<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Luyan&#39;s Bolg">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Luyan&#39;s Bolg">
<meta property="og:locale">
<meta property="article:author" content="Lu Yan">
<meta property="article:tag" content="Java, Vue3, Spring, MySQL">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/"/>





  <title>Luyan's Bolg</title>
  








<meta name="generator" content="Hexo 7.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Luyan's Bolg</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不积跬步，无以至千里；不积小流，无以成江海。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/index.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/03/Vue3%20%E7%B3%BB%E5%88%97%EF%BC%8802%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/01/03/Vue3%20%E7%B3%BB%E5%88%97%EF%BC%8802%EF%BC%89/" itemprop="url">Vue3 系列（02）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-01-03T17:33:49+08:00">
                2024-01-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="pinia-集成管理"><a href="#pinia-集成管理" class="headerlink" title="pinia 集成管理"></a>pinia 集成管理</h3><p><code>pinia</code>在 Vue 中主要充当状态管理的角色，所谓状态管理简单说就是存储数据，存储在<code>pinia</code>中的数据允许我们在各个组件使用。例如用户登录成功以后我们需要将用户的相关信息保存起来，其它的页面也有可能需要使用用户的信息，这就是一个典型的跨组件访问数据的案例。</p>
<h4 id="安装并集成"><a href="#安装并集成" class="headerlink" title="安装并集成"></a>安装并集成</h4><p>直接使用命令<code>npm i pinia</code>安装<code>pinia</code>；<br>接着我们在<code>main.ts</code>里面创建<code>pinia</code>对象并挂载到 Vue 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &quot;vue&quot;;</span><br><span class="line">import App from &quot;./App.vue&quot;;</span><br><span class="line">import &#123; createPinia &#125; from &#x27;pinia&#x27;</span><br><span class="line"></span><br><span class="line">const app = createApp(App)</span><br><span class="line">const pinia = createPinia()  // 创建 pinia 对象</span><br><span class="line">app.use(pinia)  // 安装到 app 中</span><br><span class="line">app.mount(&quot;#app&quot;);</span><br></pre></td></tr></table></figure>
<h4 id="存储并读取数据"><a href="#存储并读取数据" class="headerlink" title="存储并读取数据"></a>存储并读取数据</h4><h5 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h5><p>根据规范我们会在<code>src</code>目录下创建<code>store</code>目录用来存储相关的 TS 文件，TS 文件的命名要见名知义，例如存储用户信息的我们可以使用<code>user.ts</code>。<code>user.ts</code>样例代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 defineStore 定义一个 store 并 export 出去</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useUserStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;user&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">state</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="string">&#x27;1001&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">            <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>defineStore</code>的第一个参数是一个字符串，它是<code>store</code>的唯一标识；第二个参数是一个配置项，存储的数据需要写在<code>state</code>函数的返回值里。</p>
<h5 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h5><p>假设我想在<code>User.vue</code>组件里想要访问用户的信息，组件内部可以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;user&quot;&gt;</span><br><span class="line">        &lt;p&gt;ID：&#123;&#123; userStore.id &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;姓名：&#123;&#123; userStore.name &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;年龄：&#123;&#123; userStore.age &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;    </span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123; useUserStore &#125; from &#x27;@/store/user&#x27;</span><br><span class="line"></span><br><span class="line">    // useUserStore() 函数的返回值是一个 store 对象</span><br><span class="line">    // 存储的数据都会作为这个对象的属性存在</span><br><span class="line">    let userStore = useUserStore()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p>直接操作<code>store</code>对象，这是最简单的方式：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接操作 store 对象的 name 属性修改</span></span><br><span class="line">userStore.<span class="property">name</span> = <span class="string">&#x27;李四&#x27;</span></span><br></pre></td></tr></table></figure>
<h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p>当要操作的属性比较多的时候，按照方式一的写法代码比较臃肿。<code>pinia</code>给我们提供<code>patch</code>的方式批量修改数据：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">userStore.$patch(&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;1002&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;王五&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>$patch</code>函数传进去一个对象，对象里面就是要修改的数据。但是请注意，传的数据必须是定义在<code>store</code>里面，例如你传一个<code>score</code>会报错。</p>
<h5 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h5><p><code>pinia</code>还给我们提供<code>actions</code>用来操作存储的数据，首先我们在<code>store</code>里面配置：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useUserStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">actions</span>: &#123;  <span class="comment">// actions 里面定义若干函数操作数据</span></span><br><span class="line">        <span class="title function_">addAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">age</span> &lt; <span class="number">20</span>) &#123;  <span class="comment">// 访问数据的时候需要 this.</span></span><br><span class="line">                ++<span class="variable language_">this</span>.<span class="property">age</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">state</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="string">&#x27;1001&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">            <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们定义好<code>actions</code>之后就可以直接通过<code>store</code>对象调用这些函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useUserStore &#125; <span class="keyword">from</span> <span class="string">&#x27;@/store/user&#x27;</span></span><br><span class="line"><span class="keyword">let</span> userStore = <span class="title function_">useUserStore</span>()  <span class="comment">// 创建 store 对象</span></span><br><span class="line">userStore.<span class="title function_">addAge</span>()  <span class="comment">// 调用 addAge 函数</span></span><br></pre></td></tr></table></figure>
<p>如果只是为了修改属性而使用<code>actions</code>就比较麻烦，一般<code>actions</code>的应用场景是修改属性的逻辑比较复杂的时候，例如我们这边修改年龄的逻辑里面有一个判断。</p>
<h4 id="storeToRefs"><a href="#storeToRefs" class="headerlink" title="storeToRefs"></a>storeToRefs</h4><p>目前我们访问数据还是使用<code>userStore.</code>的方式，这个比较麻烦。于是出现下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let &#123;id, name, age&#125; = useUserStore()</span><br></pre></td></tr></table></figure>
<p>其实就是解包，但问题是这样解出来的数据会丢失响应式。理所当然想到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let &#123;id, name, age&#125; = toRefs(useUserStore())</span><br></pre></td></tr></table></figure>
<p>这样出来的数据会变为<code>Ref</code>对象，仍然具备响应式。但是<code>toRefs</code>会将<code>useUserStore()</code>返回对象里面的所有属性都变为<code>Ref</code>，这是不合理的。因为我们只想将自定义的数据变为响应式，这可以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; storeToRefs &#125; from &#x27;pinia&#x27;</span><br><span class="line">let &#123;id, name, age&#125; = storeToRefs(useUserStore())</span><br></pre></td></tr></table></figure>
<p>因此我们的标准写法是使用<code>storeToRefs</code>。</p>
<h4 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h4><p><code>pinia</code>还给我们提供了<code>getters</code>功能，可以在获取数据的时候做些操作。首先我们需要在<code>defineStore</code>的配置项里面添加<code>getters</code>配置项，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">    father(): string &#123;</span><br><span class="line">        return this.name + &#x27;父亲&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    mother(state) &#123;</span><br><span class="line">        return state.name + &#x27;母亲&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getters</code>里面定义若干函数，函数可以有一个参数<code>state</code>，我们定义的所有数据都是在这个<code>state</code>里面。<br>除了通过参数<code>state</code>获取定义的数据，还可以使用<code>this</code>关键字获取，如果定义的函数没有参数，则需要指明函数的返回值类型。</p>
<h4 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h4><p><code>pinia</code>还给我提供了订阅功能，可以监视<code>store</code>的改变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const userStore = useUserStore()</span><br><span class="line">userStore.$subscribe((_, state)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;用户发生变化&#x27;, state)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>第一个参数一般用不到所以直接定义为<code>_</code>，第二个参数<code>state</code>存着我们定义的所有数据。<br>一个通用的场景是持久化，我们可以在数据发生变化的时候将数据存到<code>localStorage</code>里面，<code>store</code>对象初始化数据的时候也从<code>localStorage</code>里面读取。</p>
<h4 id="组合式写法"><a href="#组合式写法" class="headerlink" title="组合式写法"></a>组合式写法</h4><p><code>store</code>的定义还有组合式写法，看下面例子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useUserStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;user&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> userInfo = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;1001&#x27;</span>, </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">changeUser</span>(<span class="params"></span>) &#123;</span><br><span class="line">    userInfo.<span class="property">id</span> = <span class="string">&#x27;1002&#x27;</span></span><br><span class="line">    userInfo.<span class="property">name</span> = <span class="string">&#x27;李四&#x27;</span></span><br><span class="line">    userInfo.<span class="property">age</span> = <span class="number">20</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;user.ts&#x27;</span>, userInfo.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;userInfo, changeUser&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>本来传配置项的地方现在改为一个函数，函数里面定义数据和函数，然后通过返回值返回。</p>
<h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><h4 id="props-方式"><a href="#props-方式" class="headerlink" title="props 方式"></a>props 方式</h4><p><code>props</code>主要用于父子组件间的通信，父组件向子组件传递数据是<a href="#Q0ijS">2.10</a>着重讲的内容。那么子组件想要通过<code>props</code>传递数据给父组件怎么做？其实很简单，父组件先定义一个函数，然后将这个函数通过<code>props</code>传给子组件，子组件将要传的数据作为参数调用这个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;父组件&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;自己的车：&#123;&#123; car &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;儿子的玩具：&#123;&#123; toy &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;Child :car=&quot;car&quot; :sendToy=&quot;getToy&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line">    import Child from &#x27;./Child.vue&#x27;</span><br><span class="line"></span><br><span class="line">    let car = ref(&#x27;奔驰&#x27;)</span><br><span class="line">    let toy = ref(&#x27;&#x27;)</span><br><span class="line">    function getToy(t: string) &#123;</span><br><span class="line">        toy.value = t</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;子组件&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;父亲的车：&#123;&#123; car &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;我的玩具：&#123;&#123; toy &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;button @click=&quot;sendToy(toy)&quot;&gt;把玩具传给父组件&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">    defineProps([&#x27;car&#x27;, &#x27;sendToy&#x27;])</span><br><span class="line">    let toy = ref(&#x27;奥特曼&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h4><p>自定义事件主要用于子组件传递数据给父组件，我们知道系统中定义了一些常见的事件例如点击、键盘按动、鼠标滑动等，除此之外 Vue 还支持自定义事件。例如，我们在写子组件标签的时候为其添加一个<code>get-toy</code>事件可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Child @get-toy=&quot;getToy&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>这个事件触发时执行的<code>getToy</code>函数是定义在父组件里面的，如果子组件能够在合适的时机触发这个事件那不就可以通过参数给父组件传数据了吗？那子组件该怎么和触发这个自定义事件呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">emit</span> <span class="operator">=</span> defineEmits([<span class="string">&#x27;get-toy&#x27;</span>])  <span class="comment">// 声明 get-toy 事件</span></span><br><span class="line">emit(<span class="string">&#x27;get-toy&#x27;</span>, toy.value)  <span class="comment">// 触发事件并传参</span></span><br></pre></td></tr></table></figure>
<h4 id="mitt"><a href="#mitt" class="headerlink" title="mitt"></a>mitt</h4><p><code>mitt</code>可以实现任意组件的通信，基本原理就是找一个中间人，接收数据的组件往中间人上绑定一个事件，发送数据的组件触发这个事件并将数据作为参数传递过去。<br>想要使用<code>mitt</code>，我们首先需要：</p>
<ol>
<li>使用命令<code>npm i mitt</code>安装这个模块</li>
<li>在<code>src</code>目录下创建<code>tools</code>或<code>utils</code>目录，这是一个规范不强制</li>
<li>接着在<code>tools/utils</code>目录下创建 TS 文件，我们这边就创建<code>emitter.ts</code><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mitt <span class="keyword">from</span> <span class="string">&#x27;mitt&#x27;</span></span><br><span class="line"><span class="keyword">const</span> emitter = <span class="title function_">mitt</span>()  <span class="comment">// 这就是上面说的中间人</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> emitter  <span class="comment">// 将其暴露出去，其它组件才能访问它</span></span><br></pre></td></tr></table></figure>
需要接收数据的组件在<code>emitter</code>上绑定事件如下：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">&#x27;@/tools/emitter&#x27;</span></span><br><span class="line"><span class="comment">// 绑定 send-toy 事件，并设置需要一个参数</span></span><br><span class="line">emitter.<span class="title function_">on</span>(<span class="string">&#x27;send-toy&#x27;</span>, <span class="function">(<span class="params"><span class="attr">value</span>:<span class="built_in">any</span></span>)=&gt;</span>&#123;</span><br><span class="line">    toy.<span class="property">value</span> = value</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>&#123;  <span class="comment">// 组件被卸载时应该取消绑定这个事件</span></span><br><span class="line">    emitter.<span class="title function_">off</span>(<span class="string">&#x27;send-toy&#x27;</span>)  <span class="comment">// 取消指定事件</span></span><br><span class="line">    emitter.<span class="property">all</span>.<span class="title function_">clear</span>()  <span class="comment">// 取消所有事件</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
需要发送数据的组件在合适的时机触发这个事件并将数据作为参数传过去即可：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">&#x27;@/tools/emitter&#x27;</span></span><br><span class="line">emitter.<span class="title function_">emit</span>(<span class="string">&#x27;send-toy&#x27;</span>, toy)  <span class="comment">// 触发 send-toy 事件并将数据传过去</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><p>我们会经常使用<code>v-model</code>将变量与输入框双向绑定，其实也可以对自定义组件使用<code>v-model</code>。不过这个自定义组件一般也是封装的输入框，因为用户能修改的一般也只有输入框。<br>首先我们需要明白双向绑定的本质，下面的两种写法是完全等价的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">MyInput</span> v-model=<span class="string">&quot;username&quot;</span> /&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">MyInput</span> <span class="attr">:modelValue</span>=<span class="string">&quot;username&quot;</span> @<span class="attr">update:modelValue</span>=<span class="string">&quot;username = $event&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>对一个自定义组件做<code>v-model</code>，实际上会添加<code>modelValue</code>属性和<code>update:modelValue</code>事件（事件的命名可以有<code>:</code>）。子组件<code>MyInput</code>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;input </span><br><span class="line">        type=&quot;text&quot;</span><br><span class="line">        :value=&quot;modelValue&quot;</span><br><span class="line">        @input=&quot;emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    defineProps([&#x27;modelValue&#x27;])</span><br><span class="line">    const emit = defineEmits([&#x27;update:modelValue&#x27;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>首先通过获取属性传过来的值并显示，然后当内部的输入框发生变化的时候再通过触发自定义事件将值带回去。父组件接受到新的值后，将值设置到变量中，于是就实现了双向绑定。<br>在原生事件里面<code>$event</code>表示的是事件对象，在自定义事件里<code>$event</code>就是触发事件时传递的值。<br>上面<code>v-model</code>的默认属性是<code>modelValue</code>，我们可以修改这个属性，语法很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyInput v-model:name=&quot;username&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>这边修改之后，子组件获取的属性和自定义方法就变成了<code>name</code>和<code>update:name</code>。一般来说没必要修改，但在需要双向绑定多个变量的情况下就很有用了。</p>
<h4 id="attrs"><a href="#attrs" class="headerlink" title="$attrs"></a>$attrs</h4><p><code>$attrs</code>一般用于祖孙组件互传数据，当我们通过属性给子组件传递消息的时候，子组件需要通过<code>defineProps</code>声明才能使用该变量。父组件通过属性传递的数据，未被子组件使用<code>defineProps</code>声明的变量会放到<code>$attrs</code>里面。所以我们可以将这些数据再通过属性传给孙组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;GrandChild v-bind=&quot;$attrs&quot; /&gt;</span><br><span class="line">&lt;!-- 假设 $attrs 里面装着属性 x 和 y，那么上面等价下面 --&gt;</span><br><span class="line">&lt;GrandChild :x=&quot;x&quot; :y=&quot;y&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p><code>v-bind</code>里面可以传一个对象，相当于将对象里面的值通过属性传递给子组件。因此孙组件就可以使用<code>defineProps</code>声明并使用这些变量。<br>这样就可以借助子组件使用<code>$attrs</code>实现祖到孙的通信，那么孙怎么传数据给祖呢？很简单，祖组件可以传递一个函数给孙组件，然后孙组件调用这个函数并将数据作为参数传递到祖。具体实现比较简单就不演示了。</p>
<h4 id="refs-和-parent"><a href="#refs-和-parent" class="headerlink" title="$refs 和 $parent"></a>$refs 和 $parent</h4><h5 id="refs"><a href="#refs" class="headerlink" title="$refs"></a>$refs</h5><p><a href="#pW963">2.8.3</a>讲过给子组件加<code>ref</code>属性，父组件只需要声明一个同名的空<code>ref()</code>就可以拿到子组件对象。如果组件内有较多的子组件需要去获取，我们就需要定义多个空<code>ref()</code>变量，而且操作起来也需要挨个操作。那能不能批量获取子组件并进行批量操作呢？其实是可以的，我们在父组件里面可以使用<code>$refs</code>获取所有的子组件对象，想要批量操作还可以使用循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;father&quot;&gt;</span><br><span class="line">        &lt;p&gt;父组件&lt;/p&gt;</span><br><span class="line">        &lt;!-- 通过 ref 属性给子组件命名 --&gt;</span><br><span class="line">        &lt;Child1 ref=&quot;c1&quot; /&gt;</span><br><span class="line">        &lt;Child2 ref=&quot;c2&quot; /&gt;</span><br><span class="line">        &lt;!-- 通过函数调用将 $refs 传给 JS 脚本 --&gt;</span><br><span class="line">        &lt;button @click=&quot;getChildren($refs)&quot;&gt;增加子组件的书本数目&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import Child1 from &#x27;./Child1.vue&#x27;</span><br><span class="line">    import Child2 from &#x27;./Child2.vue&#x27;</span><br><span class="line"></span><br><span class="line">    // 这边的 refs 就是模板里的 $refs，这是一个对象，里面装着所有命名的子组件 </span><br><span class="line">    function getChildren(refs: any) &#123;</span><br><span class="line">        for (let key in refs) &#123;  // 遍历所有子组件</span><br><span class="line">            refs[key].bookNum += 2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>有几个注意点：</p>
<ol>
<li>所有的<code>$</code>开头的变量都只能在模板里访问，JS 想要访问需要通过模板调用函数传参的方式</li>
<li>通过<code>$refs</code>能够获取的组件必须定义<code>ref</code>属性，否则是找不到的</li>
<li>例子里面父组件访问子组件的<code>bookNum</code>变量，那么子组件必须将其使用<code>defineExpose(&#123;bookNum&#125;)</code>暴露出来</li>
</ol>
<h5 id="parent"><a href="#parent" class="headerlink" title="$parent"></a>$parent</h5><p>子组件可以通过<code>$parent</code>获取父组件对象，当然也要通过模板传给 JS 脚本。拿到父组件对象就可以操作父组件的一些变量，前提是父组件将这些变量使用<code>defineExpose</code>暴露出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;</span><br><span class="line">        &lt;p&gt;子组件&lt;/p&gt;</span><br><span class="line">        &lt;button @click=&quot;addHouse($parent)&quot;&gt;修改父组件数据&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    function addHouse(parent: any) &#123;</span><br><span class="line">        parent.houseNum++</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="provide-和-inject"><a href="#provide-和-inject" class="headerlink" title="provide 和 inject"></a>provide 和 inject</h4><p><code>provide</code>与<code>inject</code>可以实现子孙后代之间通信，父组件通过<code>provide</code>提供数据，后代组件通过<code>inject</code>接收数据。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 以下是祖先组件内容 */</span></span><br><span class="line"><span class="keyword">import</span> &#123;ref, provide&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> money = <span class="title function_">ref</span>(<span class="number">100</span>)</span><br><span class="line"><span class="title function_">provide</span>(<span class="string">&#x27;money&#x27;</span>, money)  <span class="comment">// 祖先组件使用 provide 传递数据，两个参数分别是键与值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下是后代组件内容 */</span></span><br><span class="line"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">let</span> money = <span class="title function_">inject</span>(<span class="string">&#x27;money&#x27;</span>, <span class="number">0</span>)  <span class="comment">// inject 函数两个参数分别是键和默认值</span></span><br></pre></td></tr></table></figure>
<p>关于这种方式实现的子孙通信有一些注意点：</p>
<ol>
<li>如果父组件传递的数据是响应式的，那么子组件接收到的也是响应式的且两者是同一个对象，即子组件修改数据对父组件是可见的</li>
<li>子组件接收数据时会选择就近原则，即爷组件传递数据，父组件传递同名数据，子组件接收的时候会选择父组件的数据</li>
<li>祖先传递的数据可以被多个子孙<code>inject</code>，不存在截断现象</li>
</ol>
<h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><h5 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h5><p>假设我们要做下图的效果：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1708754859108-eb6f53f1-196a-4943-b8a1-4927b7399b9c.png#averageHue=%2370c1df&clientId=u88c9409e-bcca-4&from=paste&height=391&id=u3d0a3e34&originHeight=391&originWidth=1281&originalType=binary&ratio=1&rotation=0&showTitle=false&size=197576&status=done&style=none&taskId=u7329f2bb-5750-4647-954a-5a2b2e1d586&title=&width=1281" alt="image.png"><br>父组件里面有两个子组件，这两个子组件不完全一样。一个想法是写两个<code>.vue</code>文件表示两个组件，但是没必要，因为图中两个子组件的大体结构是一样的。那我们在子组件里面使用<code>v-if</code>或<code>v-show</code>来选择性展示？可以，但是很麻烦。更优雅的解决方案是使用插槽，父组件内的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;father&quot;&gt;</span><br><span class="line">        &lt;p&gt;父组件&lt;/p&gt;</span><br><span class="line">        &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">            &lt;Child title=&quot;热门游戏列表&quot;&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            &lt;/Child&gt;</span><br><span class="line">            &lt;Child title=&quot;每日好图&quot;&gt;</span><br><span class="line">                &lt;MyImage/&gt;</span><br><span class="line">            &lt;/Child&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;ref, reactive&#125; from &#x27;vue&#x27;</span><br><span class="line">    import Child from &#x27;./Child.vue&#x27;</span><br><span class="line">    import MyImage from &#x27;./MyImage.vue&#x27;</span><br><span class="line"></span><br><span class="line">    let games = reactive([</span><br><span class="line">        &#123;id: &#x27;1001&#x27;, name: &#x27;交错战线&#x27;&#125;,</span><br><span class="line">        &#123;id: &#x27;1002&#x27;, name: &#x27;王者荣耀&#x27;&#125;,</span><br><span class="line">        &#123;id: &#x27;1003&#x27;, name: &#x27;英雄联盟&#x27;&#125;,</span><br><span class="line">        &#123;id: &#x27;1004&#x27;, name: &#x27;斗罗大陆&#x27;&#125;,</span><br><span class="line">    ])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这个代码很简单，只不过我们在自定义组件内部写上了其它标签（可以是原生标签，也可以是自定义组件）。这些写在标签内部的内容默认并不会展现出来，因为 Vue 不知道将这些内容展示在什么地方。因此需要我们在子组件内开启插槽：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123; title &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;!-- 插槽标签，后续在本组件标签内部写东西会展现在这 --&gt;</span><br><span class="line">        &lt;slot&gt;默认内容&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    defineProps([&#x27;title&#x27;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>关于插槽有两个注意点：</p>
<ol>
<li>如果定义了多个插槽标签，那么传递的内容会展示多次。</li>
<li>我们在组件内定义了插槽，但是使用的时候没有传递内容会展示插槽内部的默认内容。</li>
</ol>
<h5 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h5><p>一般默认插槽只会定义一个，毕竟定义多个也只是将内容多复制几遍。如果我们确实想要通过插槽插入多个不同的内容该怎么做？此时可以给每一个插槽命名，然后插入的时候指定插入到哪一个插槽。<br>子组件可以通过<code>name</code>属性给插槽命名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123; title &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;!-- 给插槽起名叫 content --&gt;</span><br><span class="line">        &lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    defineProps([&#x27;title&#x27;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>父组件使用的时候给内容指定具体的插槽：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Child</span> <span class="attr">title</span>=<span class="string">&quot;热门游戏列表&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 使用 “v-slot:插槽名” 语法指定插槽 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:content</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;g in games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;g.id&quot;</span>&gt;</span>&#123;&#123; g.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Child</span> <span class="attr">title</span>=<span class="string">&quot;每日好图&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 语法糖，指定插槽可以简写成 “#插槽名” --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">template</span> #<span class="attr">content</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">MyImage</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;ref, reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">MyImage</span> <span class="keyword">from</span> <span class="string">&#x27;./MyImage.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> games = <span class="title function_">reactive</span>([</span></span><br><span class="line"><span class="language-javascript">    &#123;<span class="attr">id</span>: <span class="string">&#x27;1001&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;交错战线&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">    &#123;<span class="attr">id</span>: <span class="string">&#x27;1002&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;王者荣耀&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">    &#123;<span class="attr">id</span>: <span class="string">&#x27;1003&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;英雄联盟&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">    &#123;<span class="attr">id</span>: <span class="string">&#x27;1004&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;斗罗大陆&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">  ])</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>指定插槽的时候必须写在<code>template</code>标签上，因此往往需要包裹一层<code>&lt;template&gt;</code>。<br>学完具名插槽提一句，其实默认插槽也有名字，就叫做<code>default</code>。</p>
<h5 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h5><p>插槽出现的背景是父组件想要控制子组件的结构，上面的两种插槽都存在一个问题，那就是插槽的数据都是父组件维护。如果数据在子组件里面，但展示的格式由父组件决定，这个需求怎么实现？说白了就是子组件想给使用插槽的人传数据，子组件可以：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>每日游戏推荐<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 给 slot 标签加上属性，这个值会被传递给使用插槽的人 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:games</span>=<span class="string">&quot;games&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123;reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> games = <span class="title function_">reactive</span>([</span></span><br><span class="line"><span class="language-javascript">        &#123;<span class="attr">id</span>: <span class="string">&#x27;1001&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;交错战线&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123;<span class="attr">id</span>: <span class="string">&#x27;1002&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;王者荣耀&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123;<span class="attr">id</span>: <span class="string">&#x27;1003&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;英雄联盟&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123;<span class="attr">id</span>: <span class="string">&#x27;1004&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;斗罗大陆&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">    ])</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>父组件使用插槽的元素能够获取到传递的数据构成的对象：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Child</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 拿到的是所有数据构成的对象 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot</span>=<span class="string">&quot;params&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;g in params.games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;g.id&quot;</span>&gt;</span>&#123;&#123; g.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Child</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 接收数据的同时直接解包 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123;games&#125;&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;g in games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;g.id&quot;</span>&gt;</span>&#123;&#123; g.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>关于数据传递有几个要点：</p>
<ol>
<li>插槽可以传递若干个数据，例如<code>&lt;slot a=&quot;1&quot; b=&quot;2&quot;&gt;&lt;/slot&gt;</code>，使用插槽的人获取到的数据是这些属性构成的对象<code>&#123;a: &quot;1&quot;, b: &quot;2&quot;&#125;</code></li>
<li>对于具名插槽获取数据也是一样的写法<code>&lt;template v-slot:name=&quot;&#123;games&#125;&quot;&gt;</code></li>
</ol>
<h4 id="通信总结"><a href="#通信总结" class="headerlink" title="通信总结"></a>通信总结</h4><table>
<thead>
<tr>
<th><strong>组件关系</strong></th>
<th><strong>传递方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td>父传子</td>
<td></td>
</tr>
</tbody></table>
<ol>
<li><code>props</code></li>
<li><code>v-model</code></li>
<li><code>$refs</code></li>
<li>默认插槽、具名插槽<br> |<br>| 子传父 | </li>
<li><code>props</code></li>
<li>自定义事件</li>
<li><code>v-model</code></li>
<li><code>$parent</code></li>
<li>作用域插槽<br> |<br>| 祖孙互传 | </li>
<li><code>$attrs</code></li>
<li><code>provide、inject</code><br> |<br>| 任意组件传递 | </li>
<li><code>pinia</code></li>
<li><code>mitt</code><br> |</li>
</ol>
<h3 id="其它-API"><a href="#其它-API" class="headerlink" title="其它 API"></a>其它 API</h3><h4 id="shallow"><a href="#shallow" class="headerlink" title="shallow"></a>shallow</h4><h5 id="shallowRef"><a href="#shallowRef" class="headerlink" title="shallowRef"></a>shallowRef</h5><p>之前学过使用<code>ref</code>定义响应式对象，对象里面一个属性发生变化都会展现在界面上。本节的<code>shallowRef</code>是浅层的<code>ref</code>，它只监听数据<code>.value</code>的变化，至于更深层次的属性变化不管。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Person1：&#123;&#123; person1 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Person2：&#123;&#123; person2 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName1&quot;</span>&gt;</span>修改person1姓名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changePerson1&quot;</span>&gt;</span>修改整个person1<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName2&quot;</span>&gt;</span>修改person2姓名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changePerson2&quot;</span>&gt;</span>修改整个person2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; ref, shallowRef &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> person1 = <span class="title function_">ref</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> person2 = <span class="title function_">shallowRef</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">changeName1</span>(<span class="params"></span>) &#123;  <span class="comment">// 响应式</span></span></span><br><span class="line"><span class="language-javascript">        person1.<span class="property">value</span>.<span class="property">name</span> += <span class="string">&#x27;~&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">changePerson1</span>(<span class="params"></span>) &#123;  <span class="comment">// 响应式</span></span></span><br><span class="line"><span class="language-javascript">        person1.<span class="property">value</span> = &#123;<span class="attr">name</span>: <span class="string">&quot;王五&quot;</span>, <span class="attr">age</span>: <span class="number">60</span>&#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">changeName2</span>(<span class="params"></span>) &#123;  <span class="comment">// 非响应式！！！</span></span></span><br><span class="line"><span class="language-javascript">        person2.<span class="property">value</span>.<span class="property">name</span> += <span class="string">&#x27;!&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">changePerson2</span>(<span class="params"></span>) &#123;  <span class="comment">// 响应式</span></span></span><br><span class="line"><span class="language-javascript">        person2.<span class="property">value</span> = &#123;<span class="attr">name</span>: <span class="string">&quot;赵六&quot;</span>, <span class="attr">age</span>: <span class="number">80</span>&#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>若一个响应式变量是<code>shallowRef</code>定义的，那么只能监听<code>.value</code>的修改，至于更深的<code>.value.name</code>的修改是监听不到的。</p>
<h5 id="shallowReactive"><a href="#shallowReactive" class="headerlink" title="shallowReactive"></a>shallowReactive</h5><p><code>reactive、shallowReactive</code>之间的关系与<code>ref、shallowRef</code>之间的关系很像，对于<code>reactive</code>定义的响应式对象，我们只能修改对象的属性，如果要改的内容比较多可以借助<code>Object.assign</code>批量赋值。<code>shallowReactive</code>定义的响应式对象可以监听第一层的属性变化，监听不到内层的属性变化。具体看一个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Person1：&#123;&#123; person1 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Person2：&#123;&#123; person2 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeCar1Name&quot;</span>&gt;</span>修改person1车品牌<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeCar1&quot;</span>&gt;</span>修改整个person1整个车<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeCar2Name&quot;</span>&gt;</span>修改person2车品牌<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeCar2&quot;</span>&gt;</span>修改整个person2整个车<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; reactive, shallowReactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> person1 = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">car</span>: &#123;<span class="attr">brand</span>: <span class="string">&#x27;奔驰&#x27;</span>, <span class="attr">price</span>: <span class="number">100</span>&#125;&#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> person2 = <span class="title function_">shallowReactive</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>, <span class="attr">car</span>: &#123;<span class="attr">brand</span>: <span class="string">&#x27;宝马&#x27;</span>, <span class="attr">price</span>: <span class="number">80</span>&#125;&#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">changeCar1Name</span>(<span class="params"></span>) &#123;  <span class="comment">// 响应式</span></span></span><br><span class="line"><span class="language-javascript">        person1.<span class="property">car</span>.<span class="property">brand</span> = <span class="string">&#x27;爱玛&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">changeCar1</span>(<span class="params"></span>) &#123;  <span class="comment">// 响应式</span></span></span><br><span class="line"><span class="language-javascript">        person1.<span class="property">car</span> = &#123;<span class="attr">brand</span>: <span class="string">&#x27;丰田&#x27;</span>, <span class="attr">price</span>: <span class="number">10</span>&#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">changeCar2Name</span>(<span class="params"></span>) &#123;  <span class="comment">// 非响应式！！！</span></span></span><br><span class="line"><span class="language-javascript">        person2.<span class="property">car</span>.<span class="property">brand</span> = <span class="string">&#x27;雅迪&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">changeCar2</span>(<span class="params"></span>) &#123;  <span class="comment">// 响应式</span></span></span><br><span class="line"><span class="language-javascript">        person2.<span class="property">car</span> = &#123;<span class="attr">brand</span>: <span class="string">&#x27;大众&#x27;</span>, <span class="attr">price</span>: <span class="number">20</span>&#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>正如例子所呈现的，<code>shallowReactive</code>定义的<code>person</code>对象能监听<code>person.car</code>的变化但不能监听<code>person.car.brand</code>的变化。</p>
<h4 id="only"><a href="#only" class="headerlink" title="only"></a>only</h4><h5 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h5><p><code>readonly</code>用来生成一个响应式对象的只读副本，具体使用如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, <span class="keyword">readonly</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title function_">ref</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">car</span>: &#123;<span class="attr">brand</span>: <span class="string">&#x27;奔驰&#x27;</span>, <span class="attr">price</span>: <span class="number">100</span>&#125;&#125;)</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="title function_">readonly</span>(person1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两种写法都是错误的，因为 person2 是只读的不能修改</span></span><br><span class="line">person2.<span class="property">value</span>.<span class="property">car</span>.<span class="property">brand</span> = <span class="string">&#x27;雅迪&#x27;</span></span><br><span class="line">person2.<span class="property">value</span>.<span class="property">car</span> = &#123;<span class="attr">brand</span>: <span class="string">&#x27;大众&#x27;</span>, <span class="attr">price</span>: <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>readonly</code>生成的对象副本和原来的对象是共通的，原来的对象修改数据对副本也是可见的。</p>
<h5 id="shallowReadonly"><a href="#shallowReadonly" class="headerlink" title="shallowReadonly"></a>shallowReadonly</h5><p><code>shallowReadonly</code>会为响应式对象生成一个浅只读副本，可以修改深层次的属性，不能修改浅层次的属性。具体来说对于<code>ref</code>定义的变量，不能修改<code>.value</code>但可以修改<code>.value.name</code>之类的；对于<code>reactive</code>定义的对象，不能修改<code>.car</code>但可以修改<code>.car.name</code>。</p>
<h4 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h4><h5 id="toRaw"><a href="#toRaw" class="headerlink" title="toRaw"></a>toRaw</h5><p><code>toRaw</code>能够获得响应式对象的非响应式形式，举个例子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, toRaw &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="title function_">toRaw</span>(person1)  <span class="comment">// 返回一个非响应式的普通对象</span></span><br></pre></td></tr></table></figure>
<p>使用<code>toRaw</code>得到的就是一个普通的对象，对它修改不会作用到界面上。但是，<code>person1</code>和<code>person2</code>是互通的，<strong>其中任意一方修改数据都会影响到另一方</strong>，若响应式对象<code>person1</code>因此而改变也不会作用到页面上。</p>
<h5 id="markRaw"><a href="#markRaw" class="headerlink" title="markRaw"></a>markRaw</h5><p><code>markRaw</code>可以使一个普通对象无法变为响应式对象，例子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person1 = <span class="title function_">markRaw</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="title function_">reactive</span>(person1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1, person2)</span><br></pre></td></tr></table></figure>
<p>上面代码不会报错，但是<code>person2</code>即使使用<code>reactive</code>包裹，也不会变为响应式的，仍然是普通对象。</p>
<h4 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h4><p><code>customRef</code>是自定义<code>ref</code>，应用场景是什么呢？假设我们输入框使用<code>v-model</code>双向绑定了一个<code>ref</code>定义的响应式数据，此时我们在输入框里输入内容，新内容会立刻放到变量中。思考一个需求，我要求输入框输入新内容后延迟 1 秒将内容刷新怎么实现？延迟 1 秒显得呆呆的，我们可以把延迟 1 秒改成网络请求等其它具有实际意义的事情。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &#123;&#123; name &#125;&#125; &lt;br&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">import</span> &#123; customRef &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> initValue = <span class="string">&#x27;张三&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> name = <span class="title function_">customRef</span>(<span class="function">(<span class="params">trace, trigger</span>)=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">get</span>(<span class="params"></span>) &#123;  <span class="comment">// 访问 name 的时候会调用 get</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="title function_">trace</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="keyword">return</span> initValue</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">set</span>(<span class="params">value</span>) &#123;  <span class="comment">// 给 name 设置值的时候会调用 set</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    initValue = value</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    <span class="title function_">trigger</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                &#125;, <span class="number">1000</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>整体代码逻辑很好理解，但是有两个函数调用<code>trace()</code>与<code>trigger()</code>比较奇怪。</p>
<ul>
<li><code>trace()</code>是通知 Vue 对 name 进行监听，一旦发生变化就去更新</li>
<li><code>trigger()</code>是通知 Vue 数据发生了变化</li>
</ul>
<p>这两个函数是配套使用的，访问数据前调用<code>trace()</code>，修改数据后调用<code>trigger()</code>。<br>一般情况下，我们会将一些常用的自定义<code>ref</code>封装成<code>hook</code>方便调用。</p>
<h4 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h4><p><code>Teleport</code>是传送门标签，它能将写在里面的元素放到指定位置。看例子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Child</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Child.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>代码很简单，父组件内部维护一个子组件。按道理渲染的时候子组件是在<code>div.outer</code>内部的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 将要转移的内容写到 Teleport 标签内部，使用 to 属性指定要去的地方 --&gt;</span><br><span class="line">  &lt;Teleport to=&quot;#app&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/Teleport&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这是子组件代码，这么写之后子组件会放到<code>#app</code>对应元素内部，就移出了父组件。<code>Teleport</code>的<code>to</code>属性里面写选择器，可以是标签选择器、类选择器、ID 选择器等。</p>
<h4 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h4><h5 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h5><p>所谓全局组件就是你可以在任意一个组件内无需导入却能直接访问它，Vue3 可以在<code>main.ts</code>的<code>app</code>对象上注册全局组件：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Child.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;Child&#x27;</span>, <span class="title class_">Child</span>)  <span class="comment">// 全局注册 Child 组件</span></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>注册完毕之后，其它地方可以直接使用<code>Child</code>组件而不需要导入它。</p>
<h5 id="全局指令"><a href="#全局指令" class="headerlink" title="全局指令"></a>全局指令</h5><p>Vue 给我们提供了很多指令，例如<code>v-bind</code>、<code>v-model</code>等。其实 Vue 还支持我们自定义指令，例如我想自定义一个<code>v-beauty</code>指令仍然需要修改<code>main.ts</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"><span class="comment">// 注册 v-beauty 事件，传入一个回调，回调的参数分别是绑定的元素以及绑定的变量</span></span><br><span class="line">app.<span class="title function_">directive</span>(<span class="string">&#x27;beauty&#x27;</span>, <span class="function">(<span class="params">element, &#123;value&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">    element.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;green&#x27;</span></span><br><span class="line">    element.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;yellow&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>使用的时候可以直接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot; v-beauty=&quot;user&quot;&gt;你好！&#123;&#123; user.name &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">  import &#123;reactive&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  let user = reactive(&#123;name: &#x27;张三&#x27;&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h3><h4 id="随机字符串"><a href="#随机字符串" class="headerlink" title="随机字符串"></a>随机字符串</h4><h5 id="nanoid"><a href="#nanoid" class="headerlink" title="nanoid"></a>nanoid</h5><ol>
<li>首先安装模块<code>npm i nanoid</code></li>
<li>使用<code>nanoid</code>生成随机字符串<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123;nanoid&#125; from &#x27;nanoid&#x27;  // 导入 nanoid</span><br><span class="line">let data1 = nanoid()  // 默认生成 21 位随机字符串</span><br><span class="line">let data2 = nanoid(36)  // 指定随机字符串位数</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="uuid"><a href="#uuid" class="headerlink" title="uuid"></a>uuid</h5><ol>
<li>首先安装模块<code>npm i uuid</code></li>
<li>使用<code>uuid</code>生成随机字符串<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123;v4 as uuidv4&#125; from &#x27;uuid&#x27;  // 导包、引入 v4 函数并改名</span><br><span class="line">let d1 = uuidv4()  // 直接调用获取 uuid</span><br><span class="line">console.log(d1, d1.length)  // uuid 默认 32 位十六进制数字再加上 4 个‘-’共 36 位</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p><code>Flex</code>是<code>Flexible Box</code>的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局，即使是行内元素：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>采用<code>Flex</code>布局的元素，称为<code>Flex</code>容器（flex container），简称“容器”。容器的所有子元素自动成为容器成员，称为<code>Flex</code>项目（flex item），简称”项目”。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1708850316323-d5c308bd-1858-4b56-83a2-23e3fcdcd4a5.png#averageHue=%23f3e5c2&clientId=u55691e50-1a3c-4&from=paste&height=333&id=u58c9e6ff&originHeight=333&originWidth=563&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27719&status=done&style=none&taskId=udd504c6e-9053-44ab-8f4a-de24be191d1&title=&width=563" alt="image.png"><br>容器默认存在两根轴：水平的主轴（<code>main axis</code>）和垂直的交叉轴（<code>cross axis</code>）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。<strong>项目默认沿主轴排列</strong>，单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p>
<h5 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h5><h6 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h6><p><code>flex-direction</code>属性可以决定主轴的方向即项目的排列方向。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它有四种可能的取值：</p>
<ol>
<li><code>row</code>主轴是水平方向，起点在左侧，是<strong>默认值</strong>。</li>
<li><code>row-reverse</code>主轴是水平方向，起点在右侧。</li>
<li><code>column</code>主轴是垂直方向，起点在上沿。</li>
<li><code>column-reverse</code>主轴是垂直方向，起点在下沿。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1708869400776-56ea6a7b-adc7-4a90-bd76-1b7ee1bfd8c7.png#averageHue=%239ff4cd&clientId=u55691e50-1a3c-4&from=paste&height=326&id=u74de91c5&originHeight=326&originWidth=621&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10685&status=done&style=none&taskId=u8402e80e-950c-449b-8d4c-d4bd6f727b7&title=&width=621" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1708870917976-1fcaf683-6045-4922-bd4f-f17328f8fff6.png#averageHue=%23aff1cb&clientId=u55691e50-1a3c-4&from=paste&height=401&id=u9b90b64f&originHeight=597&originWidth=128&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6271&status=done&style=none&taskId=ud6e3368c-08dd-4d7e-959e-ee2098f2f3f&title=&width=86" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1708870939130-971df0a8-5914-468f-8c2b-b7a8f59e4401.png#averageHue=%23aff0ca&clientId=u55691e50-1a3c-4&from=paste&height=400&id=u8dc57c3f&originHeight=597&originWidth=127&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7193&status=done&style=none&taskId=u07f27863-c9c9-4404-b436-9dd60638919&title=&width=85" alt="image.png"></p>
<h6 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h6><p>一般情况下项目会排列在轴线上，使用<code>flex-wrap</code>属性可以定义轴线上排不下时该如何换行：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它有三种可能的取值：</p>
<ol>
<li><code>nowrap</code>是<strong>默认值</strong>，表示不换行。此时项目会被压缩，使其能够放到容器的一行中。</li>
<li><code>wrap</code>表示换行，第一行在上方。</li>
<li><code>wrap-reverse</code>表示换行，第一行在下方。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1708871559637-a8436eb3-4dc0-4102-9334-c1e322e2e74d.png#averageHue=%23b2f2cd&clientId=u55691e50-1a3c-4&from=paste&height=405&id=fwx3b&originHeight=693&originWidth=601&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23408&status=done&style=none&taskId=u16321ae6-ae06-4d4c-b495-a02811b6508&title=&width=351" alt="image.png"></p>
<h6 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h6><p><code>flex-flow</code>属性是<code>flex-direction</code>与<code>flex-wrap</code>属性的合并简写形式，其<strong>默认值</strong>为<code>row nowrap</code>。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h6><p><code>justify-content</code>定义了项目在主轴上的对齐方式。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它有五种可能的取值（假设主轴从左到右）：</p>
<ol>
<li><code>flex-start</code>是<strong>默认值</strong>，表示左对齐。</li>
<li><code>flex-end</code>表示右对齐。</li>
<li><code>center</code>表示水平居中对齐。</li>
<li><code>space-between</code>两端对齐（首尾项目贴边），项目之间的间隔要相等。</li>
<li><code>space-around</code>每个项目两侧间隔相等，因此最边缘的间隔是中间间隔的一半。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1708871718814-33f00893-9c22-42d1-8e5b-2a0aee582dcd.png#averageHue=%23a6f3cd&clientId=u55691e50-1a3c-4&from=paste&height=311&id=u48f42724&originHeight=311&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10586&status=done&style=none&taskId=ue56cb0b5-fd6b-4ec7-9367-2245ae382cf&title=&width=602" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1708871729517-ed5d4482-45b5-4609-a2ad-dd4b04d4b79f.png#averageHue=%23a6f3cd&clientId=u55691e50-1a3c-4&from=paste&height=400&id=u0f664aa4&originHeight=469&originWidth=599&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17325&status=done&style=none&taskId=u6cc2e22a-f82a-48c1-abf6-25f7eb0ab5c&title=&width=511" alt="image.png"></p>
<h6 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h6><p><code>align-items</code>属性定义项目在交叉轴上的对齐方式。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它有五种可能的取值（假设交叉轴自上而下）：</p>
<ol>
<li><code>flex-start</code>表示上对齐。</li>
<li><code>flex-end</code>表示下对齐。</li>
<li><code>center</code>表示竖直居中对齐。</li>
<li><code>baseline</code>项目的第一行文字的基线对齐。</li>
<li><code>stretch</code>是<strong>默认值</strong>，如果项目<strong>未设置高度或设为auto</strong>，将占满整个容器的高度。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1708872558306-1c698298-f92e-4b9d-bc35-4454982e05b0.png#averageHue=%2359fecf&clientId=u55691e50-1a3c-4&from=paste&height=507&id=u8e2de372&originHeight=507&originWidth=598&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13406&status=done&style=none&taskId=u14ce1624-15f0-4c21-ad4b-944c14143c2&title=&width=598" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1708872655439-9546c4fb-1f62-4712-9a2a-8b280ef58d04.png#averageHue=%23b3f1cb&clientId=u55691e50-1a3c-4&from=paste&height=246&id=Z1VG9&originHeight=246&originWidth=599&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6620&status=done&style=none&taskId=u4b52a577-98eb-404e-bda9-80a44373e7b&title=&width=599" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1708872601508-05f20817-526d-4121-a7d7-07781c14af4c.png#averageHue=%2393f6ce&clientId=u55691e50-1a3c-4&from=paste&height=509&id=uae552e14&originHeight=509&originWidth=597&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14096&status=done&style=none&taskId=u2dd94120-3c2c-4f3d-85cc-0027a89fe93&title=&width=597" alt="image.png"></p>
<h5 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h5><h6 id="order"><a href="#order" class="headerlink" title="order"></a>order</h6><p><code>order</code>属性定义项目的排列顺序，数值越小排列越靠前，<strong>默认为 0</strong>。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1708873614340-76f657ce-8fbf-49a0-b7fb-836988b7e6b0.png#averageHue=%23a0f1ca&clientId=u55691e50-1a3c-4&from=paste&height=151&id=xlmfk&originHeight=151&originWidth=601&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8506&status=done&style=none&taskId=u9b7d3a25-8a4b-47c0-8555-477284871e2&title=&width=601" alt="image.png"></p>
<h6 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h6><p><code>flex-grow</code>属性定义项目的放大比例。<strong>默认为 0</strong>，即使存在剩余空间，也不会放大。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>放大原理是这样的：</p>
<ol>
<li>首先满足所有的项目需求的大小；</li>
<li>剩下的空间由所有项目共享，每个项目分到多少空间由<code>flex-grow</code>设定的值决定；</li>
<li>假设一个项目的<code>grow</code>值为<code>x</code>，所有项目的<code>grow</code>之和为<code>sum</code>，那么本项目占据剩余空间的比例为<code>x / sum</code>。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1708954455731-d53debfd-19b0-48e5-9127-60303ebfb899.png#averageHue=%23f6e6bb&clientId=ud2311a5d-5ed6-4&from=paste&height=208&id=u503bcec2&originHeight=229&originWidth=602&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=7937&status=done&style=none&taskId=u056a05e1-c060-4ae8-814c-c990e56ae74&title=&width=547.2727154109106" alt="image.png"></p>
<h6 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h6><p>和<code>flex-grow</code>相对，<code>flex-shrink</code>属性定义项目的缩小比例。<strong>默认为 1</strong>，即所有项目默认情况下都等比缩小。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理也是类似的，每个项目根据<code>shrink</code>值计算出缩小的比例，然后根据比例进行缩小。<br>如果<code>shrink</code>值为 0，则表示无论如何也不缩小。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1708962633039-279f332e-dc80-4724-9657-d43e558db0de.png#averageHue=%23fbf2e5&clientId=ud2311a5d-5ed6-4&from=paste&height=219&id=szzB9&originHeight=241&originWidth=343&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=6561&status=done&style=none&taskId=u9dff5668-6dcb-437e-b386-d40ab339710&title=&width=311.8181750597049" alt="image.png"></p>
<h6 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h6><p><code>flex-basis</code>属性定义项目在主轴上的原始大小，它会覆盖<code>width</code>的值。<strong>默认值</strong>是<code>auto</code>，即使用项目本来的大小。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1709001465897-c93fa9a6-7a49-4514-b0ad-28e273a2106b.png#averageHue=%2300ffff&clientId=u55691e50-1a3c-4&from=paste&height=249&id=u87716ae0&originHeight=249&originWidth=598&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6167&status=done&style=none&taskId=u3225e199-22a4-48af-8bd0-05a7faf1335&title=&width=598" alt="image.png"></p>
<h6 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h6><p><code>flex</code>属性是<code>flex-grow、flex-shrink、flex-basis</code>的简写，默认值是<code>0 1 auto</code>。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个属性有两个快捷值：<code>auto（0 1 auto）</code>和<code>none（0 0 auto）</code>。</p>
<h6 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h6><p><code>align-self</code>允许单个项目有与其它项目不一样的对齐方式，可以覆盖容器<code>align-items</code>属性。<strong>默认值</strong>是<code>auto</code>，表示继承容器<code>align-items</code>属性值。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1709003831899-a944a657-ee07-47b3-be37-f56e214db7e0.png#averageHue=%2360f5e8&clientId=u55691e50-1a3c-4&from=paste&height=250&id=ue4277758&originHeight=250&originWidth=598&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8644&status=done&style=none&taskId=u34356611-fc0b-4219-b76f-560fcf4606b&title=&width=598" alt="image.png"></p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>传统上使用异步基本上都是借助大量的回调，当回调层数足够多时会出现“回调地狱”。假设我们有这样的需求，1 秒后打印字符串“hello”，打印完之后等 2 秒再打印“world”，打印完后再等 3 秒打印“！！！”。传统上的实现代码可以是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;!!!&quot;</span>)</span><br><span class="line">        &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>以小见大，当回调层数足够多的时候代码的可读性极低，可维护性极差。为了解决“回调地狱”问题，<code>Promise</code>就诞生了，这是一种全新的异步写法。我们可以根据构造函数创建<code>Promise</code>对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 要做的事情...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>构造函数接收一个函数作为参数，这个函数我们称为初始函数。我们会在初始函数内部写要做的操作，初始函数有两个参数<code>resolve</code>和<code>reject</code>。<code>resolve</code>是操作成功执行的回调，<code>reject</code>是操作失败执行的回调。同样的例子使用<code>Promise</code>写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">        <span class="title function_">resolve</span>()</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">            <span class="title function_">resolve</span>()</span><br><span class="line">        &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;!!!&quot;</span>)</span><br><span class="line">            <span class="title function_">resolve</span>()</span><br><span class="line">        &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>看似代码变长了很多，但是代码相对于“回调地狱”扁平化了许多，可读性大增。<br><code>Promise</code>对象有以下几个方法：</p>
<ol>
<li><code>then</code>用于处理<code>Promise</code>成功的回调，初始函数里面执行<code>resolve()</code>时就会执行这边的回调；</li>
<li><code>catch</code>用于处理<code>Promise</code>失败的回调，初始函数里面执行<code>reject()</code>时就会执行这边的回调；</li>
<li><code>finally</code>无论<code>Promise</code>是否成功，都会执行的回调；</li>
</ol>
<p>我们再看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1111</span>);</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">2222</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3333</span>;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;An error&quot;</span>;</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;).<span class="title function_">finally</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>then</code>函数可以连续调用，由于<code>then</code>指定的回调有参数，所以调用<code>resolve</code>函数的时候也传递了参数。<br>多个<code>then</code>连续调用的时候，上一个<code>then</code>的返回值作为下一个<code>then</code>的参数。<br>通过<code>throw</code>抛出异常的时候会进入最近的<code>catch</code>。<br>下面看一个高端写法，使用<code>await</code>关键字简写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params">msg, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">            <span class="title function_">resolve</span>()</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">print</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">print</span>(<span class="string">&quot;world&quot;</span>, <span class="number">2000</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">print</span>(<span class="string">&quot;!!!&quot;</span>, <span class="number">3000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>await</code>关键字后面需要跟一个<code>Promise</code>对象，它会在这个<code>Promise</code>执行结束之后再执行后面的语句，这样写异步代码就和写同步代码一样简单。<br><strong>注意：</strong>如果一个函数内部使用了<code>await</code>，那么这个函数需要使用<code>async</code>关键字修饰。<br>如果异步操作里面需要返回值应该怎么获取？很简单，直接定义变量接收即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(</span><br><span class="line">        <span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&quot;Return value&quot;</span>);  <span class="comment">// 执行成功且有返回值需要处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);  <span class="comment">// 直接在上面定义变量接收即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了<code>await</code>之后似乎没有地方写失败的回调了，该怎么做？使用<code>try...catch</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;Some error&quot;</span>; <span class="comment">// 或者 reject(&quot;Some error&quot;)</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;  <span class="comment">// 有异常会被 catch 到</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);  <span class="comment">// 会输出 Some error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>解构赋值语法是一种 JS 表达式。通过解构赋值, 可以将属性值从对象或数组中取出，赋值给其他变量。</p>
<h5 id="对象的解构"><a href="#对象的解构" class="headerlink" title="对象的解构"></a>对象的解构</h5><p>对象的解构赋值有两种写法，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准写法，冒号前面是源对象的属性名，冒号后面是要赋值的变量</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: a, <span class="attr">y</span>: b, <span class="attr">z</span>: c&#125; = obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c)  <span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写，如果源对象属性与变量同名可以简写成下面的方式</span></span><br><span class="line"><span class="keyword">let</span> &#123;x, y, z&#125; = obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x, y, z)  <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>
<p>上面的例子都是边创建变量边解构，如果想要解构给已经存在的变量可以：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x, y, <span class="title function_">z</span></span><br><span class="line">(&#123;x, y, z&#125; = obj)  <span class="comment">// 赋值表达式需要使用小括号括起来，不然会把等号左侧当做代码块会出错</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x, y, z)  <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>
<p>解构时可以为变量赋予默认值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;x, q=<span class="number">9</span>&#125; = obj  <span class="comment">// 这边给变量 q 一个默认值 9</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x, q)  <span class="comment">// 1 9</span></span><br></pre></td></tr></table></figure>
<p>当右侧对象里面没有同名属性或属性值为<code>undefined</code>时，变量会使用自己的默认值。</p>
<h5 id="数组的解构"><a href="#数组的解构" class="headerlink" title="数组的解构"></a>数组的解构</h5><p>数组的解构并不仅仅是将数组解构，解构的对象包含所有的可迭代对象，包含字符串、数组、集合、Map 等。</p>
<h6 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h6><p>字符串的赋值单位是字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> [a, b] = message;  <span class="comment">// 按顺序获取前两个元素给变量 a、b</span></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = message;  <span class="comment">// ...z 表示将剩下的所有元素全部赋给 z</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b);        <span class="comment">// H e</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x, y, z);     <span class="comment">// H e [&#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span></span><br></pre></td></tr></table></figure>
<h6 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h6><p>数组的赋值单位是元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = numbers;  <span class="comment">// 尽管 z 只能分到一个元素，但因为 ... 的存在它仍然是数组</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x, y, z);    <span class="comment">// 1 2 [3]</span></span><br></pre></td></tr></table></figure>
<h6 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h6><p>集合的赋值单位也是元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>().<span class="title function_">add</span>(<span class="string">&#x27;foo&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> [a, b] = set;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b);      <span class="comment">// foo bar</span></span><br></pre></td></tr></table></figure>
<h6 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h6><p>Map 的赋值单位是键值对组合而成的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>).<span class="title function_">set</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> [x, y] = map;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);    <span class="comment">// [&quot;a&quot;, 1] [&quot;b&quot;, 2]</span></span><br></pre></td></tr></table></figure>
<h6 id="一些小知识点"><a href="#一些小知识点" class="headerlink" title="一些小知识点"></a>一些小知识点</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> [, y, z] = data  <span class="comment">// 需要跳过某些元素时可以直接写逗号</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y, z)  <span class="comment">// 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, b, c, d=-<span class="number">1</span>] = data  <span class="comment">// 数组解构也可以有默认值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c, d)  <span class="comment">// 1 2 3 -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m, n</span><br><span class="line">[m, n] = data  <span class="comment">// 和对象解构不同，数组解构对已存在的变量解构不需要加“()”</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m, n)  <span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure>
<h5 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h5><p>嵌套解构也是支持的，我们首先看对象的嵌套解构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;ZhangSan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">scores</span>: &#123;</span><br><span class="line">        <span class="attr">math</span>: <span class="number">19</span>,</span><br><span class="line">        <span class="attr">english</span>: <span class="number">85</span>,</span><br><span class="line">        <span class="attr">chinese</span>: <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; name, <span class="attr">scores</span>: &#123;math, english, chinese&#125; &#125; = student; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name, math, english, chinese)  <span class="comment">// Zhangsan 19 85 100</span></span><br></pre></td></tr></table></figure>
<p>比较好理解，我们并没有定义<code>scores</code>变量，而是使用标准写法将源对象的<code>scores</code>属性赋值给<code>&#123;math, english, chinese&#125;</code>，这又触发了对象的解构简写。<br>对数组的解构赋值更简单，看例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> [a, [b, c, d], e] = numbers;  <span class="comment">// 直接嵌套定义数组即可</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c, d, e); <span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><h6 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">[a, b, c]</span>) &#123;  <span class="comment">// 直接在形参里解构</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="title function_">func</span>(data)</span><br></pre></td></tr></table></figure>
<h6 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;name, age&#125; = <span class="title function_">func</span>()  <span class="comment">// 直接对返回值解构</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name, age)</span><br></pre></td></tr></table></figure>
<h6 id="交换变量"><a href="#交换变量" class="headerlink" title="交换变量"></a>交换变量</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">[a, b] = [b, a]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b)</span><br></pre></td></tr></table></figure>
<h6 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> [...x] = arr  <span class="comment">// 与下面的语句等价</span></span><br><span class="line"><span class="comment">// let x = [...arr]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/01/Vue3%20%E7%B3%BB%E5%88%97%EF%BC%8801%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/01/01/Vue3%20%E7%B3%BB%E5%88%97%EF%BC%8801%EF%BC%89/" itemprop="url">Vue3 系列（01）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-01-01T17:33:49+08:00">
                2024-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><h4 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h4><ol>
<li>到<a target="_blank" rel="noopener" href="https://nodejs.org/en">官网</a>下载<code>Node.js</code>安装包并完成安装<ul>
<li>安装完成之后到控制台使用<code>node -v</code>检查是否成功。</li>
</ul>
</li>
<li><code>Windows</code>系统还需要配置<code>npm</code>的全局安装路径：<ul>
<li>以管理员身份运行命令行</li>
<li>执行命令<code>npm config set prefix &quot;E:\develop\Nodejs&quot;</code>，里面的路径换成<code>Node.js</code>的安装路径</li>
<li>执行命令<code>npm config get prefix</code>检查是否设置成功</li>
</ul>
</li>
<li>设置<code>npm</code>的淘宝镜像<code>npm config set registry [https://registry.npmmirror.com](https://registry.npmmirror.com)</code></li>
</ol>
<h4 id="基于-Vite-创建项目"><a href="#基于-Vite-创建项目" class="headerlink" title="基于 Vite 创建项目"></a>基于 Vite 创建项目</h4><p>在合适的位置打开终端，输入命令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vue<span class="meta">@latest</span></span><br></pre></td></tr></table></figure>
<p>第一次运行可能会提示安装某些包，控制台输入<code>y</code>即可。<br>接下来会出现一些定制选项，根据需求选择对应的选项即可，下面是一些参考：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1708317751018-b61a5489-d60f-46fd-9150-999ae15dff93.png#averageHue=%23343430&clientId=u6410bb4a-5bd7-4&from=paste&height=176&id=u89aa3b9e&originHeight=176&originWidth=734&originalType=binary&ratio=1&rotation=0&showTitle=false&size=134385&status=done&style=none&taskId=u84c02861-caf8-42ea-adde-41bd29cd47c&title=&width=734" alt="image.png"><br>完成之后我们的项目就创建好了，就可以使用 vscode 打开项目了。打开项目之后使用<code>sudo npm i</code>安装必要的依赖。</p>
<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><ul>
<li><code>.vscode</code>推荐安装 vscode 的插件配置</li>
<li><code>node_modules</code>安装的依赖</li>
<li><code>public</code>静态资源</li>
<li><code>src</code>源代码，我们的工作成果所在地</li>
<li><code>.gitignore</code>git 的忽略文件</li>
<li><code>env.d.ts</code>支持 ts 导入<code>.txt</code>等常见文件的配置</li>
<li><code>index.html</code>入口文件</li>
<li>包管理文件<ul>
<li><code>package-lock.json</code></li>
<li><code>package.json</code></li>
</ul>
</li>
<li>ts 配置文件<ul>
<li><code>tsconfig.app.json</code></li>
<li><code>tsconfig.json</code></li>
<li><code>tsconfig.node.json</code></li>
</ul>
</li>
<li><code>vite.config.ts</code>项目的配置文件</li>
</ul>
<h4 id="基本文件的解读"><a href="#基本文件的解读" class="headerlink" title="基本文件的解读"></a>基本文件的解读</h4><h5 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/favicon.ico&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vite App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/src/main.ts&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>界面代码很简洁，但是实际运行起来很精美。这里面比较重要的是：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/src/main.ts&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的 div 就是界面内容的渲染地，下面的 script 导入了<code>/src/main.ts</code>文件。</p>
<h5 id="src-main-ts"><a href="#src-main-ts" class="headerlink" title="src&#x2F;main.ts"></a>src&#x2F;main.ts</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./assets/main.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><code>import &#39;./assets/main.css&#39;</code>就是导入一个样式表，不太重要。<br>接下来我们着重理解一下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>我们把整个项目理解成种花，<code>createApp</code>表示花盆，<code>App</code>是组件表示花的根；那么<code>createApp(App)</code>就表示将“根”放到花盆里面，<code>.mount(&#39;#app&#39;)</code>表示将花盆放置到<code>index.html</code>的<code>#app</code>元素内。在<code>src/components</code>目录下放着很多自定义的组件，这些组件可以理解成花的枝枝叶叶。<br>所以实际上这么写完之后，运行起来会展示<code>index.html</code>，页面的<code>#app</code>里面会展示<code>App</code>这个组件，我们可以在这个组件里面导入更多其它组件使页面变得丰富。</p>
<h3 id="核心语法"><a href="#核心语法" class="headerlink" title="核心语法"></a>核心语法</h3><h4 id="新旧-Vue"><a href="#新旧-Vue" class="headerlink" title="新旧 Vue"></a>新旧 Vue</h4><h5 id="Vue2-Demo"><a href="#Vue2-Demo" class="headerlink" title="Vue2 Demo"></a>Vue2 Demo</h5><p>首先我们在<code>/src/components</code>目录下创建一个组件<code>Person.vue</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; age &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;点击修改姓名&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeAge&quot;&gt;点击修改年龄&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;showTel&quot;&gt;点击显示电话&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;  // 数据要定义在 data 函数的返回值里</span><br><span class="line">                name: &quot;张三&quot;,</span><br><span class="line">                age: 18,</span><br><span class="line">                tel: 18888888888</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;  // 函数定义在 methods 属性里</span><br><span class="line">            changeName() &#123;</span><br><span class="line">                // 读取数据域定义的字段，需要加 this.</span><br><span class="line">                this.name = &quot;李四&quot;;</span><br><span class="line">            &#125;,</span><br><span class="line">            changeAge() &#123;</span><br><span class="line">                // 字段是响应式的，修改变量的值，界面上也会更改</span><br><span class="line">                this.age += 1;</span><br><span class="line">            &#125;,</span><br><span class="line">            showTel() &#123;</span><br><span class="line">                alert(this.tel)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>一个组件里面可以写三类标签，分别是：</p>
<ul>
<li><code>template</code>用于书写 HTML 框架</li>
<li><code>script</code>用于写交互的内容</li>
<li><code>style</code>用于指定样式</li>
</ul>
<p>接着我们在<code>App.vue</code>里面引用这个组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;!-- 因为下面注册过这个组件，所以可以直接使用 --&gt;</span><br><span class="line">    &lt;Person /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">    // 导入 Person 组件，import 后面只是起的一个名字，可随意</span><br><span class="line">    import Person from &quot;./components/Person.vue&quot;</span><br><span class="line"></span><br><span class="line">    export default &#123;</span><br><span class="line">        // 将 Person 组件注册到 components 属性里面，才可以使用这个标签</span><br><span class="line">        components: &#123;Person&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="Vue3-Demo"><a href="#Vue3-Demo" class="headerlink" title="Vue3 Demo"></a>Vue3 Demo</h5><p>我们将<code>Person.vue</code>代码修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; age &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;点击修改姓名&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeAge&quot;&gt;点击修改年龄&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;showTel&quot;&gt;点击显示电话&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        setup() &#123;</span><br><span class="line">            // 定义数据</span><br><span class="line">            let name = &quot;张三&quot;;</span><br><span class="line">            let age = 18;</span><br><span class="line">            let tel = 18888888888;</span><br><span class="line"></span><br><span class="line">            // 定义方法</span><br><span class="line">            function changeName() &#123;</span><br><span class="line">                name = &quot;李四&quot;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            function changeAge() &#123;</span><br><span class="line">                age += 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            function showTel() &#123;</span><br><span class="line">                alert(tel)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return &#123;name, age, changeName, changeAge, showTel&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>Vue3 里面并没有把数据与函数分隔，它们都统一定义在<code>setup</code>函数里面。<br><code>setup</code>的返回值是一个对象，用来指定需要暴露出去的变量或函数，此外<code>setup</code>弱化了<code>this</code>，因此定义的函数访问变量均<strong>不能</strong>使用<code>this.</code>。<br><code>App.vue</code>可以不改，但是如果使用 Vue3 的推荐写法应该：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;Person /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    // setup 里面导入的内容都会默认交出去</span><br><span class="line">    import Person from &quot;./components/Person.vue&quot;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>像例子中一样直接定义的变量（<code>let age = 18</code>）均不是响应式的，即修改变量的值，在界面上并不会改变。</p>
<h5 id="Vue2-与-Vue3-混合"><a href="#Vue2-与-Vue3-混合" class="headerlink" title="Vue2 与 Vue3 混合"></a>Vue2 与 Vue3 混合</h5><p><code>setup</code>初始化的时候很早，甚至早于<code>beforeCreate</code>。因此<code>setup</code>要早于<code>data</code>和<code>methods</code>加载，于是出现了以下问题：</p>
<ol>
<li><code>setup</code>能否与<code>data/methods</code>共存？<ul>
<li>答：能。<code>setup</code>是 Vue3 的推荐写法，<code>data/methods</code>是 Vue2 的写法，在 Vue3 里面两者均支持，也能同时出现。模板渲染的时候两种方式也都能拿到数据。</li>
</ul>
</li>
<li><code>data/methods</code>里面是否可以引用<code>setup</code>里面定义的数据或函数？<ul>
<li>答：可以，因为在计算<code>data/methods</code>的时候<code>setup</code>已经加载完毕，里面的数据当然可以拿到。但是使用<code>data/methods</code>获取数据需要使用<code>this.</code>。</li>
</ul>
</li>
<li><code>setup</code>里面能否引用<code>data/methods</code>里的数据或函数？<ul>
<li>答：不能，因为计算<code>setup</code>的时候，<code>data/methods</code>还没有计算，当然取不到内容。</li>
</ul>
</li>
</ol>
<h4 id="setup-语法糖"><a href="#setup-语法糖" class="headerlink" title="setup 语法糖"></a>setup 语法糖</h4><p>我们在 Vue3 里面基本不推荐<code>data/methods</code>的写法，都是推荐将变量、函数定义在<code>setup</code>里面。但是<code>setup</code>函数里面需要将暴露出去的变量函数等通过返回值返回，这个比较麻烦。于是出现了<code>setup</code>语法糖，下面两种写法是等价的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        setup() &#123;</span><br><span class="line">            // 定义数据</span><br><span class="line">            let age = 18;</span><br><span class="line">            // 定义方法</span><br><span class="line">            function changeAge() &#123;</span><br><span class="line">                age += 1;</span><br><span class="line">            &#125;</span><br><span class="line">            return &#123;age, changeAge&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    // 定义数据</span><br><span class="line">    let age = 18;</span><br><span class="line">    // 定义方法</span><br><span class="line">    function changeAge() &#123;</span><br><span class="line">        age += 1;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>就是在<code>script</code>标签里面加一个<code>setup</code>就可以了，标签里面的所有内容相当于写在原来的<code>setup</code>函数里面且都会暴露出去。<br>这样书写确实非常方便，但是语法糖里面不能再写<code>export</code>了。一般来说这不是什么问题，但在某些情况下我们会需要修改组件的名字，因为默认情况下什么都不做组件会与文件同名。于是有下面的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;Person_new&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    let name = &quot;张三&quot;;</span><br><span class="line">    // 其它内容</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>我们新开一个<code>script</code>标签，export 出去一个 name 用于指定组件的名字。<br>一般便于在 Chrome 的 Vue 插件里面查看。<br>这样写还是比较麻烦的，需要写两个<code>script</code>标签，而其中一个<code>script</code>标签仅仅用于修改组件名称。我们可以通过使用一个插件简化书写：</p>
<ol>
<li>使用<code>npm i vite-plugin-vue-setup-extend -D</code>命令安装插件</li>
<li>在<code>vite.comfig.ts</code>里面配置这个插件：<ol>
<li>导入插件<code>import VueSetupExtend from &#39;vite-plugin-vue-setup-extend&#39;</code></li>
<li>在<code>plugins</code>里面追加调用<code>VueSetupExtend()</code></li>
</ol>
</li>
<li>在<code>script</code>标签使用<code>name</code>属性指定组件名<code>&lt;script setup lang=&quot;ts&quot; name=&quot;PersonSuper&quot;&gt;</code></li>
</ol>
<h4 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h4><p>上面我们说过在<code>setup</code>里面定义的数据都不是响应式的，对它们做修改之后界面上展示的是不变的。接下来我们介绍响应式数据应该怎么定义和操作。</p>
<h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><p>Vue3 里面将基本数据类型转为响应式需要借助<code>ref</code>，看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; count &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;addCount&quot;&gt;点击修改数字&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;ref&#125; from &#x27;vue&#x27;  // 导入 ref</span><br><span class="line"></span><br><span class="line">    let count = ref(0)  // 将基本数据类型使用 ref 包裹起来就变成响应式数据了</span><br><span class="line">    function addCount() &#123;</span><br><span class="line">        count.value += 1;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>实际上<code>ref</code>是一个函数，它返回一个<code>RefImpl</code>对象，我们传进去的值会存在对象的<code>value</code>属性里。因此在 js 代码中我们想要修改这个值，需要使用<code>xxx.value = yyy</code>的写法。但是在模板的插值表达式里面不需要额外的调用<code>.value</code>，因为表达式会自己调用。</p>
<h5 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h5><p>对象类型的数据要是想转为响应式，有两种方式分别是<code>ref</code>和<code>reactive</code>。这边说的对象，只要不是基本数据类型都是对象类型，例如数组、函数、原生对象等等。</p>
<h6 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h6><p>和<code>ref</code>类似，我们只需要将对象使用<code>reactive</code>函数包裹起来就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; car.name &#125;&#125;, &#123;&#123; car.price &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;addPrice&quot;&gt;点击修改价格&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;reactive&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">    let car = reactive(&#123;name: &quot;奔驰&quot;, price: 100&#125;)</span><br><span class="line">    function addPrice() &#123;</span><br><span class="line">        car.price += 10</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><code>reactive</code>函数会返回一个<code>Proxy</code>对象，和<code>ref</code>不一样的是我们获取对象属性的时候不需要<code>.value</code>之类的，还像原来那样获取。包括获取数组元素的时候仍然使用类似于<code>cars[0]</code>这样的写法，不需要添加任何多余的部分。</p>
<h6 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h6><p><code>ref</code>除了可以创建响应式基本数据，还可以创建响应式对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h2 v-for=&quot;car in cars&quot; :key=&quot;car.name&quot;&gt;&#123;&#123; car.name &#125;&#125;, &#123;&#123; car.price &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;addPrice&quot;&gt;点击修改第一辆车价格&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;ref&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">    let cars = ref([</span><br><span class="line">        &#123;name: &quot;奔驰&quot;, price: 100&#125;,</span><br><span class="line">        &#123;name: &quot;宝马&quot;, price: 50&#125;,</span><br><span class="line">        &#123;name: &quot;奥迪&quot;, price: 80&#125;</span><br><span class="line">    ])</span><br><span class="line">    function addPrice() &#123;</span><br><span class="line">        cars.value[0].price += 10</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>如果使用<code>ref</code>创建响应式对象，我们在 js 代码里面操作这个对象的时候仍然是需要先<code>.value</code>的。当然在插值表达式里面是不需要的，表达式仍然会帮我们自动计算。<br>事实上<code>ref</code>是借助于<code>reactive</code>实现响应式对象的，它会先使用<code>reactive</code>函数包裹对象生成<code>Proxy</code>对象，然后将这个对象赋值给<code>RefImpl</code>的<code>value</code>属性。<br>我们这个例子里面简要写了一个循环渲染，使用<code>v-for</code>来对一个数组进行循环遍历，注意循环的时候需要给标签加一个<code>key</code>属性作为当前标签的唯一标识。一般我们会使用<code>:key</code>，这个全称<code>v-bind:key</code>，这样写的话后面的值会当做 js 表达式解析，不然的话只会当做普通字符串。</p>
<h5 id="ref-踩坑"><a href="#ref-踩坑" class="headerlink" title="ref 踩坑"></a>ref 踩坑</h5><p>假设有一个变量<code>let count = ref(0)</code>，我们一般使用<code>count.value = 9</code>的写法来修改这个变量。那如果我写出下面的代码会怎么样？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count = 9  // 这种写法 count 会变成普通变量，不是响应式的</span><br><span class="line"></span><br><span class="line">// 看上去没有问题，实际上界面数据仍然和原来的 ref 绑定，所以这样写也不是响应式的</span><br><span class="line">count = ref(9)  </span><br></pre></td></tr></table></figure>
<p>总结：不论使用<code>ref</code>包裹基本数据类型还是对象，修改变量的时候我们都应该修改<code>.value</code>而不是变量本身。只要修改的是<code>.value</code>，那么不论包裹的类型都是响应式的。<br>比较麻烦的是每次我们都需要自己写<code>.value</code>，我们可以在插件里面配置，让编译器自动追加<code>.value</code>，看下图配置：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1708351496371-5819ad20-0795-43fc-944a-8a64134bdbf0.png#averageHue=%23e6ddca&clientId=u3ed3b8a8-f739-4&from=paste&height=878&id=ud9948c90&originHeight=878&originWidth=1131&originalType=binary&ratio=1&rotation=0&showTitle=false&size=338425&status=done&style=none&taskId=uaa749988-b050-4d77-b78b-31b2f10844f&title=&width=1131" alt="image.png"></p>
<h5 id="reactive-踩坑"><a href="#reactive-踩坑" class="headerlink" title="reactive 踩坑"></a>reactive 踩坑</h5><p>和<code>ref</code>相似，修改<code>reactive</code>包裹的对象时应该修改对象内部的东西，而不是这个对象的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">let</span> <span class="variable">cars</span> <span class="operator">=</span> reactive([...])</span><br><span class="line">cars[<span class="number">1</span>] = &#123;...&#125;  <span class="comment">// 合理，修改数组的元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">let</span> <span class="variable">car</span> <span class="operator">=</span> reactive(&#123;...&#125;)</span><br><span class="line">car.name = <span class="string">&#x27;...&#x27;</span>  <span class="comment">// 合理，修改对象的属性</span></span><br><span class="line"></span><br><span class="line"><span class="type">let</span> <span class="variable">car</span> <span class="operator">=</span> reactive(&#123;...&#125;)</span><br><span class="line">car = &#123;...&#125;  <span class="comment">// 错误，car 变量引用被修改了</span></span><br><span class="line">car = reactive(&#123;...&#125;)  <span class="comment">// 错误，car 变量引用被修改了</span></span><br></pre></td></tr></table></figure>
<p>很多时候，我们确实需要修改整个对象。比如某个变量有一个初值，后面服务请求获取到数据再覆盖掉这个值，此时不可能挨个属性赋值，太麻烦，我们可以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let car = reactive(&#123;...&#125;)</span><br><span class="line">car = Object.assign(car, &#123;...&#125;)</span><br></pre></td></tr></table></figure>
<p><code>Object.assign</code>函数可以有任意多参数，它可以把后面所有对象的属性都添加到第一个对象里，如果有同名属性会覆盖，后面对象的同名属性覆盖前面对象的。</p>
<h5 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h5><p>基本数据类型响应式：只能使用<code>ref</code>；<br>对象类型响应式：</p>
<ul>
<li>对象层级较浅，<code>ref</code>和<code>reactive</code>均可</li>
<li>对象层级较深，推荐使用<code>reactive</code></li>
</ul>
<h4 id="toRefs-toRef"><a href="#toRefs-toRef" class="headerlink" title="toRefs&#x2F;toRef"></a>toRefs&#x2F;toRef</h4><h5 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h5><p><code>toRefs</code>主要用于解构赋值时，让解构出来的变量也具备响应式。首先如果我们直接解构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">let</span> <span class="variable">person</span> <span class="operator">=</span> reactive(&#123;name: <span class="string">&quot;张三&quot;</span>, age: <span class="number">19</span>, score: <span class="number">100</span>&#125;)</span><br><span class="line">let &#123;name, age, score&#125; = person</span><br><span class="line"><span class="comment">/** 第二行代码就相当于：</span></span><br><span class="line"><span class="comment">    name = person.name</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>很显然解构出来的变量只是普通变量，并不是响应式的。想要让解构变量是响应式的可以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123;reactive, toRefs&#125; from &#x27;vue&#x27;</span><br><span class="line">let person = reactive(&#123;name: &quot;张三&quot;, age: 19, score: 100&#125;)</span><br><span class="line">let &#123;name, age, score&#125; = toRefs(person)</span><br></pre></td></tr></table></figure>
<p>使用<code>toRefs</code>将对象包裹起来，这样解构出来的变量直接就是<code>RefImpl</code>，并且解构的变量与原来对象的属性是同一的。也就是说，<code>name</code>和<code>person.name</code>的变化是互通，要变一起变。</p>
<h5 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h5><p><code>toRef</code>功能和<code>toRefs</code>类似，不过<code>toRefs</code>能将对象所有属性全部解构出来，而<code>toRef</code>只能解构一个属性。当然解构出来的变量也原来的对象属性也是同一，因此也是响应式的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;change&quot;&gt;修改人员信息&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123;reactive, toRef&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">    let person = reactive(&#123;name: &quot;张三&quot;&#125;)</span><br><span class="line">    let name = toRef(person, &quot;name&quot;)  // 指定要解构的属性</span><br><span class="line">    function change() &#123;</span><br><span class="line">        name.value = &quot;李四&quot;  // 模板里面会变，因为 name 与 person.name 同一变化</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><p>很多时候我们定义的变量不是直接赋值的，而是依据某些其它变量的值计算得来的。看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    姓：&lt;input v-model=&quot;firstName&quot; /&gt; &lt;br&gt;</span><br><span class="line">    名：&lt;input v-model=&quot;lastName&quot; /&gt; &lt;br&gt;</span><br><span class="line">    全名：&#123;&#123; fullName &#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;ref, computed&#125; from &#x27;vue&#x27;</span><br><span class="line">    let firstName = ref(&quot;&quot;)</span><br><span class="line">    let lastName = ref(&quot;&quot;)</span><br><span class="line">    let fullName = computed(()=&gt;&#123;  // 传进去一个计算函数</span><br><span class="line">        return firstName.value + &quot;-&quot; + lastName.value</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>代码不难看出，变量<code>firstName</code>与<code>lastName</code>分别与两个输入框双向绑定。变量<code>fullName</code>是一个计算属性，它的值有姓与名组合而成，它的使用很简单就是把计算的函数传到<code>computed</code>里面。这样写，姓与名每次发生变化，都会触发重新计算<code>fullName</code>。<br><code>fullName</code>的类型实际是<code>ComputedRefImpl</code>，而<code>ComputedRefImpl</code>的<code>value</code>属性是只读的，因此无法给<code>fullName.value</code>赋值。<br>如果我想实现给<code>fullName</code>传一个值，然后根据值自动修改<code>firstName</code>与<code>lastName</code>可以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    姓：&lt;input v-model=&quot;firstName&quot; /&gt; &lt;br&gt;</span><br><span class="line">    名：&lt;input v-model=&quot;lastName&quot; /&gt; &lt;br&gt;</span><br><span class="line">    全名：&#123;&#123; fullName &#125;&#125; &lt;br&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;直接给全名赋值&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;ref, computed&#125; from &#x27;vue&#x27;</span><br><span class="line">    let firstName = ref(&quot;&quot;)</span><br><span class="line">    let lastName = ref(&quot;&quot;)</span><br><span class="line">    let fullName = computed(&#123;</span><br><span class="line">        get() &#123;  // 读取值</span><br><span class="line">            return firstName.value + &quot;-&quot; + lastName.value</span><br><span class="line">        &#125;,</span><br><span class="line">        set(val) &#123;  // 设置值</span><br><span class="line">            // 实际上也是改变与它相关的其它变量而不是直接变它自己</span><br><span class="line">            ([firstName.value, lastName.value] = val.split(&quot;-&quot;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    function changeName() &#123;</span><br><span class="line">        fullName.value = &quot;li-si&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p><code>watch</code>可以监视数据的变化，Vue3 中的<code>watch</code>只能监视下面 4 种数据：</p>
<ol>
<li><code>ref</code>定义的数据；</li>
<li><code>reactive</code>定义的数据；</li>
<li>函数返回一个值；</li>
<li>包含上述内容的数组；</li>
</ol>
<p>分情况的话具体可以分为 5 种情况。</p>
<h5 id="ref-定义的基本类型数据"><a href="#ref-定义的基本类型数据" class="headerlink" title="ref 定义的基本类型数据"></a>ref 定义的基本类型数据</h5><p>使用<code>watch</code>监视<code>ref</code>定义的基本类型数据，看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123; sum &#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;button @click=&quot;add&quot;&gt;点我 sum+1&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">  // 导入 watch</span><br><span class="line">  import &#123;ref, watch&#125; from &#x27;vue&#x27;</span><br><span class="line">  let sum = ref(0)</span><br><span class="line">  function add() &#123;</span><br><span class="line">    sum.value++</span><br><span class="line">  &#125;</span><br><span class="line">  // 第一个参数是监视源，注意没有加 .value</span><br><span class="line">  // 第二个参数是一个回调函数，函数两个参数分别表示新值与旧值</span><br><span class="line">  watch(sum, (newVal, oldVal)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;sum 变化了：&#x27;, newVal, oldVal)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>使用还是比较简单的，那么如果满足一定条件我就想取消监视怎么办？例如当<code>sum ≥ 10</code>时停止监视，js 代码可以改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let stopWatch = watch(sum, (newVal, oldVal)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;sum 变化了：&#x27;, newVal, oldVal)</span><br><span class="line">    if (newVal &gt;= 10) stopWatch()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>主要用到<code>watch</code>函数的返回值，它会返回一个函数，调用这个函数就可以取消监视。</p>
<h5 id="ref-定义的对象类型数据"><a href="#ref-定义的对象类型数据" class="headerlink" title="ref 定义的对象类型数据"></a>ref 定义的对象类型数据</h5><p>大体写法和上面的类似，直接看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeInfo&quot;&gt;修改信息&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeRef&quot;&gt;修改引用&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;ref, watch&#125; from &#x27;vue&#x27;</span><br><span class="line">    let person = ref(&#123;name: &quot;张三&quot;, age: 18&#125;)</span><br><span class="line"></span><br><span class="line">    function changeInfo() &#123;</span><br><span class="line">        person.value.age = 20</span><br><span class="line">        person.value.name = &quot;李四&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    function changeRef() &#123;</span><br><span class="line">        person.value = &#123;name: &quot;王五&quot;, age: 10&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    watch(person, (newVal, oldVal)=&gt;&#123;</span><br><span class="line">        console.log(&quot;person 改变了&quot;, newVal, oldVal)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>在这个案例里面点击“修改信息”是不会触发监听的，而“修改引用”是会触发的。因此可以看出我们这样的默认写法，<strong>只会监听</strong><code>**ref**</code><strong>对象</strong><code>**value**</code><strong>的修改，而不会监听原对象里面各个属性的修改</strong>。<br>在大部分情况下，我们需要监听对象内部属性的变化，此时就需要给<code>watch</code>函数传进去第三个参数。这第三个参数是一个对象，用来配置<code>watch</code>函数的行为，主要可以配置：</p>
<ul>
<li><p><code>deep</code>表示是否深度监听，设为<code>true</code>就可以监听对象的属性变化</p>
</li>
<li><p><code>immediate</code>表示是否立刻触发监听，设为<code>true</code>就可以立刻监听这个对象，初次<code>oldVal</code>为<code>undefined</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(person, (newVal, oldVal)=&gt;&#123;</span><br><span class="line">    console.log(&quot;person 改变了&quot;, newVal, oldVal)</span><br><span class="line">&#125;, &#123;deep: true, immediate: true&#125;)</span><br></pre></td></tr></table></figure>
<p>我们在监听的时候会拿到两个值<code>newVal</code>和<code>oldVal</code>，分别表示改动后的新值和改动前的旧值。但是这两个值都是返回<code>ref</code>的<code>value</code>值：</p>
</li>
<li><p>当我们修改这个<code>value</code>值的时候，<code>newVal</code>和<code>oldVal</code>分别表示修改前后的两个对象。</p>
</li>
<li><p>当我们修改的是对象里面属性的时候（<code>person.value.name=&quot;zs&quot;</code>），<code>newVal</code>和<code>oldVal</code>指向的就是同一个对象，因此两者的内容是完全一样的。</p>
</li>
</ul>
<p>大多数时候我们并不会关注旧值是什么，因此一般只写一个参数表示新值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(person, (newVal)=&gt;&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;, &#123;deep: true, immediate: true&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="reactive-定义的对象数据"><a href="#reactive-定义的对象数据" class="headerlink" title="reactive 定义的对象数据"></a>reactive 定义的对象数据</h5><p>监听<code>reactive</code>定义的对象数据的时候，只能监听对象属性的改变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeInfo&quot;&gt;修改信息&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeRef&quot;&gt;修改引用&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;reactive, watch&#125; from &#x27;vue&#x27;</span><br><span class="line">    let person = reactive(&#123;name: &quot;张三&quot;, age: 18&#125;)</span><br><span class="line"></span><br><span class="line">    function changeInfo() &#123;  // 直接修改属性</span><br><span class="line">        person.age = 20</span><br><span class="line">        person.name = &quot;李四&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    function changeRef() &#123;</span><br><span class="line">        // 通过 Object.assign 批量添加/修改属性</span><br><span class="line">        person = Object.assign(person, &#123;name: &quot;王五&quot;, age: 10&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    watch(person, (newVal, oldVal)=&gt;&#123;</span><br><span class="line">        console.log(&quot;person 改变了&quot;, newVal, oldVal)</span><br><span class="line">    &#125;, &#123;immediate: true&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>例子中两种修改方式都没有改变变量<code>person</code>的引用，都是在修改<code>person</code>指向对象的内容。监听<code>reactive</code>定义的对象默认是开启深度监视的（监听属性变化），且深度监视是关不掉的。即使你在配置里面传入<code>deep: false</code>也是无效的。因为不涉及修改对象的引用，所以<code>newVal</code>和<code>oldVal</code>也是同一个对象。不论使用<code>ref</code>还是<code>reactive</code>，我们都不能直接给变量赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">let</span> <span class="variable">person</span> <span class="operator">=</span> ref(&#123;...&#125;)</span><br><span class="line"><span class="type">let</span> <span class="variable">person</span> <span class="operator">=</span> reactive(&#123;...&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种写法错误，第一这样 person 不是响应式，第二监听不了</span></span><br><span class="line">person = &#123;...&#125;</span><br></pre></td></tr></table></figure>
<h5 id="监视属性"><a href="#监视属性" class="headerlink" title="监视属性"></a>监视属性</h5><p>上面都是监视整个对象，如果我们想要监视的是响应式对象里面（<code>ref</code>和<code>reactive</code>）的某个属性怎么做？这个需要区分该属性是基本类型还是对象类型：</p>
<h6 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;button @click=&quot;changeName&quot;&gt;修改姓名&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">  import &#123;reactive, watch&#125; from &#x27;vue&#x27;</span><br><span class="line">  let person = reactive(&#123;name: &quot;张三&quot;, cars: &#123;c1: &quot;奔驰&quot;, c2: &quot;宝马&quot;&#125;&#125;)</span><br><span class="line"></span><br><span class="line">  function changeName() &#123;</span><br><span class="line">    person.name = &quot;李四&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  watch(()=&gt;person.name, (newVal)=&gt;&#123;</span><br><span class="line">    console.log(&quot;姓名发生了变化：&quot;, newVal)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>主要看监视器部分，我们第一个参数也就是监视源并没有直接写<code>person.name</code>，因为<code>person.name</code>是基本数据类型，不能被监视。能监视的类型里面有一种是返回一个值的函数，因此我们将这个属性包装成一个值（简写成箭头函数）。</p>
<h6 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h6><p>上面使用<code>reactive</code>举例子，现在使用<code>ref</code>举例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123; person.cars.c1 &#125;&#125;、&#123;&#123; person.cars.c2 &#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;button @click=&quot;changeCar1&quot;&gt;修改第一台车&lt;/button&gt;</span><br><span class="line">  &lt;button @click=&quot;changeCars&quot;&gt;修改车列表&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">  import &#123;ref, watch&#125; from &#x27;vue&#x27;</span><br><span class="line">  let person = ref(&#123;name: &quot;张三&quot;, cars: &#123;c1: &quot;奔驰&quot;, c2: &quot;宝马&quot;&#125;&#125;)</span><br><span class="line">  function changeCar1() &#123;</span><br><span class="line">    person.value.cars.c1 = &quot;奥迪&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  function changeCars() &#123;</span><br><span class="line">    person.value.cars = &#123;c1: &quot;雅迪&quot;, c2: &quot;爱玛&quot;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  watch(person.value.cars, (newVal)=&gt;&#123;</span><br><span class="line">    console.log(&quot;姓名发生了变化：&quot;, newVal, person.value.cars)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>监视的时候监视源直接写<code>person.value.cars</code>，这样是可以的，因为一个响应式对象里面某个属性如果也是一个对象，那么这个属性也是响应式的，简单说<code>person.value.cars</code>也是响应式的。<br>和监视一个响应式对象一样，这样写有一个问题，我们只能监视对象内部属性的修改，若是直接改变这个对象是无法监视的，也就是说<code>person.value.cars = &#123;...&#125;</code>是监视不到的。<br>如果想要监视对象本身，可以改为函数式监视：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(()=&gt;person.value.cars, (newVal)=&gt;&#123;</span><br><span class="line">  console.log(&quot;姓名发生了变化：&quot;, newVal, person.value.cars)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>改为函数式监视之后有监视不到内部属性的变化了，此时可以再开启深度监视：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(()=&gt;person.value.cars, (newVal)=&gt;&#123;</span><br><span class="line">  console.log(&quot;姓名发生了变化：&quot;, newVal, person.value.cars)</span><br><span class="line">&#125;, &#123;deep: true&#125;)</span><br></pre></td></tr></table></figure>
<p>所以不论监视的属性是基本数据类型还是对象，都建议使用函数式监视。</p>
<h5 id="监视数组"><a href="#监视数组" class="headerlink" title="监视数组"></a>监视数组</h5><p>数组就比较简单了，把能监视的对象放到一个数组里面统一监视。依然使用上面的例子，假设我们现在想要监视姓名和第一辆车应该怎么做？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123; person.cars.c1 &#125;&#125;、&#123;&#123; person.cars.c2 &#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;button @click=&quot;changeName&quot;&gt;修改姓名&lt;/button&gt;</span><br><span class="line">  &lt;button @click=&quot;changeCar1&quot;&gt;修改第一台车&lt;/button&gt;</span><br><span class="line">  &lt;button @click=&quot;changeCars&quot;&gt;修改车列表&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">  import &#123;reactive, watch&#125; from &#x27;vue&#x27;</span><br><span class="line">  let person = reactive(&#123;name: &quot;张三&quot;, cars: &#123;c1: &quot;奔驰&quot;, c2: &quot;宝马&quot;&#125;&#125;)</span><br><span class="line">  function changeName() &#123;</span><br><span class="line">    person.name = &quot;李四&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  function changeCar1() &#123;</span><br><span class="line">    person.cars.c1 = &quot;奥迪&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  function changeCars() &#123;</span><br><span class="line">    person.cars = &#123;c1: &quot;雅迪&quot;, c2: &quot;爱玛&quot;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  watch([()=&gt;person.name, ()=&gt;person.cars.c1], (newVal, oldVal)=&gt;&#123;</span><br><span class="line">    console.log(&quot;发生了变化：&quot;, newVal, oldVal)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>数组元素必须是可监听对象，因此对于基本数据类型还是使用函数式监听。例子里面三个函数都能触发监听，尤其是第三个函数直接修改<code>cars</code>也能被监听<code>c1</code>的监听器捕获到。</p>
<h4 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h4><p><code>watchEffect</code>也是监视，不过与<code>watch</code>不同。<code>watch</code>监视的时候需要传递监视源，而<code>watchEffect</code>不需要，它会根据回调函数内部使用的变量自动推断有哪些监视源。一般用于“遇到特定条件就做特定的事情”这样的场景之中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; sum &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;add&quot;&gt;点我 sum+1&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;ref, watchEffect&#125; from &#x27;vue&#x27;</span><br><span class="line">    let sum = ref(0)</span><br><span class="line">    function add() &#123;</span><br><span class="line">        ++sum.value</span><br><span class="line">    &#125;</span><br><span class="line">    watchEffect(()=&gt;&#123;</span><br><span class="line">        if (sum.value &gt; 10) &#123;</span><br><span class="line">            console.log(&quot;sum 超标了：&quot;, sum.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这个例子会在变量<code>sum &gt; 10</code>的时候进行输出打印，我们使用<code>watchEffect</code>简化了写法，不需要传递监视源。对于这个例子并没有太高的优越性，如果需要监视的变量有很多，那么不传监视源的优越性就体现出来了。</p>
<h4 id="标签-ref"><a href="#标签-ref" class="headerlink" title="标签 ref"></a>标签 ref</h4><h5 id="获取-DOM"><a href="#获取-DOM" class="headerlink" title="获取 DOM"></a>获取 DOM</h5><p>开发中还有一个很常用的功能就是获取某个 DOM 节点，一种常见的方式是使用 id 获取。但这有一个问题，Vue 组件里面可以包含若干个其它组件，如果两个组件中包含一样的 id，那么你获取的时候就会出现问题。Vue 给出的解决方案是对标签使用<code>ref</code>属性，然后在 js 里面定义一个同名变量就可以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h2 ref=&quot;title2&quot;&gt;我是 h2&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;show&quot;&gt;点我输出h2对象&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;ref&#125; from &#x27;vue&#x27;</span><br><span class="line">    // 这边定义的变量就是上面的 h2 DOM 节点</span><br><span class="line">    let title2 = ref()</span><br><span class="line">    function show() &#123;</span><br><span class="line">        console.log(title2.value)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="样式闭合"><a href="#样式闭合" class="headerlink" title="样式闭合"></a>样式闭合</h5><p>视频还看到了一个小知识点，这边就提一下。正常在组件<code>style</code>标签里面写样式，多个组件组合在一起的时候会出现样式污染，因此我们把样式写在<code>&lt;style scoped&gt;&lt;/style&gt;</code>标签里。加上<code>scoped</code>之后样式就会限制本组件内部，因此我们以后写样式几乎必加这个<code>scoped</code>。</p>
<h5 id="组件标签使用-ref"><a href="#组件标签使用-ref" class="headerlink" title="组件标签使用 ref"></a>组件标签使用 ref</h5><p>组件在页面里面也是标签的形式，如果我们给组价加上<code>ref</code>属性会怎么样？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;Person ref=&quot;people&quot; /&gt;</span><br><span class="line">    &lt;button @click=&quot;showPeople&quot;&gt;点我展示组件&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;ref&#125; from &quot;vue&quot;</span><br><span class="line">    import Person from &quot;./components/Person.vue&quot;</span><br><span class="line"></span><br><span class="line">    let people = ref()</span><br><span class="line">    function showPeople() &#123;</span><br><span class="line">        console.log(people.value)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>我们这边定义的<code>people</code>就是<code>Person</code>组件对象，既然是组件对象，那么<code>Person</code>组件里面定义的变量或函数能访问到吗？<br>默认情况下父组件是无法访问子组件变量或函数的，想要访问需要在子组件里面将对应的变量或函数暴露出来。我们看<code>Person</code>组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;ref, defineExpose&#125; from &#x27;vue&#x27;</span><br><span class="line">    let title2 = ref()</span><br><span class="line">    function show() &#123;</span><br><span class="line">        console.log(title2.value)</span><br><span class="line">    &#125;</span><br><span class="line">    defineExpose(&#123;title2, show&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这边使用<code>defineExpose</code>将能被父组件调用的变量或函数暴露出去，这样我们就可以在父组件使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let people = ref()</span><br><span class="line">function showPeople() &#123;</span><br><span class="line">    console.log(people.value)</span><br><span class="line">    console.log(people.value.title2)</span><br><span class="line">    people.value.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边的<code>people</code>与子组件的<code>ref</code>对应，我们拿到子组件引用之后，可以访问子组件暴露出来的变量或函数。</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>有时候我们想给一个对象制定规范，比如里面有哪些属性，这些属性分别是什么类型，如果不满足这些规范编译器会给出提示。这时候就需要使用 TS 里面的接口了，一般情况下我们会按照下列方式创建接口：</p>
<ol>
<li>在<code>src</code>目录下创建目录<code>types</code></li>
<li>在<code>types</code>目录下创建一个 TS 文件，为方便一般起名叫<code>index.ts</code>。<ul>
<li>起名叫<code>index.ts</code>，别人导入的时候直接导入<code>@/types</code></li>
<li>起其它名字例如<code>other.ts</code>，导入时需要<code>@/types/other</code></li>
<li>在 Vue 里面<code>@</code>表示<code>src</code></li>
</ul>
</li>
<li>在 TS 文件里面编写接口，我们以<code>PersonInter</code>举例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export 之后别人才能 import，定义接口关键字是 interface</span></span><br><span class="line">export <span class="keyword">interface</span> <span class="title class_">PersonInter</span> &#123;</span><br><span class="line">    id: string,  <span class="comment">// 属性名: 值类型</span></span><br><span class="line">    name: string,</span><br><span class="line">    age: number,</span><br><span class="line">    score?: number  <span class="comment">// ?: 表示这个属性可有可无</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
接口创建好之后，别人想要使用这个规范，可以：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    // 导入的时候需要在接口前面写 type 关键字</span><br><span class="line">    import &#123;type PersonInter&#125; from &#x27;@/types&#x27;</span><br><span class="line"></span><br><span class="line">    // 变量后面写上冒号，再跟上接口约束</span><br><span class="line">    let person: PersonInter = &#123;id: &quot;abc&quot;, name: &quot;张三&quot;, age: 19&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
我们现在会定义满足接口约束的变量，如果我想定义一个满足接口约束的数组应该怎么做？<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let person: Array&lt;PersonInter&gt; = [&#123;id: &quot;abc&quot;, name: &quot;张三&quot;, age: 19&#125;]</span><br></pre></td></tr></table></figure>
实际上就是泛型，一般我们会将这个数组类型自定义一个名称，可以简化书写：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 TS 文件中</span></span><br><span class="line">export <span class="type">type</span> <span class="variable">PersonList</span> <span class="operator">=</span> Array&lt;PersonInter&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用的时候直接导入就可以使用了</span></span><br><span class="line"><span class="keyword">import</span> &#123;type PersonList&#125; from <span class="string">&#x27;@/types&#x27;</span></span><br><span class="line">let person: PersonList = [&#123;id: <span class="string">&quot;abc&quot;</span>, name: <span class="string">&quot;张三&quot;</span>, age: <span class="number">19</span>&#125;]</span><br></pre></td></tr></table></figure>
如果我想把满足接口定义的数据改成响应式数据，可以这样：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">let</span> <span class="variable">person</span> <span class="operator">=</span> ref&lt;PersonInter&gt;(&#123;</span><br><span class="line">    id: <span class="string">&#x27;1001&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">let</span> <span class="variable">person</span> <span class="operator">=</span> reactive&lt;PersonInter&gt;(&#123;</span><br><span class="line">    id: <span class="string">&#x27;1001&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><p>父组件给子组件传递数据是很常见的操作，在 Vue 里分两步：父组件传，子组件收。</p>
<h5 id="父组件传数据"><a href="#父组件传数据" class="headerlink" title="父组件传数据"></a>父组件传数据</h5><p>父组件给子组件数据很简单，在子组件的标签里添加上属性就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Person info=<span class="string">&quot;消息&quot;</span> :persons=<span class="string">&quot;persons&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// persons 是定义在父组件里的数据</span></span><br><span class="line"><span class="type">let</span> <span class="variable">persons</span> <span class="operator">=</span> [</span><br><span class="line">    &#123;id: <span class="string">&quot;1001&quot;</span>, name: <span class="string">&quot;张三&quot;</span>, age: <span class="number">18</span>&#125;,</span><br><span class="line">    &#123;id: <span class="string">&quot;1002&quot;</span>, name: <span class="string">&quot;李四&quot;</span>, age: <span class="number">19</span>&#125;,</span><br><span class="line">    &#123;id: <span class="string">&quot;1003&quot;</span>, name: <span class="string">&quot;王五&quot;</span>, age: <span class="number">20</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>我们这边给子组件传递了一个字符串<code>info</code>和一个人员数组<code>persons</code>。</p>
<h5 id="子组件收数据"><a href="#子组件收数据" class="headerlink" title="子组件收数据"></a>子组件收数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; info &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;div v-for=&quot;(p, i) in persons&quot; :key=&quot;i&quot;&gt;&#123;&#123; p &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">  import &#123;defineProps&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  defineProps([&#x27;info&#x27;, &#x27;persons&#x27;])</span><br><span class="line"></span><br><span class="line">  info = &quot;哈哈&quot;  // 错误！接受的数据只能作用于模板里</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>子组件接受数据使用<code>defineProps</code>，它需要一个数组表示要接受的数据名称，名称要和父组件给的一致。<strong>注意，数据接收下来之后可以在模板里面使用，但是 js 里面是不能使用的。</strong><br>想要在 js 里面使用传过来的变量，我们可以使用<code>defineProps</code>的返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let data = defineProps([&#x27;info&#x27;, &#x27;persons&#x27;])</span><br><span class="line">console.log(data.info, data.persons)</span><br></pre></td></tr></table></figure>
<p><code>defineProps</code>的返回值是一个对象，子组件接收的数据都在这个对象里。<br>如果我们想在子组件对父组件传过来的数据做类型限制，可以这样用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给 defineProps 函数加泛型，里面传入各个数据的类型约束</span></span><br><span class="line"><span class="type">let</span> <span class="variable">data</span> <span class="operator">=</span> defineProps&lt;&#123;persons: PersonList&#125;&gt;()</span><br></pre></td></tr></table></figure>
<p>再进一步，对于某个数据父组件可传可不传，如果不传子组件能够获取一个默认值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">let</span> <span class="variable">data</span> <span class="operator">=</span> withDefaults(defineProps&lt;&#123;persons?: PersonList&#125;&gt;(), &#123;</span><br><span class="line">    persons: ()=&gt; [&#123;id: <span class="string">&quot;001&quot;</span>, name: <span class="string">&quot;工具人&quot;</span>, age: <span class="number">10</span>&#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li>首先通过<code>persons?: PersonList</code>使<code>persons</code>变为可传可不传</li>
<li>是<code>withDefaults</code>将整个<code>defineProps</code>调用作为第一个参数，第二个参数是一个对象用来配置默认值，<strong>对象里面的属性值必须写成函数的形式</strong>。</li>
</ol>
<p><strong>注意：默认值写法只能写在有 TS 限制类型的</strong><code>**defineProps**</code><strong>上。</strong><br>一个小知识点，所有<code>define</code>开头的函数（<code>defineProps</code>、<code>defineExpose</code>等）其实都是默认导入的，我们可以手动不导入。</p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><h5 id="Vue2-生命周期"><a href="#Vue2-生命周期" class="headerlink" title="Vue2 生命周期"></a>Vue2 生命周期</h5><p>Vue2 有 4 个生命阶段，每个阶段有两个钩子函数，共 8 个钩子函数。</p>
<table>
<thead>
<tr>
<th><strong>状态</strong></th>
<th><strong>周期</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>beforeCreate</code></td>
<td>创建前</td>
</tr>
<tr>
<td><code>created</code></td>
<td>创建后</td>
</tr>
<tr>
<td><code>beforeMount</code></td>
<td>挂载前</td>
</tr>
<tr>
<td><code>mounted</code></td>
<td>挂载完成，一般在里面发送数据请求</td>
</tr>
<tr>
<td><code>beforeUpdate</code></td>
<td>更新前</td>
</tr>
<tr>
<td><code>updated</code></td>
<td>更新后</td>
</tr>
<tr>
<td><code>beforeDestroy</code></td>
<td>销毁前</td>
</tr>
<tr>
<td><code>destroyed</code></td>
<td>销毁后</td>
</tr>
</tbody></table>
<h5 id="Vue3-生命周期"><a href="#Vue3-生命周期" class="headerlink" title="Vue3 生命周期"></a>Vue3 生命周期</h5><p>Vue3 的生命周期和 Vue2 有些不同，我们直接看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">  import &#123;onBeforeMount, onMounted, onBeforeUpdate, </span><br><span class="line">          onUpdated, onBeforeUnmount, onUnmounted&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;创建&quot;)</span><br><span class="line"></span><br><span class="line">  onBeforeMount(()=&gt;&#123;</span><br><span class="line">    console.log(&quot;挂载前&quot;)</span><br><span class="line">  &#125;)</span><br><span class="line">  onMounted(()=&gt;&#123;</span><br><span class="line">    console.log(&quot;挂载完成&quot;)</span><br><span class="line">  &#125;)</span><br><span class="line">  onBeforeUpdate(()=&gt;&#123;</span><br><span class="line">    console.log(&quot;更新前&quot;)</span><br><span class="line">  &#125;)</span><br><span class="line">  onUpdated(()=&gt;&#123;</span><br><span class="line">    console.log(&quot;更新完成&quot;)</span><br><span class="line">  &#125;)</span><br><span class="line">  onBeforeUnmount(()=&gt;&#123;</span><br><span class="line">    console.log(&quot;卸载前&quot;)</span><br><span class="line">  &#125;)</span><br><span class="line">  onUnmounted(()=&gt;&#123;</span><br><span class="line">    console.log(&quot;写在完成&quot;)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>Vue3 可以直接在<code>setup</code>里面做创建时要做的操作</li>
<li>其它所有钩子函数也都换了名字，但套路是一样的</li>
<li>Vue3 没有销毁的钩子，取而代之的是卸载的钩子函数</li>
<li>调用某个钩子时需要传进去一个回调函数，在回调函数里面写要做的事情</li>
</ol>
<h4 id="自定义-Hooks"><a href="#自定义-Hooks" class="headerlink" title="自定义 Hooks"></a>自定义 Hooks</h4><p>我们在组件里面总会定义变量与操作它的函数、计算属性、监视器等，当代码多的时候这些内容混杂在一起就很混乱。于是我们可以利用自定义 Hooks 将同一个逻辑抽出来，看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; sum &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;add&quot;&gt;点我sum+1&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;ref, watch&#125; from &#x27;vue&#x27;</span><br><span class="line">    let sum = ref(0)</span><br><span class="line">    function add() &#123;</span><br><span class="line">        sum.value++</span><br><span class="line">    &#125;</span><br><span class="line">    watch(sum, (newVal)=&gt;&#123;</span><br><span class="line">        console.log(newVal)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这个例子很简单，因为整个组件只有一个逻辑，就是操作变量<code>sum</code>。为了演示，我们打算将所有关于<code>sum</code>的逻辑抽出来，操作步骤：</p>
<ol>
<li>在<code>src</code>下创建目录<code>hooks</code></li>
<li>在<code>hooks</code>目录下新建文件<code>useSum.ts</code>，名字需以<code>use</code>开头</li>
<li>然后将所有相关的逻辑写到这个文件中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123;ref, watch&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default function() &#123;</span><br><span class="line">    let sum = ref(0)</span><br><span class="line">    function add() &#123;</span><br><span class="line">        sum.value++</span><br><span class="line">    &#125;</span><br><span class="line">    watch(sum, (newVal)=&gt;&#123;</span><br><span class="line">        console.log(newVal)</span><br><span class="line">    &#125;)</span><br><span class="line">    return &#123;sum, add&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
整个逻辑部分要导出为一个函数，函数的返回值是所有需要导出的变量、函数、计算属性等。<br>接下来我们在组件中使用这个 hook：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; sum &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;add&quot;&gt;点我sum+1&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import useSum from &#x27;@/hooks/useSum&#x27;</span><br><span class="line"></span><br><span class="line">    let &#123;sum, add&#125; = useSum()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
这样就实现了逻辑的抽离，当我们业务代码非常臃肿的时候这么做是非常友好的。而且在 hook 里面还可以写生命周期钩子函数，和我们直接在组件里面使用没有区别。</li>
</ol>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>首先我们需要下载安装路由模块，命令是：<code>npm i vue-router</code></p>
<h4 id="创建路由器"><a href="#创建路由器" class="headerlink" title="创建路由器"></a>创建路由器</h4><p>接下来我们需要自定义一个路由器，在路由器里面指定访问路径与展示组件的联系。我们先在<code>src</code>下创建目录<code>router</code>，为导入方便直接在<code>router</code>里面创建<code>index.ts</code>，最后我们就在<code>index.ts</code>里面创建路由器并导出：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createRouter, createWebHistory&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/Home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">News</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/News.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/About.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 createRouter 函数创建路由器</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(),  <span class="comment">// 指定路由工作模式</span></span><br><span class="line">  <span class="attr">routes</span>: [  <span class="comment">// 数组中每个对象表示路由配置</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Home</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/news&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">News</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">About</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后要导出这个路由器，不然别人拿不到</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
<h4 id="应用路由器"><a href="#应用路由器" class="headerlink" title="应用路由器"></a>应用路由器</h4><p>创建好路由器之后，我们需要在<code>main.ts</code>里创建 APP 时使用路由器：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">app.<span class="title function_">use</span>(router)  <span class="comment">// 使用我们定义的路由器</span></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>路由器被我配置到应用中之后，我们还需要指定一个<code>RouterView</code>，这个组件表示根据路径得到的组件显示在哪，可以理解成一个窗口。而且链接跳转也不能直接使用<code>&lt;a&gt;</code>标签，要使用 Vue 提供的<code>RouterLink</code>组件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;路由功能测试&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;!-- 导航区，需要使用 RouterLink 组件进行页面跳转 --&gt;</span><br><span class="line">        &lt;RouterLink to=&quot;/home&quot; active-class=&quot;linkActive&quot;&gt;首页&lt;/RouterLink&gt;</span><br><span class="line">        &lt;RouterLink to=&quot;/news&quot; active-class=&quot;linkActive&quot;&gt;新闻&lt;/RouterLink&gt;</span><br><span class="line">        &lt;!-- to 里面还可以传入一个对象，对象的 path 属性作为请求路径 --&gt;</span><br><span class="line">        &lt;RouterLink :to=&quot;&#123;path: &#x27;/about&#x27;&#125;&quot; active-class=&quot;linkActive&quot;&gt;关于&lt;/RouterLink&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;!-- RouterView 是组件展示窗口 --&gt;</span><br><span class="line">        &lt;RouterView&gt;&lt;/RouterView&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123;RouterView, RouterLink&#125; from &#x27;vue-router&#x27;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><code>RouterLink</code>有<code>active-class</code>属性，里面传一个 CSS 类进去，表示链接被激活的样式。</p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>我们将自定义的组件人为区分成一般组件和路由组件，那如何区分这两种组件？举个例子，假设我们自定义了<code>Demo.vue</code>，如果我们在某个地方这么使用<code>&lt;Demo/&gt;</code>它，那么他就是一般组件，否则就是路由组价。因为路由组件是根据请求路径自动展示的，不是我们手动写标签展示的。<br>之所以区分这个，是应用中一般组件放在<code>src/components</code>目录下，路由组件放在<code>src/pages</code>或<code>src/views</code>目录下。<strong>通过路由切换组件的时候，原来的组件会卸载掉。</strong></p>
<h4 id="路由器的工作模式"><a href="#路由器的工作模式" class="headerlink" title="路由器的工作模式"></a>路由器的工作模式</h4><ol>
<li><code>history</code>模式<ul>
<li>优点：URL 更加美观，不带有<code>#</code>，更接近传统网站的 URL</li>
<li>缺点：后期项目上线需要服务端配合处理路径问题</li>
<li>配置：在路由器里面使用<code>history: createWebHistory()</code></li>
<li>应用场景：网站直接面对大众时一般采用这种策略</li>
</ul>
</li>
<li><code>hash</code>模式<ul>
<li>优点：兼容性好，不需要服务端配合处理</li>
<li>缺点：URL 带有<code>#</code>不美观且 SEO 优化差</li>
<li>配置：在路由器里面使用<code>history: createWebHashHistory()</code></li>
<li>应用场景：一般的后台管理系统都是采用这种策略</li>
</ul>
</li>
</ol>
<h4 id="路由的几种方式"><a href="#路由的几种方式" class="headerlink" title="路由的几种方式"></a>路由的几种方式</h4><p>我们在<code>RouterLink</code>的<code>to</code>属性里面指定路径的时候有三种写法：</p>
<ol>
<li>直接写字符串，例如<code>&lt;RouterLink to=&quot;/home&quot;&gt;xxx&lt;/RouterLink&gt;</code></li>
<li>使用对象指定<code>path</code>，例如<code>&lt;RouterLink :to=&quot;&#123;path: &#39;/home&#39;&#125;&quot;&gt;xxx&lt;/RouterLink&gt;</code></li>
<li>使用对象指定<code>name</code>，例如<code>&lt;RouterLink :to=&quot;&#123;name: &#39;home&#39;&#125;&quot;&gt;xxx&lt;/RouterLink&gt;</code>，这种写法需要在路由器里面给规则配置名称，如下：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  name<span class="punctuation">:</span> &#x27;about&#x27;<span class="punctuation">,</span></span><br><span class="line">  path<span class="punctuation">:</span> &#x27;/about&#x27;<span class="punctuation">,</span></span><br><span class="line">  component<span class="punctuation">:</span> About</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h4><p>一个组件里面有路由显示的界面，路由出来的组件里面仍然有路由，这叫做路由嵌套。下图描述了一种路由嵌套的应用场景：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1708516085272-12432f3b-0e20-46cb-8270-577715674adb.png#averageHue=%23fbf7f5&clientId=ua750f794-3c8d-4&from=paste&height=571&id=uf4a6fb27&originHeight=1142&originWidth=2068&originalType=binary&ratio=2&rotation=0&showTitle=false&size=119004&status=done&style=none&taskId=u95d6b775-c71d-43dc-9fa8-654068011e2&title=&width=1034" alt="image.png"><br>新闻界面的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;left&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;news in newsList&quot; :key=&quot;news.id&quot;&gt;</span><br><span class="line">        &lt;!-- 左侧导航栏，链接是 /news 的子链接 --&gt;</span><br><span class="line">        &lt;RouterLink to=&quot;/news/detail&quot;&gt;&#123;&#123; news.title &#125;&#125;&lt;/RouterLink&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;right&quot;&gt;</span><br><span class="line">    &lt;!-- 内容展示区 --&gt;</span><br><span class="line">    &lt;RouterView /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<p>配置路由器的时候在新闻路由里面添加<code>children</code>属性：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  path<span class="punctuation">:</span> &#x27;/news&#x27;<span class="punctuation">,</span></span><br><span class="line">  component<span class="punctuation">:</span> News<span class="punctuation">,</span></span><br><span class="line">  children<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      path<span class="punctuation">:</span> &#x27;detail&#x27;<span class="punctuation">,</span></span><br><span class="line">      component<span class="punctuation">:</span> Detail</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>仔细观察可以发现，子级路由的<code>path</code>属性不是<code>/</code>开头，而是直接写路径。因为如果你加了<code>/</code>开头这就表示根下的<code>detail</code>。 </p>
<h4 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h4><p>我们使用路由跳转的时候可以携带参数，参数分为<code>query</code>和<code>params</code>。</p>
<h5 id="query-参数"><a href="#query-参数" class="headerlink" title="query 参数"></a>query 参数</h5><p>传递参数有两种方式，主要修改<code>RouterLink</code>的<code>to</code>属性，看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;!-- 方式一：直接在路径后面拼接字符串 --&gt;</span><br><span class="line">    &lt;RouterLink to=&quot;/news/detail?id=abc&quot;&gt;&#123;&#123; news.title &#125;&#125;&lt;/RouterLink&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 方式二：使用对象，对象里用 query 属性携带参数 --&gt;</span><br><span class="line">    &lt;RouterLink :to=&quot;&#123;</span><br><span class="line">        path: &#x27;/news/detail&#x27;,</span><br><span class="line">        query: &#123;</span><br><span class="line">            id: &#x27;abc&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&quot;&gt;</span><br><span class="line">        &#123;&#123; news.title &#125;&#125;</span><br><span class="line">    &lt;/RouterLink&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<p>不论使用哪种方式，最终这些参数都会通过路径携带过去。<br>路由到的组件想要获取传过来的<code>query</code>参数可以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123; useRoute &#125; from &#x27;vue-router&#x27;</span><br><span class="line"></span><br><span class="line">    const route = useRoute()</span><br><span class="line">    // 所有的 query 参数都可以在 route.query 里面找到</span><br><span class="line">    console.log(route.query.id)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="params-参数"><a href="#params-参数" class="headerlink" title="params 参数"></a>params 参数</h5><p><code>params</code>参数的形式是<code>/path/p1/p2</code>，这边<code>/path</code>是请求路径，<code>p1</code>和<code>p2</code>是两个参数。这个参数看起来和路径一样，是如何区分的呢？首先我们需要现在路由器里面配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  path<span class="punctuation">:</span> &#x27;/news&#x27;<span class="punctuation">,</span></span><br><span class="line">  component<span class="punctuation">:</span> News<span class="punctuation">,</span></span><br><span class="line">  children<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      name<span class="punctuation">:</span> &#x27;detail&#x27;<span class="punctuation">,</span></span><br><span class="line">      path<span class="punctuation">:</span> &#x27;detail/<span class="punctuation">:</span>id/<span class="punctuation">:</span>name?&#x27;<span class="punctuation">,</span></span><br><span class="line">      component<span class="punctuation">:</span> Detail</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们这边的<code>path</code>指定为<code>detail/:id/:name</code>，这就表示在路径<code>detail</code>后面会有两个参数，这两个参数分别叫做<code>id</code>与<code>name</code>。<br><code>name</code>参数使用的是<code>:name?</code>表示这个参数可传可不传。<br>我们在<code>RouterLink</code>里面指定参数的时候也有两种方式：<br>方式一很简单，就是在路径后面拼接参数就可以了，这些参数和路由里面定义的对应：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;RouterLink to=&quot;/news/detail/abc/张三&quot;&gt;&#123;&#123; news.title &#125;&#125;&lt;/RouterLink&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;RouterLink :to=&quot;&#123;</span><br><span class="line">  name: &#x27;detail&#x27;,</span><br><span class="line">  params: &#123;</span><br><span class="line">  id: &#x27;abc&#x27;,</span><br><span class="line">  name: &#x27;张三&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&quot;&gt;</span><br><span class="line">  &#123;&#123; news.title &#125;&#125;</span><br><span class="line">&lt;/RouterLink&gt;</span><br></pre></td></tr></table></figure>
<p>这是方式二，我们仍然使用对象的方式传参。不过这次将参数写进<code>params</code>属性里面。<br>注意：这里有一个坑，<code>params</code>参数使用对象携带的话，不能通过<code>path</code>配置路由路径，只能通过<code>name</code>指定。<br>数据传过去了，组件接收的时候写法和<code>query</code>基本一致，不过访问的是<code>params</code>属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">  import &#123; useRoute &#125; from &#x27;vue-router&#x27;</span><br><span class="line"></span><br><span class="line">  const route = useRoute()</span><br><span class="line">  // 所有的 params 参数都可以在 route.params 里面找到</span><br><span class="line">  console.log(route.params.id)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="props-配置"><a href="#props-配置" class="headerlink" title="props 配置"></a>props 配置</h4><p>我们现在可以接收参数，但在组件内访问变量的时候还是很麻烦。需要写<code>route.query.</code>或<code>route.params.</code>前缀，我想直接访问传过来的参数行不行？行，下面介绍几种写法。</p>
<h5 id="配置-props-属性"><a href="#配置-props-属性" class="headerlink" title="配置 props 属性"></a>配置 props 属性</h5><p>我们在路由器配置界面将子组件的<code>props</code>属性配置为<code>true</code>，这样会将参数作为属性传给组件。<br>路由器配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    path<span class="punctuation">:</span> &#x27;/news&#x27;<span class="punctuation">,</span></span><br><span class="line">    component<span class="punctuation">:</span> News<span class="punctuation">,</span></span><br><span class="line">    children<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          name<span class="punctuation">:</span> &#x27;detail&#x27;<span class="punctuation">,</span></span><br><span class="line">          path<span class="punctuation">:</span> &#x27;detail/<span class="punctuation">:</span>id/<span class="punctuation">:</span>name&#x27;<span class="punctuation">,</span></span><br><span class="line">          component<span class="punctuation">:</span> Detail<span class="punctuation">,</span></span><br><span class="line">          props<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>props: true</code>是配置在子组件上的。<br>传参还是使用一样的传法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;RouterLink </span><br><span class="line">  to=&quot;/news/detail/abc/张三&quot;&gt;</span><br><span class="line">  &#123;&#123; news.title &#125;&#125;</span><br><span class="line">&lt;/RouterLink&gt;</span><br></pre></td></tr></table></figure>
<p>组件内接收参数时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; id &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">  defineProps([&#x27;id&#x27;, &#x27;name&#x27;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>实际上如果将<code>props</code>设为<code>true</code>，路由渲染的时候相当于渲染<code>&lt;Detail id=&quot;abc&quot; name=&quot;张三&quot; /&gt;</code>，那么在组件内通过<code>defineProps</code>获取属性也就不奇怪了。<br><strong>注意：这种方式只能配合</strong><code>**params**</code><strong>传参使用，</strong><code>**query**</code><strong>传参是不能使用的。</strong></p>
<h5 id="自定义-props"><a href="#自定义-props" class="headerlink" title="自定义 props"></a>自定义 props</h5><p>第一种很好用，但只能配合<code>params</code>传参的方式。如果我想使用<code>query</code>传参怎么办？此时我们可以自定义 props，首先在路由器里面配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  path<span class="punctuation">:</span> &#x27;/news&#x27;<span class="punctuation">,</span></span><br><span class="line">  component<span class="punctuation">:</span> News<span class="punctuation">,</span></span><br><span class="line">  children<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      name<span class="punctuation">:</span> &#x27;detail&#x27;<span class="punctuation">,</span></span><br><span class="line">      path<span class="punctuation">:</span> &#x27;detail&#x27;<span class="punctuation">,</span></span><br><span class="line">      component<span class="punctuation">:</span> Detail<span class="punctuation">,</span></span><br><span class="line">      props(route) <span class="punctuation">&#123;</span></span><br><span class="line">        return route.query</span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们这边定义了<code>props</code>函数，这个函数有一个参数<code>route</code>，这个<code>route</code>就是我们之前获取数据时使用的<code>useRoute()</code>函数的返回值。<br><code>props()</code>函数的返回值将会被加到组件的<code>props</code>里面，例如我们这边直接将<code>route.query</code>返回出去，这样所有的参数都会被添加到<code>props</code>里。<br>组件访问数据的时候还是使用<code>defineProps([&#39;id&#39;, &#39;name&#39;])</code></p>
<h5 id="固定-props"><a href="#固定-props" class="headerlink" title="固定 props"></a>固定 props</h5><p>第三种方法能将固定的数据添加到组件的<code>props</code>里面，直接看路由器的配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    path<span class="punctuation">:</span> &#x27;/news&#x27;<span class="punctuation">,</span></span><br><span class="line">    component<span class="punctuation">:</span> News<span class="punctuation">,</span></span><br><span class="line">    children<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            name<span class="punctuation">:</span> &#x27;detail&#x27;<span class="punctuation">,</span></span><br><span class="line">            path<span class="punctuation">:</span> &#x27;detail&#x27;<span class="punctuation">,</span></span><br><span class="line">            component<span class="punctuation">:</span> Detail<span class="punctuation">,</span></span><br><span class="line">            props<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                id<span class="punctuation">:</span> &#x27;abc&#x27;<span class="punctuation">,</span></span><br><span class="line">                name<span class="punctuation">:</span> &#x27;王五&#x27;</span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="replace-属性"><a href="#replace-属性" class="headerlink" title="replace 属性"></a>replace 属性</h4><p>正常浏览器的历史记录是<code>push</code>模式，即浏览器维护一个栈，每次访问新页面就将这个网址入栈，当前访问的永远在栈顶。初次之外，还有<code>replace</code>模式，这个模式下每次访问新页面都会将新网址替换掉栈顶的网址（而不是入栈），这样做你前一次访问的页面就无法通过回退访问。<br>想要开启<code>replace</code>模式，只需要在<code>RouterLink</code>里面定义<code>replace</code>属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;RouterLink replace to=&quot;/home&quot; active-class=&quot;linkActive&quot;&gt;首页&lt;/RouterLink&gt;</span><br></pre></td></tr></table></figure>
<h4 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h4><p>目前我们路由导航都是通过点击<code>RouterLink</code>实现的跳转，如果我想在代码里实现跳转应该怎么做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123; useRouter &#125; from &#x27;vue-router&#x27;</span><br><span class="line"></span><br><span class="line">    const router = useRouter()</span><br><span class="line">    router.push(&#x27;/home&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><code>useRouter()</code>函数的返回值就是路由器对象，调用路由器的<code>push</code>方法就可以实现跳转。<br>除此之外，实际上<code>push</code>函数的参数和<code>RouterLink</code>组件的<code>to</code>属性一样，可以传字符串也可以传一个对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    import &#123; useRouter &#125; from &#x27;vue-router&#x27;</span><br><span class="line"></span><br><span class="line">    const router = useRouter()</span><br><span class="line">    router.push(&#123;</span><br><span class="line">        path: &#x27;/news/detail&#x27;,</span><br><span class="line">        query: &#123;</span><br><span class="line">            id: &#x27;abc&#x27;,</span><br><span class="line">            name: &#x27;张三&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>所以传参或者配置<code>props</code>都是一样的，子组件解析的方式也是不需要变化的。<br>和上一节呼应，<code>push</code>是有记录的跳转，自然还有<code>replace</code>方法表示无记录跳转。</p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>重定向是使用比较多的功能，例如我们访问一个页面的时候如果没有登录会重定向到登录界面。我们只需要在路由器配置页面添加一个配置项：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  path<span class="punctuation">:</span> &#x27;/&#x27;<span class="punctuation">,</span></span><br><span class="line">  redirect<span class="punctuation">:</span> &#x27;/home&#x27;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>配置好之后，访问根路径会自动重定向到<code>/home</code>页面。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/23/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/08/23/Redis/" itemprop="url">Redis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-08-23T11:52:13+08:00">
                2023-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis是一个完全开源免费的高性能（NOSQL）的key-value数据库。它遵守BSD协议，使用ANSI C语言编写，并支持网络和持久化。Redis拥有极高的性能，每秒可以进行11万次的读取操作和8.1万次的写入操作。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>详细安装教程见下方链接：<br><a target="_blank" rel="noopener" href="https://space-jiangsu.yuque.com/bcsfg9/qr2sxk/diylpm?view=doc_embed&inner=mR4eh">1. 软件安装</a></p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>Redis 配置文件是<code>redis.conf</code>，根据安装方式的不同其存储路径也不同。一般来说使用 Homebrew 安装则路径位于<code>/opt/homebrew/etc</code>下；若手动安装，则<code>redis.conf</code>就位于安装包下。<br>接下来我们将修改配置文件，建议修改前将原来的配置文件备份一下，直接复制在当前目录并命名为<code>redis.conf.bck</code>。<code>redis.conf</code>里面大致有以下几个值得我们注意的配置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听的地址，默认值为 127.0.0.1，这表示只有本机才能访问 redis 服务；</span></span><br><span class="line"><span class="comment"># 将其值设置为 0.0.0.0 表示所有机器都可以访问 redis 服务；</span></span><br><span class="line">bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 守护进程，默认值 no，表示我在一个控制台窗口打开 redis，这个窗口就不能干别的事情了；</span></span><br><span class="line"><span class="comment"># 我们将其设置为 yes 表示后台运行；</span></span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问密码，默认不需要密码，这边我们将其设置为 123456</span></span><br><span class="line">requirepass <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 端口号默认值 6379</span></span><br><span class="line">port <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 工作目录，后面运行期间的日志、持久化文件保存的目录</span></span><br><span class="line"><span class="comment"># 下面的值是 Homebrew 安装的 redis 的默认路径，手动安装默认为 . 表示执行命令时的当前目录</span></span><br><span class="line"><span class="built_in">dir</span> /opt/homebrew/var/db/redis/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库的数目，默认为 16，编号为 0-15</span></span><br><span class="line">databases <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 redis 能够使用的最大内存</span></span><br><span class="line">maxmemory 512mb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line"><span class="comment"># 这边只有文件名，没有路径，则路径使用上面设定的工作目录</span></span><br><span class="line">logfile <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>启动 Redis 分两种情况：</p>
<ul>
<li>Homebrew 安装，使用命令<code>brew services start redis</code>来启动 Redis；</li>
<li>手动安装，使用命令：<code>redis-server /usr/local/redis-6.2.6/redis.conf</code>来启动；</li>
</ul>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>启动完毕之后，我们就可以连接 Redis 数据库。我们可以在控制台连接，也可以使用图形化界面连接。</p>
<h5 id="控制台连接"><a href="#控制台连接" class="headerlink" title="控制台连接"></a>控制台连接</h5><p>控制台连接使用命令<code>redis-cli -h 127.0.0.1 -p 6379 -a 123456</code>，这里面有几个参数：</p>
<ul>
<li><code>-h</code>用来指定要连接的 redis 的 IP 地址，可以省略，默认为<code>127.0.0.1</code>；</li>
<li><code>-p</code>用来指定要连接的 redis 的端口号，可以省略，默认为 6379；</li>
<li><code>-a</code>用来指定要连接的 redis 的密码，可以省略；</li>
</ul>
<p>其中密码的指定除了在连接命令里面添加外，还可以交互式添加。即我们不使用密码连接，进入到交互式控制台后，使用<code>auth 123456</code>命令来设置密码。</p>
<h5 id="图形化界面"><a href="#图形化界面" class="headerlink" title="图形化界面"></a>图形化界面</h5><p>首先下载并安装图形化界面软件：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1NFkc8ORkw3dR0p8ezAbLiQ?pwd=5f3x">mac安装包</a></li>
<li><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1qiiMSFSHaiYozsokZrtmRg?pwd=csbz">Windows安装包</a></li>
</ul>
<p>安装完成后我们新建连接，并填写好对应的主机、端口号、密码等连接信息。下面就可以操作 Redis 数据库了。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>Redis 是一中存储键值对的数据库，键一般都是一个字符串，值可以多种多样。下面罗列出了平时能遇到的所有类型：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1718351274070-89d24d20-f117-4266-a0ae-d0236cd9b946.png#averageHue=%23edeeec&clientId=ubfac4f3d-4264-4&from=paste&height=557&id=udb3d6aea&originHeight=557&originWidth=1105&originalType=binary&ratio=1&rotation=0&showTitle=false&size=206685&status=done&style=none&taskId=u2a5590e4-a8c2-4f60-affd-b241a0f12c1&title=&width=1105" alt="image.png"></p>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>我们在控制台可以使用各种各样的命令来操作 Redis，详细信息可以查阅官方文档：<br><a target="_blank" rel="noopener" href="https://redis.io/docs/latest/commands/">Commands</a><br>这些命令被分为很多组，例如字符串类型的操作、哈希类型的操作、通用操作等。例如通用操作命令<code>KEYS</code>，我想知道这个命令的具体使用方法，除了可以到官方文档查阅，我们还可以直接在 Redis 交互控制台使用<code>help KEYS</code>进行查看。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1718352321470-cf8e8d39-325e-4008-9d7d-91330908de5c.png#averageHue=%23f5e98b&clientId=ubfac4f3d-4264-4&from=paste&height=90&id=u8830de0c&originHeight=90&originWidth=392&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11006&status=done&style=none&taskId=u1a7fbf95-1f99-47b1-99b6-0b2a8805b41&title=&width=392" alt="image.png"><br>下面我们按照类别分别看看一些常用命令。</p>
<h4 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h4><h5 id="KEYS"><a href="#KEYS" class="headerlink" title="KEYS"></a>KEYS</h5><p><code>KEYS pattern</code>命令用于寻找并返回所有满足某模板的键名。<br>模板中使用<code>?</code>匹配任意一个字符，使用<code>*</code>匹配任意数量任意字符。</p>
<h5 id="DEL"><a href="#DEL" class="headerlink" title="DEL"></a>DEL</h5><p><code>DEL key [key...]</code>命令用于删除若干个键值对，返回成功删除的键值对数目。</p>
<h5 id="EXISTS"><a href="#EXISTS" class="headerlink" title="EXISTS"></a>EXISTS</h5><p><code>EXISTS key [key...]</code>命令返回给定的键中存在于库中的数目。<br>注意：如果指定多个<code>key</code>，只能知道存在多少个，至于哪些存在则不知道。</p>
<h5 id="EXPIRE"><a href="#EXPIRE" class="headerlink" title="EXPIRE"></a>EXPIRE</h5><p><code>EXPIRE key seconds</code>给一个键设定有效时长，单位是秒，到期后将自动删除该键值对。</p>
<h5 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h5><p><code>TTL key</code>返回某键剩余的有效时长，单位是秒，若返回的数字：</p>
<ol>
<li><code>≥0</code>表示有效时长；</li>
<li>等于<code>-1</code>表示永久有效；</li>
<li>等于<code>-2</code>表示已到期删除；</li>
</ol>
<h5 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h5><p><code>COPY source destination</code>将键<code>source</code>对应的值复制到键名<code>destination</code>中。<code>destination</code>对应的键不存在就创建，不然怎么叫复制呢？</p>
<h4 id="String-命令"><a href="#String-命令" class="headerlink" title="String 命令"></a>String 命令</h4><p>在 Redis 里面 String 不仅仅表示字符串，还能表示整数和浮点数。</p>
<h5 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h5><p><code>SET key value [EX seconds] [NX]</code>往数据库里面新增或修改一个 String 类型的数据，默认情况下，键不存在会新增，键存在就是修改。</p>
<ol>
<li>额外选项<code>EX seconds</code>可以为该键设置有效时长，单位是秒；</li>
<li>额外选项<code>NX</code>表示仅新增不修改，即存在该键值对不做修改；</li>
</ol>
<h5 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h5><p><code>GET key</code>返回某个键的值。</p>
<h5 id="MSET"><a href="#MSET" class="headerlink" title="MSET"></a>MSET</h5><p><code>MSET key value [key value ...]</code>批量设置键值对，例如<code>MSET name luyan age 18</code>。注意使用这样的方式就不能指定<code>EX | NX</code>了。</p>
<h5 id="MGET"><a href="#MGET" class="headerlink" title="MGET"></a>MGET</h5><p><code>MGET key [key...]</code>批量返回值。</p>
<h5 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h5><p>关于自增有三条命令，如下：</p>
<ol>
<li><code>INCR key</code>对某一整数自增 1，不能对浮点数做自增；</li>
<li><code>INCRBY key increment</code>对某一整数自增指定大小，不能对浮点数自增；</li>
<li><code>INCRBYFLOAT key increment</code>对浮点数自增指定大小，也可以作用到整数上，但作用完之后这个整数会变成浮点数。</li>
</ol>
<h5 id="自减"><a href="#自减" class="headerlink" title="自减"></a>自减</h5><p>和自增对应，不过命令变为<code>DECR</code>：</p>
<ol>
<li><code>DECR key</code>对某一整数自减 1，不能对浮点数做自减；</li>
<li><code>DECRBY key increment</code>对某一整数自减指定大小，不能对浮点数自减；</li>
</ol>
<p>如果我想对浮点数自减应该怎么操作？答：自增负数即可，例如下面对分数减两分。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBYFLOAT score -<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>注意：自增和自减都必须作用到数字类型上，字符串无法自增和自减。</p>
<h5 id="SETNX"><a href="#SETNX" class="headerlink" title="SETNX"></a>SETNX</h5><p><code>SETNX key value</code>仅添加键值对，不修改。与<code>SET key value NX</code>等价。</p>
<h5 id="SETEX"><a href="#SETEX" class="headerlink" title="SETEX"></a>SETEX</h5><p><code>SETEX key seconds value</code>设置或更新键值对的时候指定有效时长，单位是秒。与<code>SET key value EX seconds</code>等价。 </p>
<h5 id="GETDEL"><a href="#GETDEL" class="headerlink" title="GETDEL"></a>GETDEL</h5><p><code>GETDEL key</code>删除某个键值对并返回对应的值。</p>
<h4 id="Hash-命令"><a href="#Hash-命令" class="headerlink" title="Hash 命令"></a>Hash 命令</h4><p>Redis 的 Hash 与 Java 里面的 Map 结构类似，便于保存对象信息。我们保存对象信息的时候，固然可以将对象序列化成 Json 字符串然后保存。但这样做有个很大的问题，例如我想修改对象里面的某个字段值怎么做？对于这样的需求，如果我们保存的是 Json 串，那么就需要将对象重新序列化成 Json 格式，然后覆盖之前的串。显然，要改就改全部效率很低下，此时就是 Hash 结构大展身手的时候，结构图如下：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1718372922309-249480c8-e704-49cb-86ae-ba0db389945d.png#averageHue=%23cba9a7&clientId=ubfac4f3d-4264-4&from=paste&height=312&id=u82300765&originHeight=312&originWidth=735&originalType=binary&ratio=1&rotation=0&showTitle=false&size=53325&status=done&style=none&taskId=u2b19db3f-49ab-4a8f-9945-7011dec6e0d&title=&width=735" alt="image.png"></p>
<h5 id="HSET"><a href="#HSET" class="headerlink" title="HSET"></a>HSET</h5><p><code>HSET key field value [field value ...]</code>新增或修改一个 Hash。<code>field</code>与<code>value</code>代表一个键值对，若该键值对不存在就新增否则就修改，允许同时操作多个键值对。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET heima:user:1 name Jack age 21</span><br></pre></td></tr></table></figure>
<h5 id="HGET"><a href="#HGET" class="headerlink" title="HGET"></a>HGET</h5><p><code>HGET key field</code>返回某 key 里某字段的值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGET heima:user:1 name</span><br></pre></td></tr></table></figure>
<h5 id="HMSET"><a href="#HMSET" class="headerlink" title="HMSET"></a>HMSET</h5><p><code>HMSET key field value [field value ...]</code>功能和<code>HSET</code>一样。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMSET heima:user:2 name Rose age 18</span><br></pre></td></tr></table></figure>
<h5 id="HMGET"><a href="#HMGET" class="headerlink" title="HMGET"></a>HMGET</h5><p><code>HMGET key field [field ...]</code>允许获取多个字段值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMGET heima:user:1 name age</span><br></pre></td></tr></table></figure>
<h5 id="HGETALL"><a href="#HGETALL" class="headerlink" title="HGETALL"></a>HGETALL</h5><p><code>HGETALL key</code>获取 key 指代 Hash 的所有键值对。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGETALL heima:user:1</span><br></pre></td></tr></table></figure>
<h5 id="HKEYS"><a href="#HKEYS" class="headerlink" title="HKEYS"></a>HKEYS</h5><p><code>HKEYS key</code>获取 key 指代 Hash 的所有键。</p>
<h5 id="HVALS"><a href="#HVALS" class="headerlink" title="HVALS"></a>HVALS</h5><p><code>HVALS key</code>获取 key 指代 Hash 的所有值。</p>
<h5 id="HINCRBY"><a href="#HINCRBY" class="headerlink" title="HINCRBY"></a>HINCRBY</h5><p><code>HINCRBY key field increment</code>对 key 指代的哈希字段做自增。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 年龄张三岁</span></span><br><span class="line">HINCRBY heima:user:1 age 3</span><br></pre></td></tr></table></figure>
<h5 id="HSETNX"><a href="#HSETNX" class="headerlink" title="HSETNX"></a>HSETNX</h5><p><code>HSETNX key field value</code>只新增不修改。</p>
<h5 id="HDEL"><a href="#HDEL" class="headerlink" title="HDEL"></a>HDEL</h5><p><code>HDEL key field [field ...]</code>删除哈希字段，可删除多个。</p>
<h5 id="HEXISTS"><a href="#HEXISTS" class="headerlink" title="HEXISTS"></a>HEXISTS</h5><p><code>HEXISTS key field</code>返回哈希字段是否存在。</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>List 在 Redis 里面是一个双向链表，支持我们左右两端操作。</p>
<h5 id="LPUSH"><a href="#LPUSH" class="headerlink" title="LPUSH"></a>LPUSH</h5><p><code>LPUSH key element [element ...]</code>往列表左端添加元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自左向右依次存储：3 2 1</span></span><br><span class="line"><span class="comment"># 因为从左端插入，所以最后插入的 3 放在最左边</span></span><br><span class="line">LPUSH number 1 2 3</span><br></pre></td></tr></table></figure>
<h5 id="LPOP"><a href="#LPOP" class="headerlink" title="LPOP"></a>LPOP</h5><p><code>LPOP key [count]</code>按顺序删除并返回最左端元素，<code>count</code>参数指定删除元素的数量。注意：</p>
<ul>
<li>列表元素不够，就有多少删多少；</li>
<li>列表为空，返回 nil；<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回 3 2 </span></span><br><span class="line">LPOP number 2</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="RPUSH"><a href="#RPUSH" class="headerlink" title="RPUSH"></a>RPUSH</h5><p><code>RPUSH key element [element ...]</code>往列表右端添加元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自左向右依次存储：1 2 3</span></span><br><span class="line">RPUSH number 1 2 3</span><br></pre></td></tr></table></figure>
<h5 id="RPOP"><a href="#RPOP" class="headerlink" title="RPOP"></a>RPOP</h5><p><code>RPOP key [count]</code>按顺序删除并返回最右端元素，<code>count</code>参数指定删除元素的数量。注意事项与<code>LPOP</code>一样。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回 3 2 </span></span><br><span class="line">RPOP number 2</span><br></pre></td></tr></table></figure>
<h5 id="LRANGE"><a href="#LRANGE" class="headerlink" title="LRANGE"></a>LRANGE</h5><p><code>LRANGE key start stop</code>获取列表指定下标的元素，下标范围为<code>[start, stop]</code>。<br>有以下注意点：</p>
<ul>
<li>下标表示范围是左右包含且从 0 开始计数；</li>
<li>若下标右侧越界，则会取到最后一个元素；</li>
<li>与 Python 类似，负数下标表示从后往前取；<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取列表最后两个元素</span></span><br><span class="line">LRANGE number -2 -1</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="BLPOP"><a href="#BLPOP" class="headerlink" title="BLPOP"></a>BLPOP</h5><p><code>BLPOP key [key ...] timeout</code>删除并返回指定列表最左侧的元素，若列表为空则阻塞等待指定时长，单位秒。注意：这边传的多个<code>key</code>不是同时删除多个列表的意思，而是删除的时候从前到后依次判断，若某列表有元素就删除该列表的元素并结束，若所有列表均为空则等待。</p>
<h5 id="BRPOP"><a href="#BRPOP" class="headerlink" title="BRPOP"></a>BRPOP</h5><p><code>BRPOP key [key ...] timeout</code>删除并返回指定列表最右侧的元素，注意事项与<code>BLPOP</code>一样。</p>
<h5 id="LLEN"><a href="#LLEN" class="headerlink" title="LLEN"></a>LLEN</h5><p><code>LLEN key</code>返回指定列表长度。</p>
<h5 id="LPOS"><a href="#LPOS" class="headerlink" title="LPOS"></a>LPOS</h5><p><code>LPOS key element</code>返回列表中<code>element</code>所在下标，不存在返回 nil。</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Set 是 Redis 里面的无序集合，Redis 支持我们操作单个集合或做集合间的运算。</p>
<h5 id="SADD"><a href="#SADD" class="headerlink" title="SADD"></a>SADD</h5><p><code>SADD key member [member ...]</code>往集合添加若干个元素。</p>
<h5 id="SREM"><a href="#SREM" class="headerlink" title="SREM"></a>SREM</h5><p><code>SREM key member [member ...]</code>删除集合里的若干个元素。</p>
<h5 id="SCARD"><a href="#SCARD" class="headerlink" title="SCARD"></a>SCARD</h5><p><code>SCARD key</code>返回集合的长度。</p>
<h5 id="SISMEMBER"><a href="#SISMEMBER" class="headerlink" title="SISMEMBER"></a>SISMEMBER</h5><p><code>SISMEMBER key member</code>返回元素<code>member</code>是否是集合里的元素。</p>
<h5 id="SMEMBERS"><a href="#SMEMBERS" class="headerlink" title="SMEMBERS"></a>SMEMBERS</h5><p><code>SMEMBERS key</code>返回集合里的所有元素。</p>
<h5 id="SPOP"><a href="#SPOP" class="headerlink" title="SPOP"></a>SPOP</h5><p><code>SPOP key [count]</code>随机删除并返回集合中的<code>count</code>个元素，默认删一个。</p>
<h5 id="SINTER"><a href="#SINTER" class="headerlink" title="SINTER"></a>SINTER</h5><p><code>SINTER key [key ...]</code>返回若干个集合的交集。</p>
<h5 id="SINTERSTORE"><a href="#SINTERSTORE" class="headerlink" title="SINTERSTORE"></a>SINTERSTORE</h5><p><code>SINTERSTORE destination key [key ...]</code>将若干个集合的交集存储到<code>destination</code>指定的集合中，该集合不存在就创建，存在就覆盖。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以 set1、set2、set3 三者的交集生成 newSet</span></span><br><span class="line">SINTERSTORE newSet set1 set2 set3</span><br></pre></td></tr></table></figure>
<h5 id="SDIFF"><a href="#SDIFF" class="headerlink" title="SDIFF"></a>SDIFF</h5><p><code>SDIFF key [key ...]</code>返回第一个集合与其它集合的差集。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回 set1 - set2 - set3</span></span><br><span class="line">SDIFF set1 set2 set3</span><br></pre></td></tr></table></figure>
<h5 id="SDIFFSTORE"><a href="#SDIFFSTORE" class="headerlink" title="SDIFFSTORE"></a>SDIFFSTORE</h5><p><code>SDIFFSTORE destination key [key ...]</code>将第一个集合与其它集合的差集存储到<code>destination</code>指定的集合中，该集合不存在就创建，存在就覆盖。</p>
<h5 id="SUNION"><a href="#SUNION" class="headerlink" title="SUNION"></a>SUNION</h5><p><code>SUNION key [key ...]</code>返回若干集合的交集，注意重复元素会被剔除。</p>
<h5 id="SUNIONSTORE"><a href="#SUNIONSTORE" class="headerlink" title="SUNIONSTORE"></a>SUNIONSTORE</h5><p><code>SUNIONSTORE destination key [key ...]</code>将若干集合的交集存储到destination指定的集合中，该集合不存在就创建，存在就覆盖。</p>
<h4 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h4><p>SortedSet 是 Redis 里面的有序集合（元素唯一），一般用于存储排行榜等有顺序的数据。SortedSet 需要我们为存储的数据指定一个 score，这个 score 就是排序的依据。</p>
<h5 id="ZADD"><a href="#ZADD" class="headerlink" title="ZADD"></a>ZADD</h5><p><code>ZADD key score member [score member ...]</code>添加或修改若干元素到集合中，元素不存在就添加元素，元素存在就修改其分数。</p>
<h5 id="ZREM"><a href="#ZREM" class="headerlink" title="ZREM"></a>ZREM</h5><p><code>ZREM key member [member ...]</code>删除集合中若干元素。</p>
<h5 id="ZSCORE"><a href="#ZSCORE" class="headerlink" title="ZSCORE"></a>ZSCORE</h5><p><code>ZSCORE key member</code>返回一个元素的分数，元素不存在返回 nil。</p>
<h5 id="ZRANK"><a href="#ZRANK" class="headerlink" title="ZRANK"></a>ZRANK</h5><p><code>ZRANK key member</code>返回元素的正序排名，从 0 开始。正序排名是指集合从小到大排列，元素在里面的排名。</p>
<h5 id="ZCARD"><a href="#ZCARD" class="headerlink" title="ZCARD"></a>ZCARD</h5><p><code>ZCARD key</code>返回集合的大小，集合不存在返回 0。</p>
<h5 id="ZCOUNT"><a href="#ZCOUNT" class="headerlink" title="ZCOUNT"></a>ZCOUNT</h5><p><code>ZCOUNT key min max</code>返回分数在<code>[min, max]</code>范围内元素的个数。</p>
<h5 id="ZINCRBY"><a href="#ZINCRBY" class="headerlink" title="ZINCRBY"></a>ZINCRBY</h5><p><code>ZINCRBY key increment member</code>对集合中某元素的分数<code>+increment</code>。</p>
<h5 id="ZRANGE"><a href="#ZRANGE" class="headerlink" title="ZRANGE"></a>ZRANGE</h5><p><code>ZRANGE key start stop</code>返回正序排名在<code>[start, stop]</code>范围的所有元素。</p>
<h5 id="ZRANGEBYSCORE"><a href="#ZRANGEBYSCORE" class="headerlink" title="ZRANGEBYSCORE"></a>ZRANGEBYSCORE</h5><p><code>ZRANGEBYSCORE key min max</code>返回分数在<code>[min, max]</code>范围的所有元素。</p>
<h5 id="ZINTER"><a href="#ZINTER" class="headerlink" title="ZINTER"></a>ZINTER</h5><p><code>ZINTER numkeys key [key ...]</code>返回若干个集合的交集，<code>numkeys</code>指定集合的数量。注意返回的仅仅是元素本身，不会返回元素对应的分数。</p>
<h5 id="ZINTERSTORE"><a href="#ZINTERSTORE" class="headerlink" title="ZINTERSTORE"></a>ZINTERSTORE</h5><p><code>ZINTERSTORE destination numkeys key [key ...]</code>将若干集合的交集存储到<code>destination</code>指定的集合中，分数是所有集合中该元素分数的总和。</p>
<h5 id="ZDIFF"><a href="#ZDIFF" class="headerlink" title="ZDIFF"></a>ZDIFF</h5><p><code>ZDIFF numkeys key [key ...]</code>返回第一个集合与后面所有集合的差，返回的也是元素本身，不包含其分数。</p>
<h5 id="ZDIFFSTORE"><a href="#ZDIFFSTORE" class="headerlink" title="ZDIFFSTORE"></a>ZDIFFSTORE</h5><p><code>ZDIFFSTORE destination numkeys key [key ...]</code>将第一个集合与后面所有集合的差存储到<code>destination</code>指定的集合中，元素对应的分数就是元素在第一个集合中的分数。</p>
<h5 id="ZUNION"><a href="#ZUNION" class="headerlink" title="ZUNION"></a>ZUNION</h5><p><code>ZUNION numkeys key [key ...]</code>返回所有集合的并集并保证结果集元素唯一，返回结果仍然不包含元素的分数。</p>
<h5 id="ZUNIONSTORE"><a href="#ZUNIONSTORE" class="headerlink" title="ZUNIONSTORE"></a>ZUNIONSTORE</h5><p><code>ZUNIONSTORE destination numkeys key [key ...]</code>将所有集合的并集存储到destination指定的集合中，新集合中元素的分数是之前集合中同元素分数的和。</p>
<h5 id="逆序操作"><a href="#逆序操作" class="headerlink" title="逆序操作"></a>逆序操作</h5><p>上面基本都是正序操作，即元素按照分数从小到大排序然后取值。很多时候需要用到逆序操作，这些操作与正序操作不过多了<code>REV</code>。举个例子，我想获取元素在集合里的排名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 元素正序排列，取 member 排名</span></span><br><span class="line">ZRANK key member</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素逆序排列，取 member 排名</span></span><br><span class="line">ZREVRANK key member</span><br></pre></td></tr></table></figure>
<h4 id="key-层级结构"><a href="#key-层级结构" class="headerlink" title="key 层级结构"></a>key 层级结构</h4><p>我们在存在数据的时候，应当如何设计 key 使得不同项目、不同类型数据的 key 不会重复呢？Redis 支持我们使用<code>:</code>定义 key 的层级结构，一般定义规则：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目名:业务名:类型名:<span class="built_in">id</span></span><br></pre></td></tr></table></figure>
<p>假设项目名是<code>lylmx</code>，业务名省略，我们有两种类型的数据（<code>user</code>与<code>product</code>）。具体数据如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户信息：<span class="punctuation">&#123;</span>id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> name<span class="punctuation">:</span> <span class="string">&quot;Lucy&quot;</span><span class="punctuation">,</span> age<span class="punctuation">:</span> <span class="number">18</span><span class="punctuation">&#125;</span></span><br><span class="line">商品信息：<span class="punctuation">&#123;</span>id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> name<span class="punctuation">:</span> <span class="string">&quot;iWatch&quot;</span><span class="punctuation">,</span> price<span class="punctuation">:</span> <span class="number">2888</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用下面的命令将数据存到 Redis 中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET lylmx:user:1 <span class="string">&#x27;&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;Lucy&quot;, &quot;age&quot;: 18&#125;&#x27;</span></span><br><span class="line">SET lylmx:product:1 <span class="string">&#x27;&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;iWatch&quot;, &quot;price&quot;: 2888&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>我们打开图形化界面查看存储的这两条数据，可以看到如下图：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1718372353317-03bac2a9-2e3b-4c1b-bcfb-173a1d3d4929.png#averageHue=%23fafafa&clientId=ubfac4f3d-4264-4&from=paste&height=155&id=u15c65174&originHeight=155&originWidth=513&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16130&status=done&style=none&taskId=udfb8325e-6a2c-4f83-bed7-4cc38eaf8fa&title=&width=513" alt="image.png"><br>图形化界面会根据键的层级创建出对应的目录（可视化）。</p>
<h3 id="Java-集成-Redis"><a href="#Java-集成-Redis" class="headerlink" title="Java 集成 Redis"></a>Java 集成 Redis</h3><h4 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h4><p>Jedis 是 Java 操作 Redis 的库，这个库里面的方法及其用法与 Redis 的操作保持一致。因此学会了上面 Redis 的操作，这个库基本就掌握了。</p>
<h5 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p>我们使用字符串操作与 Hash 操作简单看一下 Jedis 的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Jedis 对象并指定域名端口号</span></span><br><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">jedis.auth(<span class="string">&quot;123456&quot;</span>);  <span class="comment">// 指定连接密码</span></span><br><span class="line">jedis.select(<span class="number">0</span>);  <span class="comment">// 选择第 0 个库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 往库里新增一个键值对</span></span><br><span class="line">jedis.set(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">// 获取哈希字段</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.hget(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">System.out.println(hello + name);</span><br></pre></td></tr></table></figure>
<p>可以看到 Jedis 提供的方法名与参数结构和 Redis 提供的方法是一致的。</p>
<h5 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h5><p>Jedis 很好用，几乎没有学习成本。但美中不足的是 Jedis 线程不安全，因此需要配合连接池使用。我们自定义连接池如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        <span class="comment">// 最大连接数</span></span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 最大空闲连接数</span></span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 最小空闲连接数</span></span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 等待连接的超时时间</span></span><br><span class="line">        jedisPoolConfig.setMaxWait(Duration.ofSeconds(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jedisPoolConfig, <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">                                  <span class="number">6379</span>, <span class="number">1000</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义完成之后，后面我们想要使用 Jedis 对象就不需要<code>new</code>了，直接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisConnectFactory.getJedis();</span><br><span class="line">jedis.select(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 其它操作</span></span><br></pre></td></tr></table></figure>
<p>获取的 Jedis 对象不需要配置密码，因为我们在连接池里面已经配置过密码了。</p>
<h4 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a>SpringDataRedis</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>市面上除了上面的 Jedis 库可以操作 Redis，还有许多好用的操作 Redis 的库，例如 lettuce。不同的库使用方式不同，学习成本太高。此时 SpringDataRedis 出现了，它提供一套统一的接口给我们使用，底层实现随意，可以是 Jedis 也可以是 lettuce（默认使用 lettuce）。因此以后我们可以只学习 SpringDataRedis 的用法，剩下的交给 Spring。<br>SpringDataRedis 中提供了 RedisTemplate 工具类，其中封装了各种对 Redis 的操作。并且将不同数据类型的操作 API 封装到了不同的类型中：</p>
<table>
<thead>
<tr>
<th><strong>API</strong></th>
<th><strong>返回值类型</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>redisTemplate.opsForValue()</code></td>
<td><code>ValueOperations</code></td>
<td>操作 String 类型数据</td>
</tr>
<tr>
<td><code>redisTemplate.opsForHash()</code></td>
<td><code>HashOperations</code></td>
<td>操作 Hash 类型数据</td>
</tr>
<tr>
<td><code>redisTemplate.opsForList()</code></td>
<td><code>ListOperations</code></td>
<td>操作 List 类型数据</td>
</tr>
<tr>
<td><code>redisTemplate.opsForSet()</code></td>
<td><code>SetOperations</code></td>
<td>操作 Set 类型数据</td>
</tr>
<tr>
<td><code>redisTemplate.opsForZSet()</code></td>
<td><code>ZSetOperations</code></td>
<td>操作 SortedSet 类型数据</td>
</tr>
<tr>
<td><code>redisTemplate</code></td>
<td></td>
<td>操作通用数据，例如获取所有键</td>
</tr>
</tbody></table>
<h5 id="导包-1"><a href="#导包-1" class="headerlink" title="导包"></a>导包</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Redis 相关依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 额外的连接池相关依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;卢研&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码不难理解，我想往 Redis 里面存储一个简单的键值对，键为<code>name</code>，值为<code>卢研</code>。但实际上可以通过图形化界面看到存储的内容是：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1718607835556-32d221e4-3c4a-4158-a383-4faaf67d7620.png#averageHue=%23fdfafa&clientId=u7ed0da09-d40f-4&from=paste&height=382&id=KfQaV&originHeight=382&originWidth=655&originalType=binary&ratio=1&rotation=0&showTitle=false&size=33855&status=done&style=stroke&taskId=uae54abee-7599-437e-86ed-2aee23022af&title=&width=655" alt="image.png"><br>可以看到键和值里面都多了一些莫名其妙的东西，这显然不是我们想要的结果。出现这个现象的原因是默认情况下<code>redisTemplate</code>会对存储的内容做原生序列化，然后将序列化之后的结果存进去。</p>
<h5 id="自定义模板"><a href="#自定义模板" class="headerlink" title="自定义模板"></a>自定义模板</h5><p>为了解决上述问题，我们可以在配置类里定制<code>redisTemplate</code>，替换掉里面的序列化器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">    RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键都使用字符串</span></span><br><span class="line">    template.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">    template.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">    <span class="comment">// 值都转 json</span></span><br><span class="line">    template.setValueSerializer(serializer);</span><br><span class="line">    template.setHashValueSerializer(serializer);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们的配置中，键名直接使用字符串形式，值会经过 json 序列化然后存储。后面自动注入的时候会使用我们自定义的<code>redisTemplate</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;卢研&quot;</span>, <span class="number">18</span>);</span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line"><span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>自定义序列化器之后，传进去一个对象会转为 json 存储，读取的时候也会反序列化成对应类型的对象。</p>
<h5 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h5><p> 使用自定义模板非常方便，但也存在一个问题。首先我们看一下存储一个<code>User</code>类型数据的结果：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@class&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.luyan.pojo.User&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;卢研&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">18</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看到除了对象本身具有的字段，多了<code>@class</code>字段。这个字段保存该数据对应的实体类类型，这也是读取时能够反序列化的依据。当然有好处也有坏处，坏处就是这会造成额外的开销，而 Redis 又是基于内存，空间非常紧张。解决方案是手动进行序列化与反序列化，SpringDataRedis 给我们提供了<code>StringRedisTemplate</code>类，这个类进行存储的时候不论键还是值都直接作为字符串存储：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"><span class="keyword">private</span> <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;卢研&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="comment">// 手动进行序列化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(user);</span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;user&quot;</span>, json);</span><br><span class="line">    json = stringRedisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="comment">// 手动反序列化</span></span><br><span class="line">    user = objectMapper.readValue(json, User.class);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h3><p>Spring Cache 是 Spring 提供的缓存组件，仍然是提供接口，底层可以使用各种各样的缓存中间件。我们这边当然使用 Redis 作为底层中间件。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><h5 id="导包-2"><a href="#导包-2" class="headerlink" title="导包"></a>导包</h5><p>需要 Redis 作为底层中间件，所以直接导 Redis 相关的包即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="启用缓存"><a href="#启用缓存" class="headerlink" title="启用缓存"></a>启用缓存</h5><p>在启动类上使用<code>@EnableCaching</code>注解来启用缓存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Main.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><h5 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h5><p>SpEL 是 Spring Expression Language 的简写，它主要用于在注解中获取被修饰方法的信息。SpEL 里面主要有两个对象，分别是：</p>
<ul>
<li><code>#root</code>可以获取被修饰方法的详细信息，例如当前方法对象、所属实例对象等；</li>
<li><code>#result</code>表示方法的返回值，如果返回值是一个对象，可以通过<code>#result.xxx</code>的方式获取对象属性；</li>
</ul>
<p>我们比较常用的是获取以下信息：</p>
<ol>
<li>方法名：<code>#root.methodName</code></li>
<li>方法参数的获取有三种方式：<ol>
<li><code>#root.args[0]</code>获取第一个参数；</li>
<li><code>#p1</code>也是获取第一个参数；</li>
<li><code>#xxx</code>直接使用参数的名字获取；</li>
</ol>
</li>
<li>返回值：<code>#result</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. @example 仅作为示例，并不存在</span></span><br><span class="line"><span class="comment">// 2. 注解里面使用 SpEL 表达式的前提是这个注解支持</span></span><br><span class="line"><span class="comment">// 3. 这边表达式比较容易理解，需要注意的是如果只想写字符串需要使用单引号括起来</span></span><br><span class="line"><span class="meta">@example(&quot;&#x27;user&#x27; + #root.methodName + #p1.name&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">user</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
之所以普通字符串需要使用单引号括起来，是因为不加引号又没有<code>#</code>前缀会默认认为前面有<code>#root.</code>。因此获取方法名可以直接写<code>methodName</code>。</li>
</ol>
<h5 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h5><p> 对方法使用<code>@Cacheable</code>注解，每次执行该方法的时候会尝试从缓存查找结果：</p>
<ul>
<li>若能找到，则直接返回该结果，此时不会执行方法体；</li>
<li>若找不到结果，则执行方法体并将结果存到缓存中；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable(value = &quot;userGroup&quot;, key = &quot;&#x27;user&#x27; + #p0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">one</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
按照直觉缓存是键值对存储，但这边两个参数是什么意思？实际上 SpringCache 分层级存储，上面第一个指定的<code>userGroup</code>是群组名，后面的<code>key</code>指定的是键。所谓群组就是为了让数据存储更条理，例如用户数据存到用户群组，商品数据存到商品群组等。最后到 Redis 里面的键是<code>userGroup:user1</code>。</li>
</ul>
<h5 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h5><p> <code>@CacheEvict</code>注解用来删除缓存，每次执行被修饰方法，都会删除对应的缓存。与上面类似需要传递<code>value</code>与<code>key</code>属性，除此之外还有一个<code>allEntries</code>属性用来指定删除时是否删除全部缓存，默认<code>false</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这边指定 key 就有点多余了，因为会删除所有 userGroup 组下的缓存</span></span><br><span class="line"><span class="meta">@CacheEvict(value = &quot;userGroup&quot;, key = &quot;&#x27;user&#x27; + #id&quot;, allEntries = true)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;方法执行，id：&quot;</span> + id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有设置<code>allEntries</code>会根据<code>value</code>与<code>key</code>属性构造键删除指定缓存。</p>
<h5 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h5><p><code>@CachePut</code>注解会将被修饰方法的返回值存进缓存，与<code>@Cacheable</code>的区别是不论缓存是否存在，<code>@CachePut</code>都会执行方法并将结果存到缓存之中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CachePut(value = &quot;userGroup&quot;, key = &quot;&#x27;user&#x27; + #user.id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">put</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方式与其它注解没什么不同，不过在注解里面指定键需要的参数罢了。</p>
<h5 id="Caching"><a href="#Caching" class="headerlink" title="@Caching"></a>@Caching</h5><p>如果我想在一个方法上面定义多个缓存逻辑，应该怎么做？在方法上添加多个缓存注解？<br>例如，我想在一个方法执行的时候删除指定缓存，但是我想删除的逻辑有两条。此时可以使用<code>@Caching</code>注解实现多缓存逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Caching(evict = &#123;</span></span><br><span class="line"><span class="meta">    @CacheEvict(value = &quot;userGroup&quot;, key = &quot;&#x27;id&#x27; + #user.id&quot;),</span></span><br><span class="line"><span class="meta">    @CacheEvict(value = &quot;userGroup&quot;, key = &quot;&#x27;name&#x27; + #user.name&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就实现了执行方法时删除多条缓存的逻辑，除此之外<code>@Caching</code>注解还有<code>cacheable</code>和<code>put</code>属性，这两个属性里面分别写<code>@Cacheable</code>和<code>@CachePut</code>注解。</p>
<h5 id="CacheConfig"><a href="#CacheConfig" class="headerlink" title="@CacheConfig"></a>@CacheConfig</h5><p><code>@CacheConfig</code>注解作用于类上，可以使用这个注解统一定义群组。例如一个类里面所有缓存策略都在同一个群组下面，就可以使用<code>@CacheConfig</code>注解将群组抽取出来定义在类上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheConfig(cacheNames = &quot;userGroup&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了群组之后，里面的方法上的注解就可以不指定群组，如果指定还是以方法上的群组为准。</p>
<h4 id="条件式缓存"><a href="#条件式缓存" class="headerlink" title="条件式缓存"></a>条件式缓存</h4><p>上面所有的缓存策略都是无条件的，有时我们会根据情况的不同决定是否使用缓存，这就叫做条件式缓存。<code>@Cacheable</code>、<code>@CachePut</code>注解都有以下属性：</p>
<ul>
<li><code>condition</code>指定条件为<strong>真</strong>才会执行缓存逻辑；</li>
<li><code>unless</code>指定条件为<strong>假</strong>才会执行缓存逻辑；</li>
</ul>
<p><code>@CacheEvict</code>注解只有<code>condition</code>属性，没有<code>unless</code>属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传来的 id ≥ 0 才会走缓存逻辑，否则都走函数体</span></span><br><span class="line"><span class="meta">@Cacheable(key = &quot;&#x27;user&#x27; + #id&quot;, condition = &quot;#id &gt;= 0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">one</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;方法执行，id：&quot;</span> + id);</span><br><span class="line">    System.out.println(cacheManager);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/17/MyBatis-Plus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/08/17/MyBatis-Plus/" itemprop="url">MyBatis-Plus</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-08-17T11:47:38+08:00">
                2023-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MyBatis-Plus 是对 MyBatis 的二次封装，可以让我们少写 sql 语句。</p>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-plus --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- jdbc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Druid 连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- mysql 连接器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Lombok --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 测试包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>我们需要连接数据库，所以我们需要配置 Druid 连接池。配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/demo</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">mysql2425@</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>
<h4 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h4><p>和 MyBatis 一样，我们需要定义 mapper 接口。但不同的是，单表操作完全不需要我们操心，我们只需要继承<code>BaseMapper</code>接口，这个接口里面有单表操作的默认实现，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>继承<code>BaseMapper</code>有两个注意点：</p>
<ol>
<li>多表操作需要自己写 sql 语句；</li>
<li>继承时指定的泛型名会默认作为操作的表名（忽略大小写）；</li>
</ol>
<h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><p>SpringBoot 项目需要书写启动类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.luyan.mappers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Main.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>因为主要学习 MyBatis-Plus，因此直接使用测试类进行测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span>  <span class="comment">// SpringBoot 测试类注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用继承来的 selectList 方法获取所有数据</span></span><br><span class="line">        List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mapper-CRUD"><a href="#Mapper-CRUD" class="headerlink" title="Mapper CRUD"></a>Mapper CRUD</h3><p>本节主要介绍一下 mapper 层提供的 CRUD 方法，即<code>BaseMapper</code>提供的数据库操作。</p>
<h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><p>插入数据只有一个方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(T entity)</span>;</span><br></pre></td></tr></table></figure>
<p>使用起来也非常简单，只需要创建一个实体类，直接调用<code>insert</code>方法即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(<span class="number">6</span>);</span><br><span class="line">user.setAge(<span class="number">20</span>);</span><br><span class="line">user.setName(<span class="string">&quot;六六&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> userMapper.insert(user);  <span class="comment">// 添加数据</span></span><br></pre></td></tr></table></figure>
<h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><p>正常使用的比较多的有 4 个方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 id 删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 id 批量删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(Collection&lt;?&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据条件删除记录，会使用 key=value 作为条件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据条件删除记录，Wrapper 是条件封装类</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure>
<p>上面方法中最后一个条件删除方法，里面的<code>Wrapper</code>类型是条件类型，我们后面统一说。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> userMapper.deleteById(<span class="number">1</span>);  <span class="comment">// 删一个</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> userMapper.deleteBatchIds(List.of(<span class="number">1</span>, <span class="number">2</span>));  <span class="comment">// 删一批</span></span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;age&quot;</span>, <span class="number">19</span>);</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;赵六&quot;</span>);</span><br><span class="line"><span class="comment">// 最后的删除条件会变成 age=19 AND name=&quot;赵六&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> userMapper.deleteByMap(map);</span><br></pre></td></tr></table></figure>
<h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><p>更新数据我们常用的是以下 2 个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 id 更新数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateById</span><span class="params">(T entity)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据条件更新数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span>;</span><br></pre></td></tr></table></figure>
<p>要更新的数据显然都存在<code>entity</code>里面，实体类里面为<code>null</code>的字段不参与更新，因此设计实体类时字段类型都使用包装类型。<code>updateById</code>方法会使用 id 作为更新条件，<code>update</code>方法会使用指定条件参数作为条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(<span class="number">3</span>);</span><br><span class="line">user.setName(<span class="string">&quot;KK&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> userMapper.updateById(user);  <span class="comment">// 根据 id 更新姓名</span></span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setAge(<span class="number">22</span>);</span><br><span class="line"><span class="comment">// 无条件即更新所有记录</span></span><br><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> userMapper.update(user1, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 id 查询</span></span><br><span class="line">T <span class="title function_">selectById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据条件查询一条记录</span></span><br><span class="line">T <span class="title function_">selectOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 id 批量查询</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据条件查询记录</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 key=value 作为条件查询记录</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据条件查询，将结果保存在 List&lt;Map&lt;String, Object&gt;&gt; 中</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据条件查询，返回由所有记录第一个字段构成的列表</span></span><br><span class="line">&lt;E&gt; List&lt;E&gt; <span class="title function_">selectObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分页查询</span></span><br><span class="line">&lt;P <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;T&gt;&gt; P <span class="title function_">selectPage</span><span class="params">(P page, Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line">&lt;P <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;Map&lt;String, Object&gt;&gt;&gt; P <span class="title function_">selectMapsPage</span><span class="params">(P page, Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据条件查询记录条数</span></span><br><span class="line">Long <span class="title function_">selectCount</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure>
<p>这些方法都是比较容易理解的，简单使用样例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; ids = userMapper.selectObjs(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; users = userMapper.selectMaps(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Service-CRUD"><a href="#Service-CRUD" class="headerlink" title="Service CRUD"></a>Service CRUD</h3><p>一般而言，数据库操作是放在 mapper 层的，但 MyBatis-Plus 居然提供了 service 层操作数据库的方法。之所以有这样的需求，是因为在很多简单的数据库操作中，service 层只是走个过场，方法里面也只是调用 mapper 层。这浪费了效率，因此出现了 service 层操作数据库的操作。</p>
<h4 id="创建-Service"><a href="#创建-Service" class="headerlink" title="创建 Service"></a>创建 Service</h4><p>我们想在 Service 层调用对应的数据库操作方法，首先这个 Service 肯定需要实现某接口，就和 Mapper 层操作数据库一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Service 实现 IService 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>这边和上面 Mapper 层似乎差不多，但<code>IService</code>接口里面有很多方法没有实现。但是 MyBatis-Plus 提供了<code>ServiceImpl </code>类，这个类继承于<code>IService</code>接口并实现了所有抽象方法，因此我们一般直接继承这个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>
<p><code>ServiceImpl</code>类有两个泛型（按照顺序记为<code>M、T</code>）：</p>
<ul>
<li><code>M</code>需要满足<code>M extends BaseMapper&lt;T&gt; </code>，也就是说这边<code>M</code>是 Mapper 层的操作接口；</li>
<li><code>T</code>层就是实体类；</li>
</ul>
<p>在日常使用中，我们一般会使用接口来接受对象，因此我们更多使用如下方式定义 Service：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;  <span class="comment">// 额外实现我们自定义的接口方便功能扩展</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是在需要的地方可以直接注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;  <span class="comment">// 使用接口类型声明变量</span></span><br></pre></td></tr></table></figure>
<h4 id="增-1"><a href="#增-1" class="headerlink" title="增"></a>增</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">save</span><span class="params">(T entity)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br></pre></td></tr></table></figure>
<p><code>save</code>方法很简单，不多解释。我们知道数据库<code>insert</code>语句可以一次插入多条数据，但这边的<code>saveBatch</code>方法实际上会生成多条<code>insert</code>语句，即挨条插入数据。<code>batchSize</code>参数表示插多少条数据就刷新一下，如果不传这个参数默认是 1000 条。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">89</span>);</span><br><span class="line"><span class="comment">// 插入一条数据</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> userService.save(user);</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;P1&quot;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;P2&quot;</span>, <span class="number">19</span>);</span><br><span class="line">List&lt;User&gt; list1 = List.of(user1, user2);</span><br><span class="line"><span class="comment">// 批量插入，每插入 1000 条就刷新一次数据库</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> userService.saveBatch(list1);</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">7</span>, <span class="string">&quot;P3&quot;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">8</span>, <span class="string">&quot;P4&quot;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">9</span>, <span class="string">&quot;P5&quot;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">10</span>, <span class="string">&quot;P6&quot;</span>, <span class="number">19</span>);</span><br><span class="line">List&lt;User&gt; list2 = List.of(user3, user4, user5, user6);</span><br><span class="line"><span class="comment">// 批量插入，每插入 2 条就刷新一次数据库</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> userService.saveBatch(list2, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>因为批量添加数据是多次使用<code>insert</code>语句，所以效率不是很高，如果想要高效的批量的插入可以自己实现。实现方式我们之前学过，在 mapper xml 文件里面使用<code>foreach</code>标签定义插入语句。</p>
<h4 id="删-1"><a href="#删-1" class="headerlink" title="删"></a>删</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 id 删除</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 id 批量删除</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件删除，条件是 key=value</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 queryWrapper 设置的条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure>
<p>这些方法都很容易理解，使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 id 删除数据</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> userService.removeById(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; ids = List.of(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 根据 id 批量删除数据</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> userService.removeByIds(ids);</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;uid&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 根据条件删除数据，key=value</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> userService.removeByMap(map);</span><br></pre></td></tr></table></figure>
<h4 id="改-1"><a href="#改-1" class="headerlink" title="改"></a>改</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 id 修改</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateById</span><span class="params">(T entity)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 id 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 id 批量更新，batchSize 指定刷新数据阈值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(T updateEntity, Wrapper&lt;T&gt; whereWrapper)</span>;</span><br></pre></td></tr></table></figure>
<p>大体使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;P3&quot;</span>, <span class="number">22</span>);</span><br><span class="line"><span class="comment">// 根据 id 修改数据</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> userService.updateById(user1);</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;P4&quot;</span>, <span class="number">22</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>, <span class="string">&quot;P5&quot;</span>, <span class="number">22</span>);</span><br><span class="line">List&lt;User&gt; list = List.of(user2, user3);</span><br><span class="line"><span class="comment">// 根据 id 批量修改数据</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> userService.updateBatchById(list);</span><br></pre></td></tr></table></figure>
<h4 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h4><h5 id="查一条数据"><a href="#查一条数据" class="headerlink" title="查一条数据"></a>查一条数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 id 查询一条记录</span></span><br><span class="line">T <span class="title function_">getById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 查询一条记录，throwEx 控制有多条数据是否抛异常</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="type">boolean</span> throwEx)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录，使用 Map 装数据</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">&lt;V&gt; V <span class="title function_">getObj</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br></pre></td></tr></table></figure>
<p>这些方法还是见名知义的，除去<code>Wrapper</code>作为参数的，使用案例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 id 获取数据，返回实体类对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h5 id="查多条数据"><a href="#查多条数据" class="headerlink" title="查多条数据"></a>查多条数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据条件查询列表</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 id 批量查询</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据条件查询，key=value</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询所有列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询全部记录，返回第一个字段数据组成的 List</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">&lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">&lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br></pre></td></tr></table></figure>
<p>简单使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有数据，返回实体类的集合</span></span><br><span class="line">List&lt;User&gt; list1 = userService.list();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 id 批量获取数据，返回实体类的集合</span></span><br><span class="line">List&lt;User&gt; list2 = userService.listByIds(List.of(<span class="number">4</span>, <span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;age&quot;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="comment">// 根据 Map 条件获取数据，返回实体类集合</span></span><br><span class="line">List&lt;User&gt; list3 = userService.listByMap(map);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有数据，返回 Map 集合</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; list4 = userService.listMaps();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有数据，返回数据第一个字段构成的集合</span></span><br><span class="line">List&lt;Object&gt; list5 = userService.listObjs();</span><br></pre></td></tr></table></figure>
<h5 id="统计查询"><a href="#统计查询" class="headerlink" title="统计查询"></a>统计查询</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询总记录数</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">count</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure>
<p>简单使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有记录条数</span></span><br><span class="line"><span class="type">long</span> <span class="variable">nums</span> <span class="operator">=</span> userService.count();</span><br></pre></td></tr></table></figure>
<h4 id="增改"><a href="#增改" class="headerlink" title="增改"></a>增改</h4><p>所谓“增改”指的是数据存在就修改，不存在就新增。具体有如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// id 存在就更新数据，否则插入数据</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量修改插入，是否存在仍然看 id</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量修改插入，是否存在仍然看 id</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br></pre></td></tr></table></figure>
<p>批量插入方法也是挨条记录操作，对每条记录，如果 id 存在就是更新，否则就是插入。<code>batchSize</code>参数的含义与插入一样，如果不传默认是 1000。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小黑&quot;</span>, <span class="number">22</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;王麻薯&quot;</span>, <span class="number">22</span>);</span><br><span class="line">List&lt;User&gt; list = List.of(user1, user2);</span><br><span class="line"><span class="comment">// 根据 id 判断记录是否存在，存在就修改数据，否则插入数据</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> userService.saveOrUpdateBatch(list);</span><br></pre></td></tr></table></figure>
<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>现在开发中分页查询是很常见的操作，MyBatis-Plus 分页操作非常简单。</p>
<h4 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h4><p>我们只需要在启动类里面使用<code>@Bean</code>注解添加插件即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.luyan.mappers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Main.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="comment">// 返回的实际上是插件的集合</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Mapper-分页"><a href="#Mapper-分页" class="headerlink" title="Mapper 分页"></a>Mapper 分页</h4><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取分页数据，将记录封装成实体类</span></span><br><span class="line">&lt;P <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;T&gt;&gt; P <span class="title function_">selectPage</span><span class="params">(P page, Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取分页数据，将记录封装成 Map</span></span><br><span class="line">&lt;P <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;Map&lt;String, Object&gt;&gt;&gt; P <span class="title function_">selectMapsPage</span><span class="params">(P page, Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Page 对象时传的两个参数分别是“当前页”与“页容量”</span></span><br><span class="line">Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">userMapper.selectPage(page, <span class="literal">null</span>);  <span class="comment">// 无条件查询所有</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;当前页：&quot;</span> + page.getCurrent());</span><br><span class="line">System.out.println(<span class="string">&quot;页容量：&quot;</span> + page.getSize());</span><br><span class="line">System.out.println(<span class="string">&quot;记录总数：&quot;</span> + page.getTotal());</span><br><span class="line">System.out.println(<span class="string">&quot;总页数：&quot;</span> + page.getPages());</span><br><span class="line">System.out.println(<span class="string">&quot;是否有前一页：&quot;</span> + page.hasPrevious());</span><br><span class="line">System.out.println(<span class="string">&quot;是否有下一页：&quot;</span> + page.hasNext());</span><br><span class="line">System.out.println(page.getRecords());  <span class="comment">// 记录集合</span></span><br></pre></td></tr></table></figure>
<h4 id="Service-分页"><a href="#Service-分页" class="headerlink" title="Service 分页"></a>Service 分页</h4><h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无条件分页查询，封装成实体类</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">page</span><span class="params">(IPage&lt;T&gt; page)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件分页查询，封装成实体类</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">page</span><span class="params">(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无条件分页查询，封装成 Map</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">pageMaps</span><span class="params">(IPage&lt;T&gt; page)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件分页查询，封装成 Map</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">pageMaps</span><span class="params">(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure>
<h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">userService.page(page);  <span class="comment">// 与 Mapper 层相比除了方法不一样，其它都是一样的</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前页：&quot;</span> + page.getCurrent());</span><br><span class="line">System.out.println(<span class="string">&quot;页容量：&quot;</span> + page.getSize());</span><br><span class="line">System.out.println(<span class="string">&quot;记录总数：&quot;</span> + page.getTotal());</span><br><span class="line">System.out.println(<span class="string">&quot;总页数：&quot;</span> + page.getPages());</span><br><span class="line">System.out.println(<span class="string">&quot;是否有前一页：&quot;</span> + page.hasPrevious());</span><br><span class="line">System.out.println(<span class="string">&quot;是否有下一页：&quot;</span> + page.hasNext());</span><br><span class="line">System.out.println(page.getRecords());</span><br></pre></td></tr></table></figure>
<h4 id="自定义方法分页"><a href="#自定义方法分页" class="headerlink" title="自定义方法分页"></a>自定义方法分页</h4><p>将分页插件应用到自定义方法上比较简单，只需要在定义方法的时候：</p>
<ul>
<li>方法第一个参数是<code>IPage</code>类型；</li>
<li>方法返回值类型是<code>IPage</code>；</li>
</ul>
<p>下面我们用一个例子看一下：</p>
<ol>
<li><p><code>UserMapper</code>接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 自定义方法，返回值类型与第一个参数类型都必须是 IPage</span></span><br><span class="line">    IPage&lt;User&gt; <span class="title function_">queryByAge</span><span class="params">(IPage&lt;User&gt; page, <span class="meta">@Param(&quot;age&quot;)</span> Integer age)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对应的<code>UserMapper.xml</code>文件如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 返回值类型是 IPage 的泛型类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryByAge&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE age=#&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实体类别名配置一下：、</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.luyan.pojo</span></span><br></pre></td></tr></table></figure>
<p>因为我们将 mapper 文件存在<code>resources/mapper</code>目录下，这是扫描的默认值，所以不需要特意配置。</p>
</li>
<li><p>最后测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">userMapper.queryByAge(page, <span class="number">19</span>);  <span class="comment">// 使用上没什么区别</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前页：&quot;</span> + page.getCurrent());</span><br><span class="line">System.out.println(<span class="string">&quot;页容量：&quot;</span> + page.getSize());</span><br><span class="line">System.out.println(<span class="string">&quot;记录总数：&quot;</span> + page.getTotal());</span><br><span class="line">System.out.println(<span class="string">&quot;总页数：&quot;</span> + page.getPages());</span><br><span class="line">System.out.println(<span class="string">&quot;是否有前一页：&quot;</span> + page.hasPrevious());</span><br><span class="line">System.out.println(<span class="string">&quot;是否有下一页：&quot;</span> + page.hasNext());</span><br><span class="line">System.out.println(page.getRecords());</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h3><p>使用 MyBatis-Plus 条件构造器可以构造灵活、高效的查询条件。</p>
<h4 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1715655588374-b5e00375-c3ca-4e35-80de-f9db12dafbd0.png#averageHue=%23fbfbf4&clientId=uf9dcd1fb-cfe1-4&from=paste&height=513&id=u90f10c21&originHeight=513&originWidth=1162&originalType=binary&ratio=1&rotation=0&showTitle=false&size=186616&status=done&style=none&taskId=ub1df0a63-89e6-4afe-8753-786e074a485&title=&width=1162" alt="image.png"></p>
<ul>
<li><code>Wrapper</code>：条件构造抽象类，最顶端父类<ul>
<li><code>AbstractWrapper</code><ul>
<li><code>UpdateWrapper</code>：修改条件封装</li>
<li><code>QueryWrapper</code>：查询&#x2F;删除&#x2F;修改条件封装</li>
<li><code>AbstractLambdaWrapper</code>：是 Lambda 语法<ul>
<li><code>**LambdaUpdateWrapper**</code>：Lambda 修改条件封装</li>
<li><code>**LambdaQueryWrapper**</code>：Lambda 查询&#x2F;删除&#x2F;修改条件封装</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这些条件构造器中我更推荐使用 Lambda 语法的。</p>
<h4 id="QueryWrapper"><a href="#QueryWrapper" class="headerlink" title="QueryWrapper"></a>QueryWrapper</h4><h5 id="like"><a href="#like" class="headerlink" title="like"></a>like</h5><p><code>like</code>方法对应数据库语句<code>column LIKE &#39;%val%&#39;</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">like(R column, Object val)  <span class="comment">// 两个参数分别表示列名和数据库的值</span></span><br><span class="line">like(<span class="type">boolean</span> condition, R column, Object val)  <span class="comment">// 多一个条件判断参数</span></span><br></pre></td></tr></table></figure>
<p>例：查询姓名里面有“王”字的所有用户</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;王&quot;</span>);  <span class="comment">// name LIKE &#x27;%王%&#x27;</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br></pre></td></tr></table></figure>
<h5 id="between"><a href="#between" class="headerlink" title="between"></a>between</h5><p><code>between</code>方法对应数据库语句<code>column BETWEEN val1 AND val2</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">between(R column, Object val1, Object val2)</span><br><span class="line">between(<span class="type">boolean</span> condition, R column, Object val1, Object val2)</span><br></pre></td></tr></table></figure>
<p>例：查询所有年龄在 18 到 20 之间的用户</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.between(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="number">20</span>);  <span class="comment">// age BETWEEN 18 AND 20</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br></pre></td></tr></table></figure>
<p>注意：<code>BETWEEN</code>是左右都包含，因此例子中是查询所有年龄为 18、19、20 的用户。</p>
<h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h5><p>比较操作有<code>=,&lt;&gt;,&gt;,&gt;=,&lt;,&lt;=</code>，对应方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等于 =</span></span><br><span class="line">eq(R column, Object val)</span><br><span class="line">eq(<span class="type">boolean</span> condition, R column, Object val)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不等于 &lt;&gt;</span></span><br><span class="line">ne(R column, Object val)</span><br><span class="line">ne(<span class="type">boolean</span> condition, R column, Object val)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大于 &gt;</span></span><br><span class="line">gt(R column, Object val)</span><br><span class="line">gt(<span class="type">boolean</span> condition, R column, Object val)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大于等于 &gt;=</span></span><br><span class="line">ge(R column, Object val)</span><br><span class="line">ge(<span class="type">boolean</span> condition, R column, Object val)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小于 &lt;</span></span><br><span class="line">lt(R column, Object val)</span><br><span class="line">lt(<span class="type">boolean</span> condition, R column, Object val)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小于等于 &lt;=</span></span><br><span class="line">le(R column, Object val)</span><br><span class="line">le(<span class="type">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure>
<p>例：将所有年龄小于 18 的用户年龄改为 18</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.lt(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setAge(<span class="number">18</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> userMapper.update(user, wrapper);</span><br></pre></td></tr></table></figure>
<h5 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h5><ul>
<li><code>isNull</code>方法对应数据库语句<code>column IS NULL</code></li>
<li><code>isNotNull</code>方法对应数据库语句<code>column IS NOT NULL</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isNull(R column)</span><br><span class="line">isNull(<span class="type">boolean</span> condition, R column)</span><br><span class="line"></span><br><span class="line">isNotNull(R column)</span><br><span class="line">isNotNull(<span class="type">boolean</span> condition, R column)</span><br></pre></td></tr></table></figure>
例：删除所有年龄为空的用户<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.isNull(<span class="string">&quot;age&quot;</span>);  <span class="comment">// age IS NULL</span></span><br><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> userMapper.delete(wrapper);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>排序分为升序排序和降序排序，有以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 升序排序</span></span><br><span class="line">orderByAsc(R... columns)</span><br><span class="line">orderByAsc(<span class="type">boolean</span> condition, R... columns)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 降序排序</span></span><br><span class="line">orderByDesc(R... columns)</span><br><span class="line">orderByDesc(<span class="type">boolean</span> condition, R... columns)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定排序升降</span></span><br><span class="line">orderBy(<span class="type">boolean</span> condition, <span class="type">boolean</span> isAsc, R... columns)</span><br></pre></td></tr></table></figure>
<p>例：查询所有用户要求按年龄降序、id 升序排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.orderByDesc(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">        .orderByAsc(<span class="string">&quot;id&quot;</span>);  <span class="comment">// ORDER BY age DESC, id ASC</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br></pre></td></tr></table></figure>
<p>注意：数据库里面使用多个关键字进行排序时，只有前面的字段相同才会使用后面的字段。</p>
<h5 id="or"><a href="#or" class="headerlink" title="or"></a>or</h5><p>如果有多个条件，默认使用<code>AND</code>连接。如果需要使用<code>OR</code>连接，可以调用以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">or()</span><br><span class="line">or(<span class="type">boolean</span> condition)</span><br></pre></td></tr></table></figure>
<p>注意：调用<code>or</code>方法之后，只有紧邻着的两个条件之间使用<code>OR</code>，其余的仍然是<code>AND</code>。<br>例：查询所有年龄为空或年龄在<code>[18, 20]</code>之间且姓名包含“王”的用户</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// age IS NULL OR age BETWEEN 18 AND 20 AND name LIKE &#x27;%王%&#x27;</span></span><br><span class="line">wrapper.isNull(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">        .or()</span><br><span class="line">        .between(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="number">20</span>)</span><br><span class="line">        .like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;王&quot;</span>);</span><br><span class="line">List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br></pre></td></tr></table></figure>
<h5 id="指定列"><a href="#指定列" class="headerlink" title="指定列"></a>指定列</h5><p>默认查询会查询所有字段，可以使用如下方法指定查询的字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select(R... columns)</span><br><span class="line">select(<span class="type">boolean</span> condition, R... columns)</span><br><span class="line"></span><br><span class="line">select(List&lt;R&gt; columns)</span><br><span class="line">select(<span class="type">boolean</span> condition, List&lt;R&gt; columns)</span><br></pre></td></tr></table></figure>
<p>例：查询所有年龄不为空的学生的姓名与年龄</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.select(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">wrapper.isNotNull(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br></pre></td></tr></table></figure>
<h5 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h5><p>使用条件构造器可以很方便的构造条件，但对于一些条件我们并不想无脑添加，而是满足一定条件时才添加。上面的方法基本都有一个重载的形式，第一个参数是一个<code>boolean condition</code>，这个<code>condition</code>就是条件表达式，当其值为<code>true</code>时对应的条件才会添加。<br>例：当前端传过来年龄不为空时才会追加一个<code>age &gt; val</code>的条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 只有前端传过来的 age != null 时才会限制 age 的大小</span></span><br><span class="line">wrapper.gt(age != <span class="literal">null</span>, <span class="string">&quot;age&quot;</span>, age);</span><br><span class="line">List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br></pre></td></tr></table></figure>
<h4 id="UpdateWrapper"><a href="#UpdateWrapper" class="headerlink" title="UpdateWrapper"></a>UpdateWrapper</h4><p>如果想修改数据，我们当然更推荐使用<code>UpdateWrapper</code>。相比<code>QueryWrapper</code>，<code>UpdateWrapper</code>有以下优点：</p>
<ol>
<li><code>UpdateWrapper</code>可以携带修改的数据，不需要额外创建实体类；</li>
<li><code>UpdateWrapper</code>可以把某个值设置为空，而<code>QueryWrapper</code>不能；</li>
</ol>
<p>例：把姓名为“张三”或“李四”的用户年龄设置为空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UpdateWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>)</span><br><span class="line">        .or()</span><br><span class="line">        .eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;李四&quot;</span>)</span><br><span class="line">        .set(<span class="string">&quot;age&quot;</span>, <span class="literal">null</span>);  <span class="comment">// 调用 set 方法存储要修改的值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> userMapper.update(wrapper);</span><br></pre></td></tr></table></figure>
<h4 id="Lambda-写法"><a href="#Lambda-写法" class="headerlink" title="Lambda 写法"></a>Lambda 写法</h4><p>Lambda 写法的 Wrapper 有两种：<code>LambdaQueryWrapper</code>与<code>LambdaUpdateWrapper</code>。这两者与上面介绍的<code>QueryWrapper</code>和<code>UpdateWrapper</code>的用法基本是一致的。只不过在表示列名上有所不同，普通的写法使用字符串表示列名，而这边使用 Lambda 表达式表示。<br>例：把姓名为“张三”或“李四”的用户年龄设置为空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LambdaUpdateWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.eq(User::getName, <span class="string">&quot;张三&quot;</span>)</span><br><span class="line">        .or()</span><br><span class="line">        .eq(User::getName, <span class="string">&quot;李四&quot;</span>)</span><br><span class="line">        .set(User::getAge, <span class="literal">null</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> userMapper.update(wrapper);</span><br></pre></td></tr></table></figure>
<p>可以看到用户上基本与<code>UpdateWrapper</code>一样，只是表示列名的地方换成 Lambda 表达式了。</p>
<h3 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h3><h4 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@TableName</h4><p>我们在创建 Mapper 时会继承 BaseMapper：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这样里面什么都不需要写就会拥有很多数据库操作，继承<code>BaseMapper</code>时需要通过泛型指定该 Mapper 用来操作哪张表。<br>默认情况下泛型名（User）就是表名，当然是忽略大小写的。如果表名与实体类不同名，我们可以在实体类上使用<code>@TableName</code>注解来指定实体类对应的表名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;t_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;  <span class="comment">// 将实体类 User 与表 t_user 绑定</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实在开发中，数据库表一般都使用<code>t_</code>开头，而实体类命名一般会忽略这个前缀。那这种情况下每个实体类都需要使用<code>@TableName</code>注解来指定表名就有些累赘了，此时我们可以在<code>application.yaml</code>文件中配置<code>mybatis-plus.global-config.db-config.table-prefix</code>属性来指定全局表前缀：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">t_</span> <span class="comment"># 添加前缀后实体类映射表时会默认带上该前缀</span></span><br></pre></td></tr></table></figure>
<h4 id="TableId"><a href="#TableId" class="headerlink" title="@TableId"></a>@TableId</h4><p>我们知道 MyBatis-Plus 提供的诸多 CRUD 方法中有许多都是通过主键操作的，例如<code>selectById </code>、<code>updateById </code>等方法。这就产生一些问题：实体类中哪一个属性是主键？该属性对应的表字段是什么？基于这两个问题我们一一做出解答。</p>
<ol>
<li>默认情况下，<code>selectById </code>、<code>updateById </code>等方法都是操作实体类中名字为<code>id</code>的属性。如果实体类没有<code>id</code>属性当然就会报错。</li>
<li>实体类与表字段对应的时候默认同名对应，当然我们可以开启驼峰映射。</li>
</ol>
<p>如果实体类不想定义名为<code>id</code>的属性该怎么办？答案是使用<code>@TableId</code>注解指定主键。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 将实体类的 uid 属性与表的 id 字段绑定，且将 uid 属性作为主键存在</span></span><br><span class="line">    <span class="meta">@TableId(&quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果表字段也叫<code>uid</code>，那么可以直接使用<code>@TableId</code>注解而不需要指定<code>value</code>属性值。<br>除了可以指定主键之外，<code>@TableId</code>还有一个<code>type </code>属性用来指定主键的生成策略。主要有两种策略：</p>
<ul>
<li><code>IdType.AUTO </code>当主键是数字类型且使用<code>auto_increment</code>修饰时可以指定这种生成策略，即主键<code>+1</code>策略。</li>
<li><code>IdType.ASSIGN_ID </code>默认值，主键类型可以是数字也可以是字符串。这种算法叫雪花算法，算法会生成一个随机<code>long</code>数字并将其作为主键值，生成的值不会重复。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 将User类的 id 生成策略改为自增</span></span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果项目中大部分实体类的主键生成策略都是<code>AUTO</code>，我们就可以在<code>application.yaml</code>里面做全局配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="TableField"><a href="#TableField" class="headerlink" title="@TableField"></a>@TableField</h4><p>我们在开发中定义实体类的时候，可能会遇到两个问题：</p>
<ol>
<li>实体类的属性名与数据库表字段名不一致，例如存储班级时数据库使用<code>class</code>命名，但在 Java 里面这是关键字不能用来定义变量，我们就需要改名字；</li>
<li>实体类有些字段值是根据其它字段计算得来，因此数据库并没有对应的字段；</li>
</ol>
<p>而 MyBatis-Plus 会根据实体类属性名查询字段，因此字段名不对应或数据库不存在该字段的时候会报错。例如实体类有<code>id, name, age</code>属性，那么查询的时候会使用<code>SELECT id, name, age FROM...</code>语句。<br>为了解决这个问题，我们可以使用<code>@TableField</code>注解。这个注解有两个属性：</p>
<ul>
<li><code>value</code>用来指定属性对应的数据库字段名；</li>
<li><code>exist </code>boolean 类型，用来指定该属性是否存在于数据库中；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(&quot;id&quot;)</span>  <span class="comment">// 修改对应字段名</span></span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@TableField(exist = false)</span>  <span class="comment">// 不存在的字段将 exist 设为 false</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h4><p>逻辑删除对应物理删除，物理删除使用<code>DELETE</code>语句将数据真的删除，而逻辑删除则在表中新增一个字段表示数据是否被删除。例如新增一个<code>deleted</code>字段，使用这个字段值表示记录是否删除。<br>MyBatis-Plus 可以很好的支持逻辑删除，实现步骤也很简单：</p>
<ol>
<li>数据库表新增一个表示逻辑删除的字段（如<code>deleted</code>）；</li>
<li>在实体类里面新增一个同名变量（<code>deleted</code>）；</li>
<li>在该字段上使用<code>@TableLogic </code>注解修饰即可；</li>
</ol>
<p>默认情况下，MyBatis-Plus 认为<code>deleted</code>值为<code>1</code>表示该数据已经被删除，否则值为<code>0</code>表示数据没被删。我们可以在注解里面修改：</p>
<ul>
<li><code>value</code>属性表示未删除的数字表示，默认为<code>0</code>；</li>
<li><code>delval</code>属性表示删除的数字表示，默认为<code>1</code>；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableLogic(value = &quot;0&quot;, delval = &quot;1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Integer deleted;</span><br></pre></td></tr></table></figure>
如果所有表都需要实现逻辑删除，每个表都需要使用<code>@TableLogic</code>注解就很麻烦。所以逻辑删除的也可以全局配置，主要配置三个字段：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global-config:</span></span><br><span class="line">  <span class="attr">db-config:</span></span><br><span class="line">    <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 表示删除的值</span></span><br><span class="line">    <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 表示未删除的值</span></span><br><span class="line">    <span class="attr">logic-delete-field:</span> <span class="string">deleted</span> <span class="comment"># 表示删除的字段</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>在高并发的情况下，修改同一条记录可能出现数据不一致的问题。一种解决思路是在数据中添加一个表示版本的字段，每次修改数据的时候对比版本：</p>
<ul>
<li>若版本一致就执行修改，并将版本号<code>+1</code>；</li>
<li>若版本不一致就不做修改；</li>
</ul>
<p>在 MyBatis-Plus 里面实现这种乐观锁很简单：</p>
<ol>
<li>数据库添加一个表示版本的字段<code>version</code>，数字类型；</li>
<li>实体类里面添加一个变量用来存储版本，并使用<code>@Version </code>注解修饰这个变量；</li>
<li>在启动类里添加乐观锁插件<code>OptimisticLockerInnerInterceptor </code>；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实体类里定义表示版本的字段并使用 @Version 修饰</span></span><br><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动类里添加乐观锁插件</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    <span class="comment">// 乐观锁插件</span></span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
测试的代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询同一条记录，获取的版本号是一样的</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> userMapper.selectById(<span class="number">4</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> userMapper.selectById(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个人都想修改数据</span></span><br><span class="line">user1.setAge(<span class="number">30</span>);</span><br><span class="line">user2.setAge(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 版本对比成功，允许修改并将数据库存的版本号 +1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> userMapper.updateById(user1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 版本对比失败，不允许修改</span></span><br><span class="line">rows = userMapper.updateById(user2);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="防御删库跑路"><a href="#防御删库跑路" class="headerlink" title="防御删库跑路"></a>防御删库跑路</h4><p>正常开发中基本不存在删除或修改全表的操作，因为这样的操作很危险。MyBatis-Plus 给我们提供了一个防止全表删除或更新的插件<code>BlockAttackInnerInterceptor</code>，我只需要在启动类里面配置一下就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    <span class="comment">// 防止全表删除、更新的插件</span></span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">BlockAttackInnerInterceptor</span>());</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要引入插件而不需要做其它任何操作就直接可以起作用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/05/SpringBoot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/08/05/SpringBoot/" itemprop="url">SpringBoot</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-08-05T11:47:31+08:00">
                2023-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>正常开发我们使用 SSM 就足够了，但使用 SSM 需要我们自己记住许多包，而且配置也很多。以前倒是没什么，但目前微服务横行，每个服务都是一个项目，每个项目都需要配置一遍实在繁琐。因此 SpringBoot 就出现了，SpringBoot 底层还是 SSM 那一套，只不过很多功能都集成进去就方便许多。</p>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>首先我们将模块继承指定的 SpringBoot 父工程：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接着导 web 包（这个包里面包含了 SpringMVC 的依赖）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为这个包在父工程里面做了声明，所以不需要写版本号。</p>
<h4 id="写-Handler"><a href="#写-Handler" class="headerlink" title="写 Handler"></a>写 Handler</h4><p>我们仍然使用 SpringMVC 那一套书写 Handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello Boy!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="配置启动类"><a href="#配置启动类" class="headerlink" title="配置启动类"></a>配置启动类</h4><p>SpringBoot 的启动类就是一个包含 main 函数的类，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类上需要加 @SpringBootApplication 注解</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用启动方法，第一个参数是当前类</span></span><br><span class="line">        SpringApplication.run(Main.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行这个 main 函数项目就启动起来了，并且会自动开启 Tomcat，十分方便。<br>关于<code>@SpringBootApplication</code>注解有以下功能：</p>
<ol>
<li>它继承于<code>@Configuration</code>注解，因此我们可以在当前类中使用<code>@Bean</code>注解定义外部组件；</li>
<li>它继承于<code>@ComponentScan </code>注解，因此它会扫描启动类当前及其子包下的所有注解；</li>
<li>它继承于<code>@EnableAutoConfiguration </code>注解，因此它会自动加载配置文件；</li>
</ol>
<h3 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a>统一配置管理</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>SpringBoot 尽管尽量减少了配置，但有些配置不能避免或需要自定义。例如数据库连接信息、Tomcat 端口号、项目访问根路径以及一些自定义的配置。在 SpringBoot 中这些配置都会放在一个统一的文件中：<code>resources/application.properties</code>或<code>resources/application.yml</code>。</p>
<h4 id="properties-格式"><a href="#properties-格式" class="headerlink" title="properties 格式"></a>properties 格式</h4><p>我们使用<code>application.properties</code>举例子：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Tomcat 端口号配置</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">80</span></span><br><span class="line"><span class="comment"># 项目访问根路径</span></span><br><span class="line"><span class="attr">server.servlet.context-path</span>=<span class="string">/root</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 自定义的属性</span></span><br><span class="line"><span class="attr">luyan.name</span>=<span class="string">Jack</span></span><br></pre></td></tr></table></figure>
<p>这些属性配置好之后再启动服务即刻生效，对于自定义属性可以直接使用<code>@Value(&quot;$&#123;key&#125;&quot;)</code>获取。</p>
<h4 id="yml-格式"><a href="#yml-格式" class="headerlink" title="yml 格式"></a>yml 格式</h4><p>因为所有配置都要放在配置文件里面，为了避免重复，properties 文件里面使用多层命名，例如<code>server.port</code>等。当命名层次比较深的时候写的很费劲，而且也不便于阅读。因此 yml 就出现了，yml 是一种层次化的配置文件格式，文件后缀是<code>.yml</code>或<code>.yaml</code>，下面是一个例子：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/root</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">luyan:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Jack</span></span><br></pre></td></tr></table></figure>
<p>这边的效果与上面写的 properties 文件是一样的。<br>对于一些简单类型的值（单个值）我们可以直接使用<code>@Value</code>注解注入到一个变量中，但 yml 文件中还可以定义集合数据，集合数据不能使用<code>@Value</code>注解注入，数据如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">luyan:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Jack</span></span><br><span class="line">  <span class="attr">hobbies:</span> <span class="comment"># 下面使用 &quot;- 值&quot; 指定集合的多个值</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">football</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">basketball</span></span><br></pre></td></tr></table></figure>
<p>对于<code>hobbies</code>属性就无法使用<code>@Value</code>注解注入，想要获取集合的值首先为数据创建一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;luyan&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建的实体类需要使用<code>@Component</code>注解修饰，不然 Spring 如何为它注入值呢。<br>其次使用<code>@ConfigurationProperties</code>注解开启配置注入，<code>prefix = &quot;luyan&quot;</code>表示将配置中<code>luyan</code>开头的所有配置注入到实体类的属性中。</p>
<h4 id="多配置文件"><a href="#多配置文件" class="headerlink" title="多配置文件"></a>多配置文件</h4><p>SpringBoot 支持的配置文件后缀是<code>.properties、.yml、.yaml</code>，下面都以<code>.yml</code>举例子。<br>我们已经知道了 SpringBoot 所有配置都在<code>application.yml</code>里面定义，这会产生两个问题：</p>
<ol>
<li>配置太多显得配置文件臃肿凌乱；</li>
<li>需要区分环境的配置每次都要手动修改，麻烦；</li>
</ol>
<p>为了解决这两个问题，SpringBoot 支持定义子配置文件。子配置文件命名规则是<code>application-&#123;key&#125;.yml</code>，这边的<code>&#123;key&#125;</code>可随意替换。</p>
<ol>
<li>对于分环境的场景，我们可以定义两个配置文件<code>application-test.yml</code>与<code>application-dev.yml</code>分别表示测试与开发环境；</li>
<li>对于分文件存储的情况，我们可以定义<code>application-jdbc.yml</code>与<code>application-mybatis.yml</code>分别用来存储数据库与 MyBatis 相关的配置；</li>
</ol>
<p>光是定义这些子配置文件是不会生效的，SpringBoot 仍然只会读取<code>application.yml</code>。想要让子配置文件生效我们需要在<code>application.yml</code>里面配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev,jdbc,mybatis</span></span><br></pre></td></tr></table></figure>
<p><code>spring.profiles.active</code> 用来指定激活的子文件，注意只需要写<code>key</code>的部分，可同时激活多个子文件。如果多个文件里面有值重复，后面的会覆盖前面的。</p>
<h4 id="常用内置配置项"><a href="#常用内置配置项" class="headerlink" title="常用内置配置项"></a>常用内置配置项</h4><ol>
<li><code>server.port </code>用来配置服务器端口号，默认值<code>8080</code>；</li>
<li><code>server.servlet.context-path </code>用来配置项目的访问根目录，默认值<code>/</code>；</li>
<li><code>server.servlet.encoding.charset </code>用来配置请求与响应时的字符编码，默认值<code>UTF-8</code>；</li>
<li><code>server.servlet.encoding.enabled </code>用来配置是否开启字符编码设置，默认值<code>true</code>；</li>
<li><code>spring.mvc.view.prefix </code>用来配置视图解析器的前缀，默认值空串；</li>
<li><code>spring.mvc.view.suffix </code>用来配置视图解析器的后缀，默认值空串；</li>
<li><code>spring.web.resources.static-locations </code>用来配置静态资源地址，默认值如下：<ol>
<li><code>classpath:/META-INF/resources/</code></li>
<li><code>classpath:/resources/</code></li>
<li><code>classpath:/static/</code></li>
<li><code>classpath:/public/</code></li>
</ol>
</li>
</ol>
<p>上面的配置前几个比较简单，最后一个静态资源路径需要说一下。静态资源目录就是存储图片、CSS、JS等文件的目录。默认有 4 个，上面的目录都是位于<code>resources</code>目录下。<br>例如我们有<code>resources/static/a.jpg</code>文件，在所有配置都默认的情况下，访问的路径是<code>localhost:8080/a.jpg</code>，也就是说文件前面的静态资源目录是不需要加的。</p>
<h4 id="拦截器配置"><a href="#拦截器配置" class="headerlink" title="拦截器配置"></a>拦截器配置</h4><p>在 SpringMVC 里面拦截器是经常需要用到的功能，那在 SpringBoot 里面该如何配置拦截器？<br>答：与以前一样，只需要创建一个配置文件，实现<code>WebMvcConfigurer</code>接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 为所有请求注册拦截器（静态资源不拦截）</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">MyInterceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上到此就结束了，不需要做额外的配置。总结下来就两步：</p>
<ol>
<li>创建自定义拦截器；</li>
<li>在配置类中添加拦截器；</li>
</ol>
<p>还是那句话，SpringBoot 会自动扫描启动类所在包及其子包下的所有注解，因此这个配置类也会被扫描到，于是配置类里面添加的拦截器也会自动生效。</p>
<h3 id="整合-Druid-连接池"><a href="#整合-Druid-连接池" class="headerlink" title="整合 Druid 连接池"></a>整合 Druid 连接池</h3><h4 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 继承父类的版本 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- JdbcTemplate、事务等 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- druid 连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- mysql 连接器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>连接池基本信息的配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span>  <span class="comment"># 使用 druid 连接池</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">mysql2425@</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/demo</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 直接自动装配</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">all</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from users;&quot;</span>;</span><br><span class="line">        List&lt;User&gt; users = jdbcTemplate.query(sql, </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class));</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整合-MyBatis"><a href="#整合-MyBatis" class="headerlink" title="整合 MyBatis"></a>整合 MyBatis</h3><h4 id="导包-1"><a href="#导包-1" class="headerlink" title="导包"></a>导包</h4><p>需要新导入的是 MyBatis 包，其它诸如 Druid 连接池、mysql 连接器等都在上一节导过了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mappers/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.luyan.pojo</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">auto-mapping-behavior:</span> <span class="string">full</span></span><br></pre></td></tr></table></figure>
<p>着重需要配置的有如下内容：</p>
<ul>
<li><code>mybatis.mapper-locations</code>配置 mapper 文件路径；<ul>
<li>默认值是<code>classpath*:/mapper/**/*.xml</code>，也就是<code>resources/mapper/</code>目录下面的所有 xml 文件都可以读取；</li>
</ul>
</li>
<li><code>mybatis.type-aliases-package</code>配置别名包；</li>
<li><code>mybatis.configuration.map-underscore-to-camel-case</code>配置驼峰映射；<ul>
<li>默认值是<code>true</code>；</li>
</ul>
</li>
<li><code>mybatis.configuration.auto-mapping-behavior</code>配置自动映射；<ul>
<li>默认值是<code>AutoMappingBehavior.PARTIAL</code>；</li>
</ul>
</li>
</ul>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ol>
<li><p>正常创建 mapper 接口与 mapper 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">queryAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from users</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在启动类上添加<code>@MapperScan</code>注解用来配置 mapper 接口位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.luyan.mappers&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Main.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">all</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.queryAll();</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="整合-tx-与-aop"><a href="#整合-tx-与-aop" class="headerlink" title="整合 tx 与 aop"></a>整合 tx 与 aop</h3><h4 id="tx"><a href="#tx" class="headerlink" title="tx"></a>tx</h4><p>事务所需的包仍然是包含在<code>spring-boot-starter-jdbc </code>里面，上面已经说过。<br>与之前在 Spring 里面使用事务不同，SpringBoot 不需要往容器中手动添加事务管理器，直接使用事务相关注解即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>  <span class="comment">// 直接使用事务注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteById</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> userMapper.delete(<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它使用都是一样，总结下来在 SpringBoot 中使用事务非常简单：1、导包；2、使用。</p>
<h4 id="aop"><a href="#aop" class="headerlink" title="aop"></a>aop</h4><p>在 SpringBoot 里面开启 AOP 非常简单，只需要导包写切面即可。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>切面代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com..service.*.*())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打包运行"><a href="#打包运行" class="headerlink" title="打包运行"></a>打包运行</h3><p>传统 JavaWeb 项目打包成 war 包，然后放到<code>tomcat &gt; webapps</code>目录下。但 Springboot 项目自带 tomcat，因此打包出来是一个 jar 包。</p>
<h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><h5 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这边的<code>build</code>标签与<code>dependencies </code>标签同级。</p>
<h5 id="package"><a href="#package" class="headerlink" title="package"></a>package</h5><p><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1714902998448-38cf3b10-999d-421e-ad13-045f531ba8b0.png#averageHue=%23f7f7f7&clientId=u1e1ecd21-3dd8-4&from=paste&height=222&id=IjjLn&originHeight=444&originWidth=452&originalType=binary&ratio=2&rotation=0&showTitle=false&size=39367&status=done&style=none&taskId=u69553af8-d2ab-4163-9795-78b1efdc406&title=&width=226" alt="image.png"><br>如右图，打开 IDEA 的 Maven 面板并双击生命周期里的<code>package</code>即可。</p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>将 jar 包复制到合适的地方，并在控制台使用指令运行：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar fileName.jar</span><br></pre></td></tr></table></figure>
<p>我们使用控制台命令执行 jar 包的时候还可以指定参数，这些参数就是在<code>application.yml</code>里面定义的系统参数，例如端口号、激活的配置文件等。注意在命令中添加参数会覆盖配置文件里面的参数，也就是说以命令里面的参数为准。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar -Dserver.port=8888 -Dspring.profiles.active=dev,test fileName.jar</span><br></pre></td></tr></table></figure>
<p>可以看到定义参数主要使用<code>-D</code>指定。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/30/SSM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/07/30/SSM/" itemprop="url">SSM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-07-30T11:47:22+08:00">
                2023-07-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>什么是 SSM 整合？下面将从微观和宏观两个角度进行理解。<br>从微观上讲就是将学习的 Spring、SpringMVC、Mybatis 框架应用到项目中：</p>
<ul>
<li>SpringMVC 框架负责控制层；</li>
<li>Spring 框架负责整体和业务层的声明式事务管理；</li>
<li>MyBatis 框架负责数据库访问层；</li>
</ul>
<p>从宏观上讲就是 Spring 接管一切（将框架核心组件交给 Spring 容器进行管理），代码更加简洁：</p>
<ul>
<li>SpringMVC 管理表述层、SpringMVC 相关组件；</li>
<li>Spring 管理业务层、持久层、以及数据库相关（DataSource，MyBatis）的组件；</li>
<li>使用 loC 的方式管理一切所需组件；</li>
</ul>
<h3 id="整合-4-问"><a href="#整合-4-问" class="headerlink" title="整合 4 问"></a>整合 4 问</h3><h4 id="SSM-整合需要几个容器"><a href="#SSM-整合需要几个容器" class="headerlink" title="SSM 整合需要几个容器"></a>SSM 整合需要几个容器</h4><p>答：<strong>两个</strong>。本质上说，整合就是将三层架构和框架核心 API 组件交给 SpringloC 容器管理。一个容器可能就够了，但是我们常见的操作是创建两个 loC 容器（web 容器和 root 容器），组件分类管理有以下好处和目的：</p>
<ol>
<li>分离关注点：通过初始化两个容器，可以将各个层次的关注点进行分离。这种分离使得各个层次的组件能够更好地聚焦于各自的责任和功能；</li>
<li>解耦合：各个层次组件分离装配不同的 loC 容器，这样可以进行解耦。这种解耦合使得各个模块可以独立操作和测试，提高了代码的可维护性和可测试性；</li>
<li>灵活配置：通过使用两个容器，可以为每个容器提供各自的配置，以满足不同层次和组件的特定需求。每个配文件也更加清晰和灵活；</li>
</ol>
<p>总的来说，初始化两个容器在 SSM 整合中可以实现关注点分离、解耦合、灵活配置等好处。它们各自负责不同的层次和功能，并通过合适的集成方式协同工作，提供一个高效、可维护和可扩展的应用程序架构。</p>
<h4 id="各容器装哪些组件"><a href="#各容器装哪些组件" class="headerlink" title="各容器装哪些组件"></a>各容器装哪些组件</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1713343982589-80497dfe-7d47-41d3-9b3a-29435ad79f5a.png#averageHue=%23f4ece8&clientId=u373edd81-a831-4&from=paste&height=609&id=uf4951c12&originHeight=619&originWidth=1026&originalType=binary&ratio=1&rotation=0&showTitle=false&size=221405&status=done&style=none&taskId=ua105574a-8e26-4f2f-9d81-cb77fdf71a1&title=&width=1009" alt="image.png"><br>两个容器具体装哪些组件可以总结如下表：</p>
<table>
<thead>
<tr>
<th><strong>容器</strong></th>
<th><strong>盛放组件</strong></th>
</tr>
</thead>
<tbody><tr>
<td>web 容器</td>
<td>controller 层相关组件（SpringMVC 相关组件）</td>
</tr>
<tr>
<td>root 容器</td>
<td>业务和持久层相关组件（aop、tx、mybatis 等组件）</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：web 容器是 root 容器的子容器。之所以这样设计是因为我们在 controller 层经常会需要拿到 service 层的对象，因此将它们设计为父子关系，这样子容器就可以获取到父容器里的组件。而父容器是拿不到子容器里面的组件的，不过这也没有关系，因为后面的层一般也不需要 controller 层的对象。</p>
<h4 id="Spring-配置类需要多少个"><a href="#Spring-配置类需要多少个" class="headerlink" title="Spring 配置类需要多少个"></a>Spring 配置类需要多少个</h4><p>答：一般推荐写 3 个配置类，即每一层都写一个配置类。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1713345106561-94374a65-248b-47d5-be0f-158e0ae82861.png#averageHue=%23f8f2ee&clientId=u373edd81-a831-4&from=paste&height=765&id=u90664ffb&originHeight=765&originWidth=1057&originalType=binary&ratio=1&rotation=0&showTitle=false&size=286317&status=done&style=none&taskId=u474d5330-c063-45d4-a440-e3cb3589882&title=&width=1057" alt="image.png"><br>配置类与容器的关系总结下表：</p>
<table>
<thead>
<tr>
<th><strong>配置类</strong></th>
<th><strong>对应内容</strong></th>
<th><strong>对应容器</strong></th>
</tr>
</thead>
<tbody><tr>
<td>WebJavaConfig</td>
<td>controller 层：springmvc 相关</td>
<td>web 容器</td>
</tr>
<tr>
<td>ServiceJavaConfig</td>
<td>service 层：业务逻辑、aop、tx 相关</td>
<td>root 容器</td>
</tr>
<tr>
<td>MapperJavaConfig</td>
<td>mapper 层：datasource、mybatis 相关</td>
<td>root 容器</td>
</tr>
</tbody></table>
<h4 id="如何指定各配置类"><a href="#如何指定各配置类" class="headerlink" title="如何指定各配置类"></a>如何指定各配置类</h4><p>我们只需要在 SpringMVC 初始化类对应位置进行设置即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpringMVC 初始化类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcInitializer</span> </span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="comment">// 在这指定 root 容器配置类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这指定 web 容器配置类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123; SpringMvcConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在上述对应位置指定配置类之后，SpringMVC 会帮我们创建容器并设置父子关系。</p>
<h3 id="整合-SpringMVC"><a href="#整合-SpringMVC" class="headerlink" title="整合 SpringMVC"></a>整合 SpringMVC</h3><p>整合 SpringMVC 的项目需要是 web 项目，因此模块创建好之后右键点击<code>JBLJavaToWeb</code>。</p>
<h4 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h4><h5 id="必须包"><a href="#必须包" class="headerlink" title="必须包"></a>必须包</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- SpringMVC --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- SpringMVC 核心 Servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="选配包"><a href="#选配包" class="headerlink" title="选配包"></a>选配包</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JSON 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.17.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 参数校验 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- jsp --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet.jsp.jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet.jsp.jstl-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><p>接下来我们创建 SpringMVC 对应的配置类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">// 配置 json、HandlerMapping、HandlerAdapter</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.luyan.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 添加视图前后缀</span></span><br><span class="line">        registry.jsp(<span class="string">&quot;/WEB-INFO/views/&quot;</span>, <span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(</span></span><br><span class="line"><span class="params">            DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置静态资源</span></span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置拦截器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><h5 id="初始化类"><a href="#初始化类" class="headerlink" title="初始化类"></a>初始化类</h5><p>创建类继承<code>AbstractAnnotationConfigDispatcherServletInitializer</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectInit</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// SpringMVC 配置类放在这</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h5><p>创建一个 Handler 测试功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整合-aop-与-tx"><a href="#整合-aop-与-tx" class="headerlink" title="整合 aop 与 tx"></a>整合 aop 与 tx</h3><h4 id="导包-1"><a href="#导包-1" class="headerlink" title="导包"></a>导包</h4><h5 id="必选包"><a href="#必选包" class="headerlink" title="必选包"></a>必选包</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- aop --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 事务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="选配包-1"><a href="#选配包-1" class="headerlink" title="选配包"></a>选配包</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- @Resource 注解需要 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 测试整合包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- junit --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="配置类-1"><a href="#配置类-1" class="headerlink" title="配置类"></a>配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>  <span class="comment">// 允许自动代理</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span>  <span class="comment">// 允许事务管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceJavaConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">manager</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        manager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring 事务需要我们配置一个事务管理器到容器中，事务管理器需要的连接池通过参数注入获得。因为连接池我们会在后面配置，因此目前会注入失败。</p>
<h3 id="整合-MyBatis"><a href="#整合-MyBatis" class="headerlink" title="整合 MyBatis"></a>整合 MyBatis</h3><h4 id="导包-2"><a href="#导包-2" class="headerlink" title="导包"></a>导包</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- druid 连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- MyBatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 整合包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="整合方式一"><a href="#整合方式一" class="headerlink" title="整合方式一"></a>整合方式一</h4><p>使用方面，接口与 mapper 文件正常创建使用即可。</p>
<h5 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h5><p>mybatis 核心配置文件也一样创建，但是里面不需要配置<code>environments </code>与<code>mappers </code>标签，其它诸如起别名、驼峰映射等功能还是在核心配置文件里面写：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.luyan.domain&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="配置类（错误）"><a href="#配置类（错误）" class="headerlink" title="配置类（错误）"></a>配置类（错误）</h5><p>接下来我们主要需要将用到的对象配到容器之中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;url&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;driver&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;username&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;password&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 不使用 mybatis 自带的连接池，使用 druid 连接池</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 配置 SqlSessionFactory，使用的是标准工厂</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> </span><br><span class="line">            <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        <span class="comment">// 注入连接池</span></span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">// 设置核心配置文件路径</span></span><br><span class="line">        <span class="type">ClassPathResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        sqlSessionFactoryBean.setConfigLocation(resource);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 配置所有的 mapper 接口</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">mapperScannerConfigurer</span> </span><br><span class="line">            <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        <span class="comment">// 设置基路径</span></span><br><span class="line">        mapperScannerConfigurer.setBasePackage(<span class="string">&quot;com.luyan.mappers&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mapperScannerConfigurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这种方式配置 mapper，接口与映射文件的目录结构应该是一致的。即若接口放到<code>java/com/luyan/mappers</code>目录下，则映射文件放到<code>resources/com/luyan/mappers</code>下。</p>
<h5 id="配置类（正确）"><a href="#配置类（正确）" class="headerlink" title="配置类（正确）"></a>配置类（正确）</h5><p>上述写法实际上有一个 bug：mybatis 对象会优先于<code>@Value</code>注解配置，因此会出现连接池配置失败的情况。解决方案就是将连接池的配置放到一个新的配置文件中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="type">ClassPathResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        sqlSessionFactoryBean.setConfigLocation(resource);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">mapperScannerConfigurer</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        mapperScannerConfigurer.setBasePackage(<span class="string">&quot;com.luyan.mapper&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mapperScannerConfigurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="整合方式二"><a href="#整合方式二" class="headerlink" title="整合方式二"></a>整合方式二</h4><p>方式二相较于方式一就是完全不需要核心配置文件<code>mybatis-config.xml</code>，所有的配置都直接写在代码里面，我们只需要修改创建<code>SqlSessionFactoryBean</code>的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">    <span class="type">SqlSessionFactoryBean</span> <span class="variable">factoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">    factoryBean.setDataSource(dataSource);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置 settings 标签内的内容</span></span><br><span class="line">    org.apache.ibatis.session.<span class="type">Configuration</span> <span class="variable">configuration</span></span><br><span class="line">            <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">org</span>.apache.ibatis.session.Configuration();</span><br><span class="line">    configuration.setMapUnderscoreToCamelCase(<span class="literal">true</span>);</span><br><span class="line">    configuration.setAutoMappingBehavior(AutoMappingBehavior.FULL);</span><br><span class="line">    factoryBean.setConfiguration(configuration);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置别名</span></span><br><span class="line">    factoryBean.setTypeAliasesPackage(<span class="string">&quot;com.luyan.domain&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置插件</span></span><br><span class="line">    <span class="type">PageInterceptor</span> <span class="variable">pageInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageInterceptor</span>();</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    properties.setProperty(<span class="string">&quot;helperDialect&quot;</span>, <span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">    pageInterceptor.setProperties(properties);</span><br><span class="line">    factoryBean.addPlugins(pageInterceptor);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> factoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与上面代码相对应的核心配置文件如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;FULL&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.luyan.domain&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;helperDialect&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用这种方式就完全不需要配置文件了，我们推荐使用这种方式配置。</p>
<h3 id="开发建议"><a href="#开发建议" class="headerlink" title="开发建议"></a>开发建议</h3><h4 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h4><p>现在都是前后端分离开发，前端项目直接访问我们的后端是会被拦截的。此时需要我们在 Controller 上配置<code>@CrossOrigin </code>注解来解除跨域请求问题。</p>
<h4 id="统一返回"><a href="#统一返回" class="headerlink" title="统一返回"></a>统一返回</h4><p>实际开发中返回的数据可能多种多样，但我们一般会对数据做一层封装达到统一返回格式的目的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;  <span class="comment">// 存储响应数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Result</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">build</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        Result&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;();</span><br><span class="line">        result.setData(data);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">build</span><span class="params">(T data, Integer code, String message)</span> &#123;</span><br><span class="line">        Result&lt;T&gt; result = build(data);</span><br><span class="line">        result.setCode(code);</span><br><span class="line">        result.setMessage(message);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">build</span><span class="params">(T data, ResultCodeEnum resultCodeEnum)</span> &#123;</span><br><span class="line">        Result&lt;T&gt; result = build(data);</span><br><span class="line">        result.setCode(resultCodeEnum.getCode());</span><br><span class="line">        result.setMessage(resultCodeEnum.getMessage());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">ok</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(data, ResultCodeEnum.SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与之配合的枚举类<code>ResultCodeEnum</code>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ResultCodeEnum</span> &#123;</span><br><span class="line">    SUCCESS(<span class="number">200</span>, <span class="string">&quot;success&quot;</span>),</span><br><span class="line">    ACCOUNT_ERROR(<span class="number">501</span>, <span class="string">&quot;account validate error&quot;</span>),</span><br><span class="line">    NO_LOGIN(<span class="number">503</span>, <span class="string">&quot;noLogin&quot;</span>),</span><br><span class="line">    USERNAME_USED(<span class="number">504</span>, <span class="string">&quot;username used&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的代码也非常简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果请求成功，直接调用</span></span><br><span class="line"><span class="keyword">return</span> Result.ok(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果请求失败，则选择对应的理由，如登录校验失败</span></span><br><span class="line"><span class="keyword">return</span> Result.build(data, ResultCodeEnum.NO_LOGIN);</span><br></pre></td></tr></table></figure>
<h4 id="JWT-Token"><a href="#JWT-Token" class="headerlink" title="JWT &amp; Token"></a>JWT &amp; Token</h4><h5 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h5><p>令牌（Token）：在计算机领域，令牌是一种代表某种访问权限或身份认证信息的令牌。它可以是一串随机生成的字符或数字，用于验证用户的身份或授权用户对特定资源的访问。</p>
<h5 id="JWT-工作流程"><a href="#JWT-工作流程" class="headerlink" title="JWT 工作流程"></a>JWT 工作流程</h5><p>JWT（JSON Web Token）是具体可以生成、校验、解析 Token 的技术，其工作流程如下：</p>
<ul>
<li>用户提供其凭据（通常是用户名和密码）进行身份验证；</li>
<li>服务器对这些凭据进行验证，并在验证成功后创建一个 JWT；</li>
<li>服务器将 JWT 发送给客户端，客户端在后续的请求中将 JWT 附加在请求头或参数中；</li>
<li>服务器接收到请求后，验证 JWT 的签名和有效性，并根据 JWT 中的声明进行身份验证和授权操作；</li>
</ul>
<h5 id="JWT-数据组成"><a href="#JWT-数据组成" class="headerlink" title="JWT 数据组成"></a>JWT 数据组成</h5><p>JWT 由<code>头部、载荷、签名</code>三部分组成，中间使用<code>.</code>连接，即<code>header.payload.signature</code>。<br>JWT 可以携带很多信息，一般情况下需要携带：</p>
<ul>
<li>有效时间：保证 Token 的时效性；</li>
<li>签名密钥：防止 Token 被他人解析、修改；</li>
<li>用户信息：方便我们知道是哪一个用户访问；</li>
</ul>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><h6 id="导包-3"><a href="#导包-3" class="headerlink" title="导包"></a>导包</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.12.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h6><p>在<code>application.yaml</code>中配置相关参数：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jwt:</span></span><br><span class="line">  <span class="attr">token:</span></span><br><span class="line">    <span class="attr">signature:</span> <span class="string">bHV5YW4gMTk5OC4xMi4wOQpMTyAwMy4wOCBWRQpsaXVtaWFveGlhIDE5OTguMDUuMjE=</span></span><br><span class="line">    <span class="attr">expiration:</span> <span class="number">120</span> <span class="comment"># token 有效时长，单位分钟</span></span><br></pre></td></tr></table></figure>
<p><code>signature</code>是加密签名，长度不得小于 512 字节。</p>
<h6 id="封装工具类"><a href="#封装工具类" class="headerlink" title="封装工具类"></a>封装工具类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;jwt.token&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtHelper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String signature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> expiration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SecretKey <span class="title function_">getSecretKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] keyBytes = signature.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">return</span> Keys.hmacShaKeyFor(keyBytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户 id 创建 Token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createToken</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .subject(<span class="string">&quot;LMX-SECOND-HAND-USER&quot;</span>)</span><br><span class="line">                .expiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + expiration * <span class="number">60</span> * <span class="number">1000</span>))</span><br><span class="line">                .claim(<span class="string">&quot;userId&quot;</span>, userId)</span><br><span class="line">                .signWith(getSecretKey(), Jwts.SIG.HS512)</span><br><span class="line">                .compressWith(Jwts.ZIP.GZIP)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从 Token 里获取用户 id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getUserId</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(token)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">                .verifyWith(getSecretKey())</span><br><span class="line">                .build()</span><br><span class="line">                .parseSignedClaims(token)</span><br><span class="line">                .getPayload();</span><br><span class="line">        <span class="keyword">return</span> claims.get(<span class="string">&quot;userId&quot;</span>, Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验 Token 是否过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isExpiration</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(token)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">                .verifyWith(getSecretKey())</span><br><span class="line">                .build()</span><br><span class="line">                .parseSignedClaims(token)</span><br><span class="line">                .getPayload();</span><br><span class="line">        <span class="keyword">return</span> claims.getExpiration().before(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> jwtHelper.createToken(<span class="number">99L</span>);</span><br><span class="line">System.out.println(token);</span><br><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> jwtHelper.getUserId(token);</span><br><span class="line">System.out.println(userId);</span><br><span class="line">System.out.println(jwtHelper.isExpiration(token));</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/22/SpringMVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/07/22/SpringMVC/" itemprop="url">SpringMVC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-07-22T11:47:16+08:00">
                2023-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Spring MVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架，本质上相当于 Servlet。Spring MVC 是结构最清晰的 Servlet+JSP+JavaBean 的实现，是一个典型的教科书式的 MVC 构架，不像 Struts 等其它框架都是变种或者不是完全基于 MVC 系统的框架。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><h4 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h4><p>我们首先使用一个例子进行引入，我们下面将对比原始 Servlet 与 SpringMVC。</p>
<ul>
<li>直接使用 Servlet 处理请求很麻烦，我们不仅需要写逻辑代码，还需要关注请求参数的获取、Response 封装等内容。</li>
<li>使用 SpringMVC 之后，我们只需要关注业务逻辑，其它事情 SpringMVC 帮我们做。</li>
</ul>
<p>同样是登录功能，在 SpringMVC 里面只需要写一个登录方法，需要的参数通过形参定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这类方法在 SpringMVC 里面被称为 Handler，Handler 所需的参数由 SpringMVC 负责从 Request 里面解析出来；如果有返回值我们也只需要返回数据本身，由 SpringMVC 负责将数据封装成 Response 再给到用户。因此我们只需要关注业务逻辑本身，而不需要关注其它一些繁琐的事情。</p>
<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p>首先我们介绍一下 SpringMVC 里面的几个核心对象：</p>
<ul>
<li><code>DispatcherServlet</code>是 SpringMVC 的核心 Servlet 对象，它统领全局；</li>
<li><code>HandlerMapping</code>负责维护请求路径与 Handler 之间的映射；</li>
<li><code>HandlerAdapter</code>负责解析 Request 与封装 Response，是框架与 Handler 之间的桥梁；</li>
</ul>
<p>SpringMVC 执行的流程图如下：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1712631137771-780d20cb-dc65-48bc-ae32-dc81b3ca2107.png#averageHue=%23f6f2ee&clientId=u0892c2fe-428c-4&from=paste&height=751&id=ue5617df0&originHeight=751&originWidth=1264&originalType=binary&ratio=1&rotation=0&showTitle=false&size=70930&status=done&style=none&taskId=ucca5fba4-92f2-4cf9-97b6-fda030fba91&title=&width=1264" alt="image.png"><br>下面使用文字简要描述一下流程，我们对照图的流程编号进行讲解：</p>
<ul>
<li>流程<code>1</code>：用户发起请求；</li>
<li>流程<code>2、3</code>：DispatcherServlet 向 HandlerMapping 查询请求路径对应的 Handler；</li>
<li>流程<code>4</code>：DispatcherServlet 将 Handler 告知 HandlerAdapter，由 HandlerAdapter 解析 Request 并调用 Handler；</li>
<li>流程<code>5、6</code>：Handler 处理请求并将结果返回 HandlerAdapter；</li>
<li>流程<code>7</code>：HandlerAdapter 封装处理结果并返回给 DispatcherServlet；</li>
<li>流程<code>8、9、10</code>：可选流程，需要渲染界面的时候走这一步；</li>
<li>流程<code>11</code>：返回最终的响应给用户；</li>
</ul>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>首先我们需要创建一个项目，注意这次创建的项目得是 web 项目。因此创建完项目之后，我们根据之前的方法右键项目点击<code>JBLJavaToWeb</code>。</p>
<h4 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h4><p>我们主要需要导以下三个包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 6.0 之前的 Spring 配合这个包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 6.0 之后的 Spring 配合这个包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="创建-Handler"><a href="#创建-Handler" class="headerlink" title="创建 Handler"></a>创建 Handler</h4><p>SpringMVC 里面处理请求的方法称为 Handler，我们创建如下类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.luyan.controller;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>  <span class="comment">// 需要将对象交给 Ioc 容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;springmvc/hello&quot;)</span>  <span class="comment">// 将 Handler 与请求路径绑定</span></span><br><span class="line">    <span class="meta">@ResponseBody</span>  <span class="comment">// 这个注解表示将这个方法的返回值直接当做响应体，不做视图解析</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建配置类"><a href="#创建配置类" class="headerlink" title="创建配置类"></a>创建配置类</h4><p>我们知道 SpringMVC 要想工作光有 Handler 不够，还需要<code>HandlerMapping</code>与<code>HandlerAdapter</code>对象。因此我们需要将这两个对象配到配置类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.luyan.controller&quot;)</span>  <span class="comment">// 扫描 Handler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RequestMappingHandlerMapping <span class="title function_">handlerMapping</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerMapping</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RequestMappingHandlerAdapter <span class="title function_">handlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerAdapter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化-运行"><a href="#初始化-运行" class="headerlink" title="初始化 &amp; 运行"></a>初始化 &amp; 运行</h4><p>现在定义好了配置类，但容器怎么创建、谁来创建？<br>答：这些事情交给 SpringMVC 即可，我们只需要定义类继承<code>AbstractAnnotationConfigDispatcherServletInitializer </code>并实现抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcInitializer</span> </span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加在配置类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123; SpringMvcConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示使用 SpringMVC 处理所有以“/”开头的路径，即所有请求都需要处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义好之后创建 Tomcat 容器运行即可。</p>
<h3 id="路径设置"><a href="#路径设置" class="headerlink" title="路径设置"></a>路径设置</h3><p>我们在上一节已经使用<code>@RequestMapping</code>注解对请求路径与 Handler 进行绑定，这一节详细看看。</p>
<h4 id="精准路径"><a href="#精准路径" class="headerlink" title="精准路径"></a>精准路径</h4><p>我们可以在方法上使用<code>@RequestMapping(路径)</code>注解将此方法与指定的路径绑定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外还可以传递多个路径进去表示将这个方法与多个路径绑定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&#123;&quot;/user/login&quot;, &quot;/user/login2&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模糊路径"><a href="#模糊路径" class="headerlink" title="模糊路径"></a>模糊路径</h4><p>除了精确匹配，还可以使用模糊路径匹配。具体来说就是<code>*</code>可以匹配一层任意字符串，<code>**</code>可以匹配任意层任意字符串。例如，<code>/user/*</code>可以匹配<code>/user/、/user/a</code>但不能匹配<code>/user、/user/a/b</code>；而<code>/user/**</code>可以匹配<code>/user</code>及其所有以其开头的路径。注意，<code>/user</code>与<code>/user/</code>是不一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/**&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中两个路径是有重合的，产生冲突的时候会优先选择范围更小的方法匹配。</p>
<h4 id="类注解"><a href="#类注解" class="headerlink" title="类注解"></a>类注解</h4><p><code>@RequestMapping</code>注解除了可以放在方法上，还可以放在类上。放在类上表示匹配的基路径，实际匹配的路径是<code>类上路径 + 方法上路径</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span>  <span class="comment">// 这边指定的是下面方法的基路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相当于 /user/login</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RequestMapping 后面可以省略路径，此时相当于 /user/</span></span><br><span class="line">    <span class="meta">@RequestMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相当于 /user/*</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;*&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login3&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相当于 /user/**</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;**&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login4&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指定请求方式"><a href="#指定请求方式" class="headerlink" title="指定请求方式"></a>指定请求方式</h4><p>我们知道请求方式分很多种，例如<code>GET、POST、PUT、DELETE</code>等。默认情况下，使用<code>@RequestMapping</code>注解可以使用任何方法访问。如果我们想要限制访问方式，可以使用<code>method </code>参数指定，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只允许 GET 方式访问</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;login&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;login1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只允许 GET 与 POST 方式访问</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;login&quot;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;login2&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>method</code>参数既可以传递一种方式，也可以传递多种访问方式。如果使用错误的访问方式，会返回<code>405</code>报错。</p>
<h4 id="其它注解"><a href="#其它注解" class="headerlink" title="其它注解"></a>其它注解</h4><p>除了可以使用<code>method</code>参数指定访问方式，每种访问方式还有专门的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET 方式访问 /login</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;login1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST 方式访问 /login</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;login2&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同一个请求路径只能绑定一个方法，绑定多个会报错。注意，同一个请求路径但访问方式不同我们认为这是两种路径。</p>
<h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><p>我们在做业务逻辑的时候往往需要获取一些数据才行，比如获取请求参数、Request 对象、Session 对象等。本节主要讨论这些对象的获取。</p>
<h4 id="param-参数获取"><a href="#param-参数获取" class="headerlink" title="param 参数获取"></a>param 参数获取</h4><p>param 参数通过网址进行携带，一些比较简短的信息会通过这种方式传递，例如<code>/data?a=OK&amp;b=1</code>；</p>
<h5 id="直接接收"><a href="#直接接收" class="headerlink" title="直接接收"></a>直接接收</h5><p>我们在定义 Handler 方法的时候只需要在形参列表里面定义与传递参数同名的形参即可拿到数据，假设我们将通过网址传递名为<code>name</code>与<code>age</code>的参数，可以使用下面的方式接收：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/data&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">// 接收传过来的 name 与 age 参数</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">data</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    System.out.println(name + age);</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;name: %s, age: %d&quot;</span>, name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这种接收方式有以下注意点：</p>
<ul>
<li>我们定义的形参名必须与传递的参数同名，否则接收不到；</li>
<li>通过 param 方式传递的参数都会被当做字符串，<code>HandlerAdapter</code>会根据我们定义的形参类型进行强转，如果强转失败会报错；</li>
<li>如果定义的形参没有对应的参数与之匹配，那么会赋默认值<code>null</code>，此时如果我们定义的形参类型是非包装类型（如<code>int、double</code>等）会报错，因为无法将<code>null</code>强转成非包装类型；</li>
</ul>
<h5 id="注解指定"><a href="#注解指定" class="headerlink" title="注解指定"></a>注解指定</h5><p>除了直接接收参数，SpringMVC 还支持我们对参数做一些限制。例如我们可以设置某参数是否必须、参数与形参名不同但需要对应、参数不存在给形参一个指定默认值等。<br>我们可以使用<code>@RequestParam </code>注解来实现上述功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/data&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">data</span><span class="params">(<span class="meta">@RequestParam</span> String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    System.out.println(name + age);</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;name: %s, age: %d&quot;</span>, name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边我们在形参<code>name</code>之前使用<code>@RequestParam</code>注解修饰，使用这个注解修饰的形参都是必须的参数，如果不传会报<code>400</code>错误。<br>除此之外，我们还可以给<code>@RequestParam</code>注解的<code>value</code>或<code>name</code>属性赋值来指定当前形参与哪一个参数对应：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/data&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">data</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    System.out.println(name + age);</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;name: %s, age: %d&quot;</span>, name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边我们将形参<code>name</code>与参数<code>username</code>对应，并且因为使用了<code>@RequestParam</code>注解修饰，所以参数<code>username</code>是必须的。<br>再有我们还可以通过<code>@RequestParam</code>注解给某形参设置一个默认值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/data&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">data</span><span class="params">(String name, </span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(required = false, defaultValue = &quot;-1&quot;)</span> <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    System.out.println(name + age);</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;name: %s, age: %d&quot;</span>, name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们将<code>@RequestParam</code>注解的<code>required</code>属性设置为<code>false</code>表示这个参数不是必须的，其次我们再通过<code>defaultValue</code>属性指定这个参数的默认值。需要注意的是，不管默认值是什么类型，我们给<code>defaultValue</code>属性赋值的时候只能赋字符串。</p>
<h5 id="多对一接收"><a href="#多对一接收" class="headerlink" title="多对一接收"></a>多对一接收</h5><p>所谓多对一接收，就是类似于<code>/data?hbs=a&amp;hbs=b</code>这种形式。这边参数<code>hbs</code>出现多次，我们想要将多个值放到一个列表之中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/data&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">data</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; hbs)</span> &#123;</span><br><span class="line">    System.out.println(hbs);</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;%s&quot;</span>, hbs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义形参的时候直接定义<code>List</code>类型就可以了，但是这种情况下必须使用<code>@RequestParam</code>注解修饰，否则会报错。</p>
<h5 id="实体类接收"><a href="#实体类接收" class="headerlink" title="实体类接收"></a>实体类接收</h5><p>很多时候我们需要将参数封装成一个实体类，例如我们想将数据封装成<code>User</code>对象可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/data&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">data</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;%s&quot;</span>, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，直接在形参列表里面定义<code>User</code>类型参数即可。框架会帮我们将数据通过<code>setter</code>注入到实体类之中，但这有几个注意点：</p>
<ul>
<li>实体类的属性名需要与参数名一致，否则无法知道将参数注入到哪一个属性之中；</li>
<li>不能使用<code>@RequestParam</code>注解修饰实体类参数，一旦修饰了就会认为形参<code>user</code>需要通过参数传递，但实际我们只会传递用户名、密码之类的信息；</li>
</ul>
<h5 id="动态路径"><a href="#动态路径" class="headerlink" title="动态路径"></a>动态路径</h5><p>实际开发中动态路径也是很常见的参数传递形式，例如<code>/user/username/password</code>，这边的<code>username</code>与<code>password</code>是动态改变的。这种形式的路径参数获取也很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/data/&#123;username&#125;/&#123;password&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">data</span><span class="params">(<span class="meta">@PathVariable</span> String username, </span></span><br><span class="line"><span class="params">                   <span class="meta">@PathVariable(&quot;password&quot;)</span> String pwd)</span> &#123;</span><br><span class="line">    System.out.println(username + <span class="string">&quot; &quot;</span> + pwd);</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;%s %s&quot;</span>, username, pwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先在路径映射中使用<code>&#123;路径名&#125;</code>形式为这一段路径起一个名字，然后在形参列表里面定义一个同名的参数，并使用<code>@PathVariable</code>注解修饰这个参数表示该参数接收的是路径参数而不是 param 参数。当然我们也可以给<code>@PathVariable</code>注解的<code>value</code>属性传一个值表示当前形参与哪一个路径参数绑定。</p>
<h4 id="json-参数获取"><a href="#json-参数获取" class="headerlink" title="json 参数获取"></a>json 参数获取</h4><p>json 是前后端通信最常用的数据格式，本节详细探讨一下 json 数据的接收。主要有以下注意点：</p>
<ul>
<li>因为 json 数据是封装到请求体里面的，所以请求方式必须是 POST；</li>
<li>我们必须定义与之对应的实体类来接收 json 数据；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/user&quot;)</span>  <span class="comment">// 必须使用 POST 方式</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">data</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> user.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意我们用来接收 json 数据的实体类对象形参必须使用<code>@RequestBody</code>注解修饰，否则会认为这个实体类是接收 param 参数的。<br>除了以上注意点，我们还需做些工作。因为 Java 原生不支持 json 格式数据，所以我们需要做两件事：</li>
</ul>
<ol>
<li><p>引入解析 json 数据的依赖<code>jackson</code>；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入 jackson 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.16.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为<code>HandlerAdapter</code>配置 json 解析器；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">// 在配置类上加 @EnableWebMvc 注解</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.luyan.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RequestMappingHandlerMapping <span class="title function_">handlerMapping</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerMapping</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RequestMappingHandlerAdapter <span class="title function_">handlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerAdapter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做完这些之后，<code>HandlerAdapter</code>会将 json 字段自动映射到实体类的属性之中。<br>实际上<code>@EnableWebMvc</code>注解非常强大，使用这个注解会自动在容器里面添加<code>HandlerAdapter</code>与<code>HandlerMapping</code>对象，因此我们的配置类直接变成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.luyan.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Cookie-获取"><a href="#Cookie-获取" class="headerlink" title="Cookie 获取"></a>Cookie 获取</h4><p>很多时候我们需要获取 Cookie，可以通过以下方式设置与获取 Cookie：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span>  <span class="comment">// 将 @ResponseBody 注解放到类上，相当于在下面所有方法上加这个注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;save&quot;)</span></span><br><span class="line">    <span class="comment">// 方法直接声明 Response 对象，方便后面存储 Cookie</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">saveCookie</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">        response.addCookie(<span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;root&quot;</span>));</span><br><span class="line">        response.addCookie(<span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;save done!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;get&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCookie</span><span class="params">(<span class="meta">@CookieValue</span> String username, </span></span><br><span class="line"><span class="params">                            <span class="meta">@CookieValue(&quot;password&quot;)</span> String pwd)</span> &#123;</span><br><span class="line">        System.out.println(username + pwd);</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;%s, %s&quot;</span>, username, pwd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取 Cookie 的时候需要在形参列表里声明与 Cookie name 同名的形参，然后使用<code>@CookieValue</code>注解表示该形参接收 Cookie 值。默认情况下形参名就是 Cookie 的 name，如果不一致需要指定<code>@CookieValue</code>注解的<code>value</code>属性。</p>
<h4 id="请求头获取"><a href="#请求头获取" class="headerlink" title="请求头获取"></a>请求头获取</h4><p>请求头的获取也非常简单，我们一样声明形参，然后使用<code>@RequestHeader</code>注解修饰该形参即可获取对应的 Header：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/header&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getHeader</span><span class="params">(<span class="meta">@RequestHeader(&quot;Host&quot;)</span> String host, </span></span><br><span class="line"><span class="params">                        <span class="meta">@RequestHeader(&quot;User-Agent&quot;)</span> String ua)</span> &#123;</span><br><span class="line">    System.out.println(host + ua);</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;%s %s&quot;</span>, host, ua);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中我们获取<code>Host</code>与<code>User-Agent</code>两个请求头。</p>
<h4 id="原生对象获取"><a href="#原生对象获取" class="headerlink" title="原生对象获取"></a>原生对象获取</h4><p>能获取的原生对象有很多，我们主要探讨重要的几个。</p>
<h5 id="请求响应相关"><a href="#请求响应相关" class="headerlink" title="请求响应相关"></a>请求响应相关</h5><p>比较常用的原生对象有<code>Request、Response、Session</code>这三个，我们只需要在形参列表声明这几种类型的变量即可获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/data&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">data</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                 HttpServletResponse response,</span></span><br><span class="line"><span class="params">                 HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h5><p>Web 开发中还有一个很重要的对象<code>ServletContext</code>，它是最大的上下文对象。获取项目的实际目录等操作都需要借助这个对象，我们有两种方式获取这个对象：</p>
<ol>
<li><p>借助<code>Request</code>或<code>Session</code>对象获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/data&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">data</span><span class="params">(HttpServletRequest request, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 借助 Request 对象获取</span></span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 借助 Session 对象获取</span></span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接使用 IoC 容器的自动装配功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServletContext servletContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SpringMVC 启动的时候会将<code>ServletContext</code>对象放到 IoC 容器之中，我们自动装配即可。</p>
</li>
</ol>
<h5 id="共享域"><a href="#共享域" class="headerlink" title="共享域"></a>共享域</h5><p>共享域就是一个存储数据的公共区域，比较重要的共享域有以下几种：</p>
<ul>
<li><code>Request</code>一次请求内有效，一般用于请求转发的场景；</li>
<li><code>Session</code>一次会话内有效，一般存储用户信息；</li>
<li><code>ServletContext</code>整个项目运行期间有效，一般用来存储一些全局配置；</li>
</ul>
<p>原始的使用方法都很简单，只需要调用对应域的<code>setAttribute </code>与<code>getAttribute </code>方法即可，这几个域的两个方法签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setAttribute</span><span class="params">(String var1, Object var2)</span>;</span><br><span class="line">Object <span class="title function_">getAttribute</span><span class="params">(String var1)</span>;</span><br></pre></td></tr></table></figure>
<p>除了原始的操作方法，SpringMVC 对<code>Request</code>共享域的操作有四种新写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟要存的 key 与 value</span></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/data1&quot;)</span></span><br><span class="line"><span class="comment">// 方式一：形参定义一个 Map 类型数据，并在里面添加数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">data1</span><span class="params">(Map map)</span> &#123;</span><br><span class="line">    map.put(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/data2&quot;)</span></span><br><span class="line"><span class="comment">// 方式二：形参定义一个 Model 类型数据，并在里面添加数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">data2</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">    model.addAttribute(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/data3&quot;)</span></span><br><span class="line"><span class="comment">// 方式三：形参定义一个 ModelMap 类型数据，并在里面添加数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">data3</span><span class="params">(ModelMap modelMap)</span> &#123;</span><br><span class="line">    modelMap.addAttribute(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/data4&quot;)</span></span><br><span class="line"><span class="comment">// 方式四：创建 ModelAndView 对象并返回</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">data4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    modelAndView.addObject(key, value);</span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;视图名称&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这四种方式都可以往<code>Request</code>域中设置数据，值得注意的是第四种方式，这种方式一定要<code>modelAndView.setViewName(&quot;视图名称&quot;)</code>即设置视图名称。也就是说使用这种方式无法返回数据，只能够返回视图。</p>
<h3 id="数据返回"><a href="#数据返回" class="headerlink" title="数据返回"></a>数据返回</h3><h4 id="返回视图页面"><a href="#返回视图页面" class="headerlink" title="返回视图页面"></a>返回视图页面</h4><p>在混合开发模式下，我们获取数据之后，往往要将数据渲染成 HTML 界面。常见的有 JSP 技术，本节我们就谈谈如何在 SpringMVC 里面通过 JSP 技术返回一个界面。</p>
<h5 id="导包-1"><a href="#导包-1" class="headerlink" title="导包"></a>导包</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet.jsp.jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet.jsp.jstl-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>让配置类实现<code>WebMvcConfigurer</code>接口并重写<code>configureViewResolvers</code>方法，重写这个方法是为了指定视图界面的前后缀。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.luyan.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 寻找视图文件的时候默认拼接上这边设定的前后缀</span></span><br><span class="line">        registry.jsp(<span class="string">&quot;WEB-INF/pages/&quot;</span>, <span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如我们想要渲染<code>index</code>界面，经过拼接 SpringMVC 会去寻找<code>WEB-INF/pages/index.jsp</code>界面。</p>
<h5 id="创建-JSP-界面"><a href="#创建-JSP-界面" class="headerlink" title="创建 JSP 界面"></a>创建 JSP 界面</h5><p>我们在<code>webapp/WEB-INF/pages</code>目录下创建<code>index.jsp</code>文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    $&#123;name&#125; 你好！</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>界面很简单，就是输出一句话。这边使用<code>$&#123;name&#125;</code>获取<code>Request</code>域中键为<code>name</code>的值进行展示。<br>有一个小细节，我们是在<code>webapp/WEB-INF</code>下面创建的 jsp 文件而不是直接在<code>webapp</code>目录下。这么做是因为直接在<code>webapp</code>目录下创建的文件能够直接被外部访问，而<code>webapp/WEB-INF</code>目录下的文件不能被外部直接访问。显然 jsp 文件不应该直接被外部访问，因此我们如此创建。</p>
<h5 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h5><p>接下来我们定义 Handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// 因为 jsp 需要，这边往 Request 域放内容</span></span><br><span class="line">    request.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tom&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;  <span class="comment">// 返回视图文件名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这边我们不能使用<code>@ResponseBody </code>修饰方法，因为一旦使用这个注解就意味着将返回值直接作为响应体内容。实际上，我们这边的返回值表示的是视图文件的名字。</p>
<h4 id="转发-重定向"><a href="#转发-重定向" class="headerlink" title="转发 &amp; 重定向"></a>转发 &amp; 重定向</h4><h5 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h5><p>转发只能转给项目内的资源，不能转给外站资源，SpringMVC 使用下面的方式实现转发：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;forward&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">forward</span><span class="params">(Map map)</span> &#123;</span><br><span class="line">    map.put(<span class="string">&quot;info&quot;</span>, <span class="string">&quot;Content&quot;</span>);</span><br><span class="line">    <span class="comment">// 返回一个以 “forward:” 开头的路径</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于转发有几个注意点：</p>
<ol>
<li>Handler 需要返回一个字符串，且该字符串需要以<code>forward:</code>开头；</li>
<li>Handler 方法不能使用<code>@ResponseBody</code>修饰，否则会将返回值当做响应体；</li>
<li>转发前后的<code>Request</code>对象是同一个，因此可以通过<code>Request</code>域进行信息传递；</li>
</ol>
<h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p>重定向与转发不同，本质上重定向是两次请求，而转发只有一次请求。因此重定向不会共享<code>Request</code>对象，SpringMVC 实现重定向也很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;redirect&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">redirect</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 返回以“redirect:”开头的路径字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于重定向有以下注意点：</p>
<ol>
<li>Handler 需要返回一个字符串，且该字符串需要以<code>redirect:</code>开头；</li>
<li>Handler 方法不能使用<code>@ResponseBody</code>修饰，否则会将返回值当做响应体；</li>
<li>可以重定向到外站资源，例如我想重定向到百度可以返回<code>&quot;redirect:https://www.baidu.com&quot;</code>；</li>
</ol>
<h5 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h5><p>对于原始使用<code>Request</code>与<code>Response</code>对象实现的转发重定向，我们假设项目的根目录是<code>/demo</code>且我们定义了<code>/demo/index</code>路径，有以下注意事项：</p>
<ul>
<li>因为转发只能转给内部资源，因此转发的路径不能携带项目的根目录。例如我们可以使用<code>/index</code>直接访问资源，不能使用<code>/demo/index</code>；</li>
<li>重定向即可以转到站内资源，也可以转到站外资源。<ul>
<li>如果转到站内资源我们可以省略域名、端口号之类的信息，但路径需要写全。例如我们可以写<code>/demo/index</code>而不能写<code>/index</code>；</li>
<li>如果转到外站资源域名、端口号（80 除外）之类的就不能省略。例如<code>https://www.baidu.com</code>就是合法的路径；</li>
</ul>
</li>
</ul>
<p>在 SpringMVC 中，针对重定向到内部资源做了优化，我们可以省略项目根路径。也就是说<strong>在 SpringMVC 里面重定向的路径写法与转发的路径写法一致</strong>。</p>
<h4 id="返回-JSON"><a href="#返回-JSON" class="headerlink" title="返回 JSON"></a>返回 JSON</h4><p>对于前后端分离的项目我们的 Handler 一般都会返回 json 数据，SpringMVC 里面返回 json 数据也很简单，下面一步步分解看看。</p>
<h5 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h5><p>与获取 json 数据一样，我们想返回 json 数据也需要对应的包与支持，简单说就是两个步骤：</p>
<ol>
<li>导入 jackson 包；</li>
<li>配置类上加<code>@EnableWebMvc</code>注解；</li>
</ol>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>我们想要返回 json 格式的数据，首先需要与之对应的实体类。然后在 Handler 中返回这个实体类对象即可，<code>HandlerAdapter</code>会帮我们将对象转成 json 并返回：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="keyword">return</span> user;  <span class="comment">// 直接创建对象并返回即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一点需要注意，我们需要在 Handler 上添加<code>@ResponseBody</code>注解。使用这个注解仍然是表示将返回的内容直接作为响应体，而不会去找视图解析器。</p>
<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><p>在前后端分离的项目中，我们大多数的 Handler 都是直接返回一个 json。因此每一个 Handler 上面写一个<code>@ResponseBody</code>注解就显得很麻烦了。我们可以直接把<code>@ResponseBody</code>注解加到类上，这样就相当于给所有方法都加了这个注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为此 SpringMVC 还给我提供了简化写法，直接加一个<code>@RestController</code>注解即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于<code>@Controller + @ResponseBody = @RestController</code>。</p>
<h4 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h4><p>访问静态资源也是开发过程中很常用的功能，以往我们直接在<code>webapp</code>目录下存放静态资源即可被外部访问。例如我们项目中存在<code>webapp/images/demo.jpg</code>文件，以往我们可以直接通过路径<code>/images/demo.jpg</code>访问这个文件。但是在 SpringMVC 中路径<code>/images/demo.jpg</code>会被交给<code>HandlerMapping</code>寻找对应的 Handler，显然是找不到的，因此在 SpringMVC 之中直接访问静态资源会<code>404</code>。<br>如果想访问静态资源，我们需要对配置文件做如下配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.luyan.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置类实现<code>WebMvcConfigurer</code>接口的<code>configureDefaultServletHandling</code>方法，并在里面开启静态资源映射。</p>
<h3 id="RESTFUL"><a href="#RESTFUL" class="headerlink" title="RESTFUL"></a>RESTFUL</h3><p>REST 即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000 年他的博士论文中提出来的一种软件架构风格。它是一种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。</p>
<h4 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h4><p>设计规范总结来说就是两点：</p>
<ol>
<li>每一个 URI 都应该是一个名词，说白了就是请求路径应该是名词形式而非动词；</li>
<li>我们应该使用正确的请求方式来表示对服务器资源的不同操作；</li>
</ol>
<p>对于一些常见的操作和对应的请求方式见下表：</p>
<table>
<thead>
<tr>
<th><strong>操作</strong></th>
<th><strong>请求方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td>查询数据</td>
<td>GET</td>
</tr>
<tr>
<td>保存数据</td>
<td>POST</td>
</tr>
<tr>
<td>删除数据</td>
<td>DELETE</td>
</tr>
<tr>
<td>更新数据</td>
<td>PUT</td>
</tr>
</tbody></table>
<p>我们不妨以用户操作对比一下传统路径与 RESTFUL 路径：</p>
<table>
<thead>
<tr>
<th><strong>操作</strong></th>
<th><strong>传统风格（动词命名）</strong></th>
<th><strong>RESTFUL 风格（名词命名）</strong></th>
</tr>
</thead>
<tbody><tr>
<td>保存用户</td>
<td><code>/user/save</code></td>
<td><code>/user</code> - POST</td>
</tr>
<tr>
<td>根据 id 删除用户</td>
<td><code>/user/delete?id=1</code></td>
<td><code>/user/1</code> - DELETE</td>
</tr>
<tr>
<td>更新用户</td>
<td><code>/user/update</code></td>
<td><code>/user</code> - PUT</td>
</tr>
<tr>
<td>根据 id 查询用户</td>
<td><code>/user/query?id=1</code></td>
<td><code>/user/1</code> - GET</td>
</tr>
</tbody></table>
<p>重点是使用名词作为请求路径，对于不同操作但路径相同的情况通过请求方式区分。</p>
<h4 id="设计样例"><a href="#设计样例" class="headerlink" title="设计样例"></a>设计样例</h4><p>本节我们使用一个例子阐述一下 RESTFUL 路径设计思路，在此之前我们看一下几个传参原则：</p>
<ol>
<li>对于 POST 与 PUT 请求方式，它支持路径参数、param 参数、请求体参数这三种，但我们推荐单纯在请求体里使用 json 传递参数；</li>
<li>对于 GET 与 DELETE 请求方式，它仅支持路径参数与 param 参数两种，我们推荐按需使用：<ol>
<li>当要传递的是唯一标识时使用路径参数；</li>
<li>当要传递的是模糊条件使用 param 参数；</li>
</ol>
</li>
</ol>
<p>假设我们要基于用户表做一些操作，看看下面的 api 设计：</p>
<table>
<thead>
<tr>
<th><strong>操作</strong></th>
<th><strong>请求方式与接口</strong></th>
<th><strong>请求参数</strong></th>
</tr>
</thead>
<tbody><tr>
<td>分页查询</td>
<td><code>GET</code>&#x2F;user</td>
<td>page&#x3D;1&amp;size&#x3D;10</td>
</tr>
<tr>
<td>用户添加</td>
<td><code>POST</code>&#x2F;user</td>
<td>请求体 json</td>
</tr>
<tr>
<td>根据 id 查询用户</td>
<td><code>GET</code>&#x2F;user&#x2F;1</td>
<td>路径参数</td>
</tr>
<tr>
<td>用户更新</td>
<td><code>PUT</code>&#x2F;user</td>
<td>请求体 json</td>
</tr>
<tr>
<td>根据 id 删除用户</td>
<td><code>DELETE</code>&#x2F;user&#x2F;1</td>
<td>路径参数</td>
</tr>
<tr>
<td>模糊匹配</td>
<td><code>GET</code>&#x2F;user&#x2F;search</td>
<td>keyword&#x3D;关键字&amp;…</td>
</tr>
</tbody></table>
<ul>
<li>所有的 POST 与 PUT 操作都是使用请求体 json 传递参数；</li>
<li>当我们需要传递的参数是 id 等唯一标识时使用的是路径参数，例如<code>/user/1</code>；</li>
<li>当我们需要传递的参数是一种模糊条件时使用 param 参数，例如<code>/user?page=1&amp;size=10</code>；</li>
<li>同一请求方式下，路径命名重复可以使用动词命名（走投无路），例如<code>/user/search</code>；</li>
<li>若查询操作中需要传递的参数比较敏感也可以使用 POST 请求方式；</li>
</ul>
<h3 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h3><p>以往我们会使用<code>try...catch</code>捕获异常，现在 SpringMVC 提供了一套全局异常处理机制给我们。下面我们看看具体的操作步骤。<br>首先，业务逻辑部分该咋写咋写，不需要去捕获异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;  <span class="comment">// 不需要去捕获异常</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/null&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(<span class="number">1</span>);  <span class="comment">// 不需要去捕获异常</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，定义一个全局异常捕获类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalErrorHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @ExceptionHandler 注解指定该方法处理什么异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(NullPointerException.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">nullPointerHandler</span><span class="params">(NullPointerException e)</span> &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">exceptionHandler</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于这个异常捕获类有几点说明：</p>
<ol>
<li>这个类需要用<code>@ControllerAdvice </code>或<code>@RestControllerAdvice </code>注解修饰，这两个注解的区别就是<code>@RestControllerAdvice</code>注解暗含一个<code>@ResponseBody</code>；</li>
<li>被这两个注解修饰之后里面的方法都会变成 Handler，也就是说可以返回数据、视图等。因为我们这边就是想返回一个字符串回去，因此使用<code>@RestControllerAdvice</code>修饰类；</li>
<li>每一个方法需要使用<code>@ExceptionHandler</code>注解指定该方法能够处理的异常，有多个异常需要同一个方法处理时可以使用形如<code>&#123;Exception1.class, Exception2.class&#125;</code>这种形式；</li>
<li>我们可以在方法形参里面定义该异常对象，便于我们处理该异常；</li>
<li>发生异常时会优先寻找对应的 Handler，找不到逐层寻找其父异常对应的 Handler；</li>
</ol>
<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>拦截器的功能与之前的过滤器有些类似，但不完全相同。Web 开发中的过滤器是请求到达一个 Servlet 之前被拦住做某些操作，例如编码设置、登录校验、权限鉴定等。这显然在 SpringMVC 中是不实用的，因为 SpringMVC 中只有一个核心 Servlet，所有请求都经过这个 Servlet 的转发。<br>这种情况下，我们想要的是在请求到达 Handler 之前进行拦截。SpringMVC 也给我们提供相关技术，称为拦截器，这边拦截器可以在三个地方做拦截：</p>
<ol>
<li>Handler 处理前；</li>
<li>Handler 处理后；</li>
<li>整个请求结束返回给用户前；</li>
</ol>
<p>下面我们看下使用拦截器的整个流程。</p>
<h4 id="定义拦截器"><a href="#定义拦截器" class="headerlink" title="定义拦截器"></a>定义拦截器</h4><p>定义拦截器的具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义拦截器需实现 HandlerInterceptor 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                             HttpServletResponse response,</span></span><br><span class="line"><span class="params">                             Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Handler 前处理&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                           HttpServletResponse response,</span></span><br><span class="line"><span class="params">                           Object handler,</span></span><br><span class="line"><span class="params">                           ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Handler 后处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求结束处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口中有三个方法，分别是：</p>
<ul>
<li><code>preHandle</code>表示 Handler 执行前，只有该方法返回<code>true</code>才能继续往后执行（包括执行 Handler 与触发后续拦截器），我们一般在这做登录校验等工作；</li>
<li><code>postHandle</code>表示 Handler 执行后，我们一般在这个阶段做敏感词汇过滤；</li>
<li><code>afterCompletion</code>表示整个请求结束返回给用户之前；</li>
</ul>
<h4 id="注册拦截器"><a href="#注册拦截器" class="headerlink" title="注册拦截器"></a>注册拦截器</h4><p>拦截器定义好之后，我们还需要在配置文件中注册这个拦截器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.luyan&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 为所有请求注册拦截器（静态资源不拦截）</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">MyInterceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的 IoC 配置类需要实现<code>WebMvcConfigurer</code>接口，并实现<code>addInterceptors</code>方法，最后在方法中注册拦截器。<br>目前配置完毕之后，所有的请求都会被拦截。中间想要做什么操作，也可以通过提供的<code>Request</code>与<code>Response</code>对象进行操作，例如登录校验失败跳转到登录界面。</p>
<h4 id="更多拦截规则"><a href="#更多拦截规则" class="headerlink" title="更多拦截规则"></a>更多拦截规则</h4><p>上面我们展示了如何拦截所有的请求，在某些时候我们想要拦截的只是部分请求怎么办？我们可以使用如下写法实现拦截部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拦截全部</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">MyInterceptor</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式调用 addPathPatterns 方法之后只拦截 /hello</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">MyInterceptor</span>()).addPathPatterns(<span class="string">&quot;/hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式调用 addInterceptor 方法之后，在前面拦截规则基础上取消拦截 /hello</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">MyInterceptor</span>()).excludePathPatterns(<span class="string">&quot;/hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>我们可以将<code>addPathPatterns</code>与<code>excludePathPatterns</code>配合使用实现灵活拦截。<br>除此之外，拦截规格也支持模糊匹配，<code>*</code>表示拦截一层任意路径，<code>**</code>表示拦截任意层任意路径。</p>
<h4 id="拦截时机"><a href="#拦截时机" class="headerlink" title="拦截时机"></a>拦截时机</h4><p>我们可以同时注册多个拦截器，它们的运行时机是如何的？例如我们注册如下拦截器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">MyInterceptor1</span>());</span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">MyInterceptor2</span>());</span><br></pre></td></tr></table></figure>
<p>多个拦截器之间是包裹关系，最核心部分就是被拦截的 Handler，本例中先后如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyInterceptor1.preHandle</span><br><span class="line">MyInterceptor2.preHandle</span><br><span class="line"></span><br><span class="line">核心 Handler 操作</span><br><span class="line"></span><br><span class="line">MyInterceptor2.postHandle</span><br><span class="line">MyInterceptor1.postHandle</span><br><span class="line"></span><br><span class="line">MyInterceptor2.afterCompletion</span><br><span class="line">MyInterceptor1.afterCompletion</span><br></pre></td></tr></table></figure>
<p>简单说多个拦截器方法的执行顺序为：核心操作前按注册顺序执行，核心操作后按注册顺序逆序执行。</p>
<h3 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h3><p>参数校验就是针对前端传过来的数据，判断其是否满足一定约束。例如年龄不能是负数，姓名不能是空串等。以前这些内容都需要我们自己做，现在我们可以使用参数校验注解快速实现。</p>
<h4 id="导包-2"><a href="#导包-2" class="headerlink" title="导包"></a>导包</h4><p>这些注解在 Java 只是一种标准，我们需要导入其实现者的包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>我们开发过程中比较常见的注解有：</p>
<table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>验证的数据类型</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>@AssertFalse</code></td>
<td>Boolean,boolean</td>
<td>验证注解的元素值是 false</td>
</tr>
<tr>
<td><code>@AssertTrue</code></td>
<td>Boolean,boolean</td>
<td>验证注解的元素值是 true</td>
</tr>
<tr>
<td><code>@NotNull</code></td>
<td>任意类型</td>
<td>验证注解的元素值不是 null</td>
</tr>
<tr>
<td><code>@Null</code></td>
<td>任意类型</td>
<td>验证注解的元素值是 null</td>
</tr>
<tr>
<td><code>@Min(value)</code></td>
<td>BigDecimal，BigInteger, byte,short, int, long，等任何Number或CharSequence（存储的是数字）子类型</td>
<td>验证注解的元素值 ≥value</td>
</tr>
<tr>
<td><code>@Max(value)</code></td>
<td>和@Min要求一样</td>
<td>验证注解的元素值 ≤value</td>
</tr>
<tr>
<td><code>@DecimalMin(value)</code></td>
<td>和@Min要求一样</td>
<td>验证注解的元素值 ≥value</td>
</tr>
<tr>
<td><code>@DecimalMax(value)</code></td>
<td>和@Min要求一样</td>
<td>验证注解的元素值 ≤value</td>
</tr>
<tr>
<td><code>@Digits(integer, fraction)</code></td>
<td>和@Min要求一样</td>
<td>验证注解的元素值的整数位数和小数位数上限</td>
</tr>
<tr>
<td><code>@Size(min, max)</code></td>
<td>字符串、Collection、Map、数组等</td>
<td>验证注解的元素大小在 [min, max] 范围内，如字符串长度、集合大小</td>
</tr>
<tr>
<td><code>@Past</code></td>
<td>java.util.Date,java.util.Calendar;Joda Time类库的日期类型</td>
<td>验证注解的元素值比当前时间早</td>
</tr>
<tr>
<td><code>@Future</code></td>
<td>与@Past要求一样</td>
<td>验证注解的元素值比当前时间晚</td>
</tr>
<tr>
<td><code>@NotBlank</code></td>
<td>CharSequence子类型</td>
<td>验证去除首尾空白字符之后串长度 &gt;0</td>
</tr>
<tr>
<td><code>@Length(min, max)</code></td>
<td>CharSequence子类型</td>
<td>验证注解的串长度在 [min, max] 范围内</td>
</tr>
<tr>
<td><code>@NotEmpty</code></td>
<td>CharSequence子类型、Collection、Map、数组</td>
<td>验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0）</td>
</tr>
<tr>
<td><code>@Range(min, max)</code></td>
<td>BigDecimal,BigInteger,CharSequence, byte, short, int, long等原子类型和包装类型</td>
<td>验证注解的元素值在 [min, max] 范围内</td>
</tr>
<tr>
<td><code>@Email</code></td>
<td>CharSequence子类型（如String）</td>
<td>验证注解的元素值是Email，也可以通过regexp和flag指定自定义的email格式</td>
</tr>
<tr>
<td><code>@Pattern(regexp)</code></td>
<td>String，任何CharSequence的子类型</td>
<td>验证注解的元素值与指定的正则表达式匹配</td>
</tr>
<tr>
<td><code>@Valid</code></td>
<td>任何非原子类型</td>
<td>指定递归验证关联的对象，如用户对象中有个地址对象属性，如果想在验证用户对象时一起验证地址对象的话，在地址对象上加@Valid注解即可级联验证</td>
</tr>
</tbody></table>
<p>开发过程中比较常用的注解单独拿出来列表：</p>
<table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>验证的数据类型</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>@NotNull</code></td>
<td>任意类型</td>
<td>验证注解的元素值不是 null</td>
</tr>
<tr>
<td><code>@Min(value)</code></td>
<td>BigDecimal，BigInteger, byte,short, int, long，等任何Number或CharSequence（存储的是数字）子类型</td>
<td>验证注解的元素值 ≥value</td>
</tr>
<tr>
<td><code>@Max(value)</code></td>
<td>和@Min要求一样</td>
<td>验证注解的元素值 ≤value</td>
</tr>
<tr>
<td><code>@NotBlank</code></td>
<td>CharSequence子类型</td>
<td>验证去除首尾空白字符之后串长度 &gt;0</td>
</tr>
<tr>
<td><code>@Length(min, max)</code></td>
<td>CharSequence子类型</td>
<td>验证注解的串长度在 [min, max] 范围内</td>
</tr>
<tr>
<td><code>@Email</code></td>
<td>CharSequence子类型（如String）</td>
<td>验证注解的元素值是Email，也可以通过regexp和flag指定自定义的email格式</td>
</tr>
</tbody></table>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>参数校验使用起来也非常简单：</p>
<ol>
<li><p>我们需要在实体类对应的属性上加对应的校验注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Min(1)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们这边只对姓名校验非空，年龄最小 1 岁。</p>
</li>
<li><p>在 Handler 对应参数前面加上<code>@Validated </code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">user</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated</span> User user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边我们使用<code>@Validated</code>注解修饰形参<code>user</code>，框架会帮我们校验各字段是否合法。如果校验不通过默认情况下会报错。<br>如果我们不希望校验失败就报错，而是希望校验失败我们返回一个 json 数据，里面包含错误信息可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">user</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated</span> User user, BindingResult result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">            System.out.println(result.getAllErrors());</span><br><span class="line">            Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;code&quot;</span>, <span class="number">400</span>);</span><br><span class="line">            map.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;参数校验失败&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们<strong>挨着</strong>校验对象<code>user</code>定义了一个<code>BindingResult</code>类型的形参<code>result</code>，校验情况可以通过<code>result</code>获取。但注意，<code>BindingResult</code>对象必须与被校验对象定义在一起，中间不能声明其它形参。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/16/MyBatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/07/16/MyBatis/" itemprop="url">MyBatis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-07-16T17:33:49+08:00">
                2023-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MyBatis 是一款用于持久层的、轻量级的半自动化 ORM 框架，封装了所有 jdbc 操作以及设置查询参数和获取结果集的操作，支持自定义 sql、存储过程和高级映射。</p>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h4><p>MyBatis 需要导两个包，一个是连接数据库的<code>mysql-connector-java</code>，一个是<code>mybatis</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>使用 MyBatis 操作数据库主要有 4 个步骤：</p>
<ul>
<li>定义数据库操作的接口；</li>
<li>编写 mapper 文件；</li>
<li>编写 MyBatis 核心配置文件；</li>
<li>编写代码操作数据库；</li>
</ul>
<h5 id="定义操作接口"><a href="#定义操作接口" class="headerlink" title="定义操作接口"></a>定义操作接口</h5><p>我们会定义接口用来表示需要那些数据库操作。接口里面定义一些操作数据库的方法声明，包括需要什么参数、返回什么类型数据等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line">    <span class="comment">// 目前只定义了一个方法，按照 id 查询学生</span></span><br><span class="line">    Student <span class="title function_">queryById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="编写-mapper-文件"><a href="#编写-mapper-文件" class="headerlink" title="编写 mapper 文件"></a>编写 mapper 文件</h5><p>光有接口不行，每一个操作最终都是需要翻译成 sql 语句的。因此就出现了 mapper 文件，一个 mapper 文件与一个接口对应，我们一般将 mapper 文件放到<code>resources/mappers/</code>目录下。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- namespace 里面填写与之对应的接口全限定名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.luyan.mappers.StudentMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id 对应着接口内的一个方法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.luyan.bean.Student&quot;</span>&gt;</span></span><br><span class="line">        SELECT id, sname AS name, class AS clazz FROM students WHERE id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>根据数据库操作类型，mapper 文件中可以定义<code>insert、delete、update、select</code>操作标签，上面案例使用<code>select</code>标签表示查询数据信息。关于操作标签有以下注意事项：</p>
<ul>
<li>每个操作标签都有<code>id</code>属性用来与接口内方法绑定，即一个方法对应一个标签。标签的主要职责就是提供 sql 语句，因此我们不能在接口内定义重载方法，否则标签无法明确与谁绑定；</li>
<li>对于<code>select</code>标签我们可以使用<code>resultType</code>属性来指定返回值类型，MyBatis 会自动根据字段名称将记录映射为实体类；<ul>
<li>对于表字段名和类变量名不一致的情况，sql 语句使用<code>as</code>关键字改成一样的名称；</li>
</ul>
</li>
<li>其它非选择语句虽然没有指定返回值类型，但都会返回一个整数表示受影响的记录条数；</li>
<li>在 sql 语句中可以使用<code>#&#123;key&#125;</code>的方式获取接口方法的形参，具体 key 怎么写后面看；</li>
</ul>
<h5 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h5><p>目前数据库操作有哪些、每个操作需要什么参数、返回什么数据等信息都通过接口定义好了，对于每一个操作 sql 语句这么写也通过 mapper 文件定义好了。但是连接数据库总得需要一些连接信息吧？若定义多个 mapper 文件，哪些 mapper 文件是有效的？这些信息由 MyBatis 核心配置文件指定：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- environments 里面放若干个环境，使用 default 指定使用哪一个环境的配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- environment 标签配置具体环境，使用 id 作为不同环境的唯一标识 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- MyBatis 默认的事务管理器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置数据源信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/demo&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql2425@&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用 mapper 标签注册定义的 mapper 文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/StudentMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之所以分环境，是因为项目中生产与开发条件下连接的数据库信息是不一样的。</p>
<h5 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h5><p>编写代码有固定的套路，主要看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 读取 mybatis 核心配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">ips</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建 SqlSessionFactory</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(ips);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 开启 SqlSession，每次业务都开启一个，用完就释放</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建接口的代理对象并使用</span></span><br><span class="line"><span class="type">StudentMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(StudentMapper.class);</span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> mapper.queryById(<span class="number">2</span>);</span><br><span class="line">System.out.println(student);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 提交事务 &amp; 释放资源</span></span><br><span class="line">sqlSession.commit();</span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><h4 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h4><p>我们在 mapper 文件的操作标签中可以使用<code>#&#123;&#125;</code>来获取传递的参数，除此之外还可以使用<code>$&#123;&#125;</code>来获取参数，那么两者有什么区别？<br>使用<code>#&#123;&#125;</code>获取参数相当于使用占位符构造 sql 语句，看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students <span class="type">WHERE</span> <span class="variable">id</span> <span class="operator">=</span> #&#123;id&#125;</span><br><span class="line"></span><br><span class="line">=====&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM students WHERE id = ?&quot;</span>;</span><br><span class="line">select(sql, id);  <span class="comment">// 使用占位符，并在代码里注入参数</span></span><br></pre></td></tr></table></figure>
<p>使用<code>$&#123;&#125;</code>获取参数相当于直接使用字符串拼接，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students <span class="type">WHERE</span> <span class="variable">id</span> <span class="operator">=</span> #&#123;id&#125;</span><br><span class="line"></span><br><span class="line">=====&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM students WHERE id = &quot;</span> + id;</span><br><span class="line">select(sql);  <span class="comment">// 这边 sql 语句是直接进行字符串拼接的</span></span><br></pre></td></tr></table></figure>
<p>很显然使用<code>#&#123;&#125;</code>可以有效防止 sql 注入攻击，因此当两者都可以使用的时候我们倾向于使用<code>#&#123;&#125;</code>。<br>那什么情况下只能使用<code>$&#123;&#125;</code>呢？答：当参数不是表示数据的时候。例如我可能根据 id 查询学生，也有可能根据姓名查询学生，这种情况下数据表字段是变量，此时就不能使用<code>#&#123;&#125;</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students WHERE $&#123;key&#125; = #&#123;value&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子就是查询的字段及其值都由参数指定。</p>
<h4 id="单简单类型传参"><a href="#单简单类型传参" class="headerlink" title="单简单类型传参"></a>单简单类型传参</h4><p>接口方法定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student <span class="title function_">queryById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>
<p>对应的 mapper 标签定义为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.luyan.bean.Student&quot;</span>&gt;</span></span><br><span class="line">    SELECT id, sname name, class clazz FROM students WHERE id=#&#123;xx&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>参数只有一个简单类型，此时在 xml 里面使用插值表达式获取参数的时候 key 随意。就像这边<code>#&#123;xx&#125;</code>，key 值不需要与接口方法的参数一致，但推荐一致。</p>
<h4 id="多简单类型传参"><a href="#多简单类型传参" class="headerlink" title="多简单类型传参"></a>多简单类型传参</h4><p>接口方法定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student <span class="title function_">queryByNameClass</span><span class="params">(String name, String clazz)</span>;</span><br></pre></td></tr></table></figure>
<p>这种情况下 mapper 有三种写法：</p>
<ol>
<li><p>使用<code>arg0...</code>根据下标获取参数：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryByNameClass&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.luyan.bean.Student&quot;</span>&gt;</span></span><br><span class="line">    SELECT id, sname name, class clazz FROM students </span><br><span class="line">      WHERE sname=#&#123;arg0&#125; and class=#&#123;arg1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>param1...</code>根据下标获取参数：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryByNameClass&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.luyan.bean.Student&quot;</span>&gt;</span></span><br><span class="line">    SELECT id, sname name, class clazz FROM students </span><br><span class="line">      WHERE sname=#&#123;param1&#125; and class=#&#123;param2&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>@Param</code>注解给参数指定 key 名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给两个参数分别指定 key 值为 a 与 b</span></span><br><span class="line">Student <span class="title function_">queryByNameClass</span><span class="params">(<span class="meta">@Param(&quot;a&quot;)</span> String name, <span class="meta">@Param(&quot;b&quot;)</span> String clazz)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryByNameClass&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.luyan.bean.Student&quot;</span>&gt;</span></span><br><span class="line">    SELECT id, sname name, class clazz FROM students </span><br><span class="line">      WHERE sname=#&#123;a&#125; and class=#&#123;b&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时 xml 里面根据设定的 key 获取参数，而且这么使用之后<code>arg0、param1</code>之类的就失效了。<br>我们当然推荐使用第三种方式，并且推荐起的名字与参数名一致。</p>
</li>
</ol>
<h4 id="单对象传参"><a href="#单对象传参" class="headerlink" title="单对象传参"></a>单对象传参</h4><p>接口方法定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">addOne</span><span class="params">(Student student)</span>;</span><br></pre></td></tr></table></figure>
<p>对应的 mapper 标签定义为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addOne&quot;</span>&gt;</span></span><br><span class="line">    INSERT INTO students (sname, class) VALUES (#&#123;name&#125;, #&#123;clazz&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种情况直接将实体类对象传到方法里，xml 取值的时候 key 值直接指定为实体类的属性名。</p>
<h4 id="Map-传参"><a href="#Map-传参" class="headerlink" title="Map 传参"></a>Map 传参</h4><p>接口方法定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">addOneMap</span><span class="params">(Map&lt;String, Object&gt; data)</span>;</span><br></pre></td></tr></table></figure>
<p>方法调用代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Object&gt; studentMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">studentMap.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">studentMap.put(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;小学六年级&quot;</span>);</span><br><span class="line">mapper.addOneMap(studentMap);</span><br></pre></td></tr></table></figure>
<p>对应的 mapper 标签定义为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addOneMap&quot;</span>&gt;</span></span><br><span class="line">    INSERT INTO students (sname, class) VALUES (#&#123;name&#125;, #&#123;class&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>显然 xml 获取参数的 key 就是 Map 的键。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><h4 id="返回值别名"><a href="#返回值别名" class="headerlink" title="返回值别名"></a>返回值别名</h4><p>我们之前说过在 mapper 里面使用<code>select</code>标签可以通过<code>resultType </code>属性指定返回值类型，之前我们使用类的全限定名来指定这个类型。下面我们详细说一下返回值类型的三种写法。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryByNameClass&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.luyan.bean.Student&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="全限定符"><a href="#全限定符" class="headerlink" title="全限定符"></a>全限定符</h5><p>这个很简单，不论是自定义类还是 Java 给我们提供的类都可以使用这种方式，例如<code>com.luyan.bean.Student</code>、<code>java.lang.String</code>等。</p>
<h5 id="MyBatis-默认别名"><a href="#MyBatis-默认别名" class="headerlink" title="MyBatis 默认别名"></a>MyBatis 默认别名</h5><p>对于一些常用的系统类型，我们每次都写全限定符很麻烦。MyBatis 给这些常用系统类型都提供了别名：</p>
<ol>
<li>基本数据类型的别名就是在前面加一个<code>_</code>：<code>byte -&gt; _byte</code>、<code>int -&gt; _int</code>、<code>double -&gt; _double</code>、<code>boolean -&gt; _boolean</code>……</li>
<li>包装类型的别名就是首字母小写：<code>Short -&gt; short</code>、<code>Long -&gt; long</code>、<code>Float -&gt; float</code>、<code>Integer -&gt; integer | int</code>……</li>
<li>其它一些常见类型基本都是改成全小写形式：<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>别名</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Date</td>
<td>date</td>
</tr>
<tr>
<td>Object</td>
<td>object</td>
</tr>
<tr>
<td>Map</td>
<td>map</td>
</tr>
<tr>
<td>HashMap</td>
<td>hashmap</td>
</tr>
<tr>
<td>List</td>
<td>list</td>
</tr>
<tr>
<td>ArrayList</td>
<td>arraylist</td>
</tr>
<tr>
<td>Collection</td>
<td>collection</td>
</tr>
<tr>
<td>Iterator</td>
<td>iterator</td>
</tr>
</tbody></table>
</li>
</ol>
<p>事实上这些别名都是不区分大小写的，但我们默认还是按照规范来。</p>
<h5 id="自定义别名"><a href="#自定义别名" class="headerlink" title="自定义别名"></a>自定义别名</h5><p>除了这些默认定义的别名，MyBatis 还支持我们自定义别名。此时我们需要在 MyBatis 核心配置文件里面通过<code>typeAliases</code>标签进行配置，但是注意核心配置文件里面的标签是有顺序关系的，具体如下：</p>
<ul>
<li>configuration（配置)<ul>
<li>properties（属性）</li>
<li>settings（设置）</li>
<li>typeAliases（类型别名）</li>
<li>typeHandlers（类型处理器）</li>
<li>objectFactory（对象工厂）</li>
<li>plugins（插件）</li>
<li>environments（环境配置）<ul>
<li>environment（环境变量）<ul>
<li>transactionManager（事务管理器）</li>
<li>dataSource（数据源）</li>
</ul>
</li>
</ul>
</li>
<li>databaseldProvider（数据库厂商标识）</li>
<li>mappers（映射器）</li>
</ul>
</li>
</ul>
<h6 id="单个定义"><a href="#单个定义" class="headerlink" title="单个定义"></a>单个定义</h6><p>做如下配置即可为某个类起一个别名，自定义的别名也是忽略大小写的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.luyan.bean.Student&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;Student&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种方式起别名当类比较多的时候比较麻烦。</p>
<h6 id="批量定义"><a href="#批量定义" class="headerlink" title="批量定义"></a>批量定义</h6><p>除了挨个为类起别名，MyBatis 还支持批量为某个包及其子包下的所有类起别名，默认的起别名规则就是类名的首字母小写（其实起的别名不区分大小写）。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.luyan.bean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>例子中包<code>com.luyan.bean</code>及其子包下的所有类都会被起一个别名。<br>在批量起别名的基础上，如果我们想给一个类指定别名，可以使用<code>@Alias </code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;stu&quot;)</span>  <span class="comment">// 将当前类起别名为 stu</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><code>@Alias</code>注解一定是配合批量起别名的。</p>
<h4 id="属性映射"><a href="#属性映射" class="headerlink" title="属性映射"></a>属性映射</h4><p>我们在 mapper 的<code>select</code>标签里面，可以通过<code>resultType </code>属性设置返回值类型。我们知道 Java 推荐驼峰命名，而数据库推荐下划线命名，因此数据表字段与实体类属性名经常会不一致。名称不一致 MyBatis 就无法将查询的记录映射成实体类，下面有三种解决方案。</p>
<h5 id="数据库查询别名"><a href="#数据库查询别名" class="headerlink" title="数据库查询别名"></a>数据库查询别名</h5><p>我们在写 sql 语句的时候为查询到字段起别名即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryByNameClass&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.luyan.bean.Student&quot;</span>&gt;</span></span><br><span class="line">    SELECT id, sname name, class clazz FROM students</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>查询 sql 里面的<code>AS</code>关键字可以省略，所以直接写形如<code>class clazz</code>即可。</p>
<h5 id="开启驼峰映射"><a href="#开启驼峰映射" class="headerlink" title="开启驼峰映射"></a>开启驼峰映射</h5><p>大部分情况下，即使数据表字段名与实体类属性名不一致，但基本结构是相似的，例如<code>stuName</code>与<code>stu_name</code>的关系。MyBatis 可以支持配置将数据库读取出来的下划线命名映射到实体类时使用驼峰命名，我们只需要在 MyBatis 核心配置文件的<code>settings</code>标签中添加以下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>这个配置是拿到查询结果之后，找实体类属性的时候会使用驼峰式命名寻找，并不是直接返回驼峰式的命名。之所以关注这个是因为<code>3.3</code>返回 Map 的时候，即使开启了这个开关，返回的字段名也还是下划线形式的。</p>
<h5 id="自定义映射规则"><a href="#自定义映射规则" class="headerlink" title="自定义映射规则"></a>自定义映射规则</h5><p>对于一些深层次的映射或者数据表字段名与实体类属性名差异较大的情况，上面的两种方式就没办法处理了。MyBatis 支持我们自定义映射规则，具体操作如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  id 是这个 resultMap 的唯一标识</span></span><br><span class="line"><span class="comment">      type 用来指定这个映射作用在哪一个类里面，这边是给学生类起别名了 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;studentMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id 标签用来指定数据库主键的映射，result 标签指定其它属性的映射 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;class&quot;</span> <span class="attr">property</span>=<span class="string">&quot;clazz&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- resultMap 属性用来指定使用哪一个映射，这个属性和 resultType 二选一 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM students WHERE id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="返回-Map"><a href="#返回-Map" class="headerlink" title="返回 Map"></a>返回 Map</h4><p>有时候查询的数据并没有对应的实体类，例如我想查询某字段的最大值、最小值、平均值等信息。我们为了这个需求设计一个实体类不太合理，此时我们就可以将返回值类型设为<code>Map</code>。<br>接口方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; <span class="title function_">queryMapById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>
<p>对应的 mapper 如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryMapById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这边的返回值类型我们使用的是 MyBatis 提供的默认别名<code>map</code>，Map 中 key 由查询的字段名组成，value 就是查询的值。</p>
<h4 id="返回-List"><a href="#返回-List" class="headerlink" title="返回 List"></a>返回 List</h4><p>很多时候我们需要查询的结果是一个集合，那么这种情况下返回值类型怎么写呢？<br>答：直接写集合的泛型类型即可，看下面两个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; <span class="title function_">queryAll</span><span class="params">()</span>;</span><br><span class="line">List&lt;String&gt; <span class="title function_">queryAllNames</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>与之对应的 mapper 如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 要的是 List&lt;Student&gt;，但我们返回类型只写 student --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM students</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 要的是 List&lt;String&gt;，但我们返回类型只写 string --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAllNames&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;string&quot;</span>&gt;</span></span><br><span class="line">    SELECT stu_name FROM students</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中<code>string</code>是 MyBatis 的默认别名，<code>student</code>是我们自定义的别名。</p>
<h4 id="自增长主键回显"><a href="#自增长主键回显" class="headerlink" title="自增长主键回显"></a>自增长主键回显</h4><p>日常开发中，我们往往会使用自增长的整数作为数据表的主键。那么就会有这样的使用场景：我想要插入一条数据到数据库中，并且插入完成我想获取到新记录的 id。<br>mapper 文件定义的插入标签如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addOne&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyColumn</span>=<span class="string">&quot;stu_id&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;stuId&quot;</span>&gt;</span></span><br><span class="line">    INSERT INTO students (stu_name, stu_class) VALUES (#&#123;stuName&#125;, #&#123;stuClass&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这边新出现三个属性：</p>
<ul>
<li><code>useGeneratedKeys</code>表示是否使用自增长主键；</li>
<li><code>keyColumn</code>指定数据库中自增长主键的字段名；</li>
<li><code>keyProperty</code>指定获取到主键值放到实体类的哪一个变量中；</li>
</ul>
<p>对应的接口方法与测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口方法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addOne</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;哇哈哈&quot;</span>, <span class="string">&quot;小学五年级&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> mapper.addOne(s);  <span class="comment">// 传学生对象进去</span></span><br><span class="line">System.out.println(s);  <span class="comment">// 插入成功后，对象 s 的 stuId 属性会将被赋值为主键值</span></span><br><span class="line">System.out.println(rows);  <span class="comment">// rows 是受影响记录条数</span></span><br></pre></td></tr></table></figure>
<h4 id="非自增长主键维护"><a href="#非自增长主键维护" class="headerlink" title="非自增长主键维护"></a>非自增长主键维护</h4><p>项目中一般会使用 UUID 作为非自增长主键，假设我们有一张<code>teachers</code>表，表里就两个字段：</p>
<ul>
<li><code>t_id</code>主键，字符串类型；</li>
<li><code>t_name</code>表示教师姓名，字符串类型；</li>
</ul>
<h5 id="传统写法"><a href="#传统写法" class="headerlink" title="传统写法"></a>传统写法</h5><p>因为主键不是自增长的了，所以主键现在需要我们自己去维护，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口方法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addOne</span><span class="params">(Teacher teacher)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码，需要我们自己生成主键</span></span><br><span class="line"><span class="type">String</span> <span class="variable">tId</span> <span class="operator">=</span> UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(tId, <span class="string">&quot;张老师&quot;</span>);</span><br><span class="line">mapper.addOne(teacher);</span><br></pre></td></tr></table></figure>
<p>对应的 mapper 如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addOne&quot;</span>&gt;</span></span><br><span class="line">    INSERT INTO teachers (t_id, t_name) VALUES (#&#123;tId&#125;, #&#123;tName&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一般字符串类型的主键我们会选择使用 UUID，代码很常规没什么好说的。</p>
<h5 id="MyBatis-维护"><a href="#MyBatis-维护" class="headerlink" title="MyBatis 维护"></a>MyBatis 维护</h5><p>我们主键的生成可以交给 MyBatis，具体操作如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试代码，这边不需要给实体类赋主键值</span></span><br><span class="line"><span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">teacher.settName(<span class="string">&quot;王老师&quot;</span>);</span><br><span class="line">mapper.addOne(teacher);</span><br><span class="line">System.out.println(teacher.gettId());  <span class="comment">// 此时对象的 tId 属性已经被赋值</span></span><br></pre></td></tr></table></figure>
<p>对应的 mapper 如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addOne&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;tId&quot;</span>&gt;</span></span><br><span class="line">        SELECT REPLACE(UUID(), &quot;-&quot;, &quot;&quot;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    INSERT INTO teachers (t_id, t_name) VALUES (#&#123;tId&#125;, #&#123;tName&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这边主要需要关注一下<code>selectKey</code>标签，这个标签内部也写着 sql 语句。主要的属性有：</p>
<ul>
<li><code>order</code>用来指定<code>selectKey</code>内部 sql 语句的执行时机：<ul>
<li><code>BEFORE</code>表示执行在主 sql 语句之前；</li>
<li><code>AFTER</code>表示执行在主 sql 语句之后；</li>
</ul>
</li>
<li><code>resultType</code>用来指定内部 sql 语句的返回值类型；</li>
<li><code>keyProperty</code>用来指定将内部 sql 语句的返回值赋给哪一个变量；</li>
</ul>
<p>因此本例的解读：在执行插入 sql 语句之前先执行<code>selectKey</code>内部的 sql 语句生成一个字符串赋值给传进来对象的<code>tId</code>属性。</p>
<h4 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h4><p>我们每定义一个实体类就要去写对应的<code>getter/setter</code>与<code>toString</code>，还是比较麻烦。我们可以使用<code>Lombok</code>简化书写，主要分为以下几个步骤。</p>
<h5 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h5><p>如右图，我们在 IDEA 里面安装<code>Lombok</code>插件。<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1712199901994-2d743c5d-133b-4587-90c8-b99595cb49fa.png#averageHue=%23eaf3fc&clientId=uf9f2e138-2bd0-4&from=paste&height=66&id=u28f0c5dc&originHeight=66&originWidth=336&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4209&status=done&style=none&taskId=u2229f81f-3be9-4f6e-8f37-7197a65dc33&title=&width=336" alt="image.png"></p>
<h5 id="导包-1"><a href="#导包-1" class="headerlink" title="导包"></a>导包</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="使用-Data注解"><a href="#使用-Data注解" class="headerlink" title="使用@Data注解"></a>使用<code>@Data</code>注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String tId;</span><br><span class="line">    <span class="keyword">private</span> String tName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接使用<code>@Data</code>注解修饰一个类，<code>Lombok</code>会帮我们添加对应的<code>getter/setter</code>和<code>toString</code>。<br>更多关于 Lombok 的使用看以下笔记：<br><a target="_blank" rel="noopener" href="https://space-jiangsu.yuque.com/bcsfg9/ia5lzr/isn6ix9dwqfpsw31?view=doc_embed&inner=LIHSc">5. 常用三方库</a></p>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>日常开发中我们时常会遇到多表查询的需求，例如客户与订单的关系，一个客户有多个订单，一个订单只属于一个客户。客户与订单的详细信息分别存储在<code>customer</code>与<code>order</code>表中，我们想要在查询客户的时候把这个客户的所有订单信息都带上，或者查询订单的时候把这个订单所属的客户带上。这些都是多表查询的案例，下面我们将通过这个例子进行学习。</p>
<h4 id="实体类设计"><a href="#实体类设计" class="headerlink" title="实体类设计"></a>实体类设计</h4><p>显然我们需要设计两个实体类，分别是<code>Customer</code>与<code>Order</code>。<br>为了体现一个订单属于一个客户，我们在<code>Order</code>类中定义一个<code>Customer</code>类型的变量用来表示这个订单所属的客户：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> orderId;</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> customerId;  <span class="comment">// 数据库字段全要有，即使下面有了专门的客户字段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Customer customer;  <span class="comment">// 存储该订单的所属用户</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了体现一个客户有多个订单，我们在<code>Customer</code>类中定义一个<code>List&lt;Order&gt;</code>类型的变量用来表示这个客户拥有的多个订单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> customerId;</span><br><span class="line">    <span class="keyword">private</span> String customerName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orders;  <span class="comment">// 存储该用户的所有订单</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个小注意点，我们查询的时候不要“螺旋赋值”。举个例子，我们查询订单的时候需要把对应的客户也查到，但是这个客户里面的订单集合赋值为<code>null</code>即可；相应的我们查询客户的时候需要查找这个客户对应的所有订单，这些订单的所属客户也赋值为<code>null</code>就行了。</p>
<h4 id="对一关系查询"><a href="#对一关系查询" class="headerlink" title="对一关系查询"></a>对一关系查询</h4><p>我们想要按照 id 查询一个订单，并将这个订单的所属客户查出来。对应接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderMapper</span> &#123;</span><br><span class="line">    Order <span class="title function_">queryById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与之对应的 mapper 文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;orderMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;order&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;oid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;oname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;customer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM t_order tor JOIN t_customer tcr ON tor.cid = tcr.cid </span><br><span class="line">        WHERE tor.oid = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为数据表与实体类命名不统一，所以我们使用<code>resultMap</code>进行自定义映射。当存在层级映射（对象里面还有对象）的时候，我们使用<code>association</code>标签给内层对象映射，这个标签有两个属性：</p>
<ul>
<li><code>property</code>表示内层对象的名字；</li>
<li><code>javaType</code>表示内层对象的类型；</li>
</ul>
<p>标签内部也是使用<code>id/result</code>标签进行属性映射。</p>
<h4 id="对多关系查询"><a href="#对多关系查询" class="headerlink" title="对多关系查询"></a>对多关系查询</h4><p>我们想要查询所有存在订单的用户，并将这些用户的订单都查询出来。对应接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomerMapper</span> &#123;</span><br><span class="line">    List&lt;Customer&gt; <span class="title function_">queryAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与之对应的 mapper 文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;customerMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;customer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;order&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;oid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;oname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;customerMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM t_customer tcr JOIN t_order tor ON tcr.cid = tor.cid</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>集合的层级映射我们使用<code>collection</code>标签，这个标签有两个属性：</p>
<ul>
<li><code>property</code>表示内层集合的名称；</li>
<li><code>ofType</code>表示内层集合的泛型类型；</li>
</ul>
<p>标签内部仍然是使用<code>id/result</code>标签进行属性映射。</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>我们前面说过数据表字段名与实体类属性名是差不多的，只不过一个下划线命名，一个驼峰命名。为此我们可以在 MyBatis 核心配置文件里配置驼峰映射，但存在嵌套映射的情况下会出现以下情形：</p>
<ul>
<li>如果<code>resultMap</code>标签内只有<code>id</code>与<code>result</code>标签（单层映射），那么<code>result</code>标签在满足映射条件的情况下是可以不写的，MyBatis 会帮我们自动映射。映射条件指的是：<ol>
<li>数据表字段名与实体类属性名一致；</li>
<li>开启了驼峰映射，且两者确实满足驼峰映射；</li>
</ol>
</li>
<li>如果<code>resultMap</code>标签内部配置了<code>association</code>或<code>collection</code>标签（多层映射），那么 MyBatis 就不会帮我们自动映射了，开启驼峰映射也没用。</li>
</ul>
<p>此时如果想让 MyBatis 帮我们映射，而不用我们自己写映射标签怎么办呢？<br>可以在核心配置文件里配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;FULL&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样配置之后在满足映射条件的情况下，MyBatis 会帮我们自动映射，而且不论是单层还是多层都会映射。假设我们现在所有的字段都满足驼峰映射，开启配置之后我们的<code>resultMap</code>就可以定义如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;customerMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;customer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;order&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为字段名都满足驼峰映射，所以<code>result</code>标签都省略掉了。但是注意，配置主键的<code>id</code>标签不能省略。</p>
<h3 id="动态-sql"><a href="#动态-sql" class="headerlink" title="动态 sql"></a>动态 sql</h3><p>动态 sql 就是 sql 语句是根据条件自动生成的，而不是提前写好的。例如查询的时候，查询条件个数或内容根据前端的选择动态指定。</p>
<h4 id="if-标签"><a href="#if-标签" class="headerlink" title="if 标签"></a>if 标签</h4><p>假设我们想要查询学生信息，可以根据姓名、班级或者两者一起联合查询。我们定义的接口方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; <span class="title function_">queryStudent</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;clazz&quot;)</span> String clazz)</span>;</span><br></pre></td></tr></table></figure>
<p>方法需要两个参数分别表示学生姓名和班级，当参数不为<code>null</code>的时候才会作为查询条件。<br>这样的需求还是比较常见的，以往我们需要自己拼接字符串，现在可以直接定义如下 sql 语句：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryStudent&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM students WHERE</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">            stu_name = #&#123;name&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;clazz != null&quot;</span>&gt;</span></span><br><span class="line">            AND stu_class = #&#123;clazz&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这边使用<code>if</code>标签进行条件判断，只有<code>test</code>指定表达式返回<code>true</code>内部语句才会添加到 sql 语句之中，<code>test</code>里面不需要使用<code>#&#123;&#125;</code>之类的写法就可以直接访问方法的参数。可以看到使用<code>if</code>标签可以很简单的控制查询条件。</p>
<h4 id="where-标签"><a href="#where-标签" class="headerlink" title="where 标签"></a>where 标签</h4><p>仔细观察不难发现，上面使用<code>if</code>标签控制查询条件是有隐患的。例如：</p>
<ul>
<li>当传入的两个条件均为<code>null</code>时，我们的本意是查询全部学生，而生成的 sql 语句是<code>SELECT * FROM students WHERE</code>；</li>
<li>当传入的<code>name</code>为<code>null</code>，而<code>clazz</code>不为<code>null</code>时，生成的 sql 语句是<code>SELECT * FROM students WHERE AND stu_class = #&#123;clazz&#125;</code>；</li>
</ul>
<p>在这两种情况下，生成的 sql 语句是错误的。我们可以使用<code>where</code>标签：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryStudent&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM students</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">                stu_name = #&#123;name&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;clazz != null&quot;</span>&gt;</span></span><br><span class="line">                AND stu_class = #&#123;clazz&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>总结下来，<code>where</code>标签会做两件事：</p>
<ol>
<li>自动添加<code>WHERE</code>关键字；当<code>where</code>标签内部没有查询条件的时候就不在 sql 语句里面加<code>WHERE</code>，否则会自己加上<code>WHERE</code>关键字。</li>
<li>去除开头多余的<code>AND|OR</code>关键字；对应上面问题2，避免出现<code>SELECT * FROM students WHERE AND stu_class = #&#123;clazz&#125;</code>这样的情况。</li>
</ol>
<h4 id="set-标签"><a href="#set-标签" class="headerlink" title="set 标签"></a>set 标签</h4><p><code>set</code>标签的用法与上面的<code>where</code>类似，只不过<code>set</code>标签作用于更新语句中。接口方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">updateStudent</span><span class="params">(Student student)</span>;</span><br></pre></td></tr></table></figure>
<p>使用传递的学生对象更新数据库信息，主要根据 id 更新其它各字段。如果某个字段为<code>null</code>则不用更新，如果直接使用<code>if</code>标签控制如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateStudent&quot;</span>&gt;</span></span><br><span class="line">    UPDATE students SET</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;stuName != null&quot;</span>&gt;</span></span><br><span class="line">            stu_name = #&#123;stuName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;stuClass != null&quot;</span>&gt;</span></span><br><span class="line">            , stu_class = #&#123;stuClass&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    WHERE stu_id = #&#123;stuId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>问题与上面的<code>where</code>类似，会出现错误的 sql。此时可以使用<code>set</code>标签：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateStudent&quot;</span>&gt;</span></span><br><span class="line">    UPDATE students</span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;stuName != null&quot;</span>&gt;</span></span><br><span class="line">                stu_name = #&#123;stuName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;stuClass != null&quot;</span>&gt;</span></span><br><span class="line">                , stu_class = #&#123;stuClass&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    WHERE stu_id = #&#123;stuId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>总结下来，<code>set</code>标签的做事情主要有两点：</p>
<ol>
<li>自动添加<code>SET</code>关键字；这个功能比较鸡肋，因为在<code>UPDATE</code>语句里面必须有<code>SET</code>。</li>
<li>去除开头多余的<code>,</code>；仍然是对应第一个<code>if</code>为<code>null</code>，第二个不为<code>null</code>的情况。</li>
</ol>
<h4 id="trim-标签"><a href="#trim-标签" class="headerlink" title="trim 标签"></a>trim 标签</h4><p><code>trim</code>可以在一段 sql 前后添加某些内容，也可以删除一段 sql 前后的某些内容。它的主要属性：</p>
<ul>
<li><code>prefix </code>添加前缀属性；</li>
<li><code>suffix </code>添加后缀属性；</li>
<li><code>prefixOverrides </code>删除前缀属性；</li>
<li><code>suffixOverrides </code>删除后缀属性；</li>
</ul>
<h5 id="实现where"><a href="#实现where" class="headerlink" title="实现where"></a>实现<code>where</code></h5><p>我们可以使用<code>trim</code>实现<code>where</code>的功能，如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryStudent&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM students</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;WHERE&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;AND|OR&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">            stu_name = #&#123;name&#125; AND</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;clazz != null&quot;</span>&gt;</span></span><br><span class="line">            stu_class = #&#123;clazz&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这边使用的<code>trim</code>作用解读如下：</p>
<ul>
<li>如果<code>trim</code>标签内部存在 sql（至少有一个<code>if</code>判断通过） 则添加前缀<code>WHERE</code>；</li>
<li>如果<code>trim</code>标签内部存在 sql，则删除其后缀的<code>AND</code>或<code>OR</code>；</li>
</ul>
<h5 id="实现set"><a href="#实现set" class="headerlink" title="实现set"></a>实现<code>set</code></h5><p>我们可以使用<code>trim</code>实现<code>set</code>的功能，如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateStudent&quot;</span>&gt;</span></span><br><span class="line">    UPDATE students</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;stuName != null&quot;</span>&gt;</span></span><br><span class="line">            stu_name = #&#123;stuName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;stuClass != null&quot;</span>&gt;</span></span><br><span class="line">            , stu_class = #&#123;stuClass&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    WHERE stu_id = #&#123;stuId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这边使用的<code>trim</code>作用解读如下：</p>
<ul>
<li>如果<code>trim</code>标签内部存在 sql 则添加前缀<code>SET</code>；</li>
<li>如果<code>trim</code>标签内部存在 sql，则删除其前缀的<code>,</code>；</li>
</ul>
<h4 id="choose-标签"><a href="#choose-标签" class="headerlink" title="choose 标签"></a>choose 标签</h4><p><code>choose</code>标签主要用在有多个条件依次判定选择一个执行的情形，例如：我们传递一个姓名与班级，若姓名不为<code>null</code>则使用姓名查询，姓名为<code>null</code>而班级不为<code>null</code>则使用班级查询，否则查询所有学生。<br>我们可以写出下面的 mapper：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryStudentCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM students WHERE</span><br><span class="line">    <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">            stu_name = #&#123;name&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;clazz != null&quot;</span>&gt;</span></span><br><span class="line">            stu_class = #&#123;clazz&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            1=1</span><br><span class="line">        <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到我们使用了<code>choose</code>标签，内部包含若干个<code>when</code>标签以及一个<code>otherwise</code>标签。它会从上到下依次判别每一个<code>when</code>，<code>test</code>为<code>true</code>时就使用对应的语句，若没有满足条件的<code>test</code>就使用<code>otherwise</code>指定的语句。<br>要注意，当我们使用<code>choose</code>标签的时候，内部的若干个 sql 语句我们最多选择一个执行，所以不存在有多余的<code>AND|OR</code>的情形。</p>
<h4 id="foreach-标签"><a href="#foreach-标签" class="headerlink" title="foreach 标签"></a>foreach 标签</h4><p><code>foreach</code>标签主要用于循环生成字符串，它有以下几个重要属性：</p>
<ul>
<li><code>collection </code>指定用于循环的集合；</li>
<li><code>open</code>为生成的字符串指定一个前缀；</li>
<li><code>separator </code>指定每一项的分隔符；</li>
<li><code>close</code>为生成的字符串指定一个后缀；</li>
<li><code>item </code>指定循环过程中每一项的名称；</li>
</ul>
<p>使用<code>foreach</code>的主要场景就是批量增、删、改、查的场景。</p>
<h5 id="批量增"><a href="#批量增" class="headerlink" title="批量增"></a>批量增</h5><p>批量增加数据的 sql 可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (fields) <span class="keyword">VALUES</span> (v1), (v2)...</span><br></pre></td></tr></table></figure>
<p>定义的批量增加数据的接口方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">addBatch</span><span class="params">(<span class="meta">@Param(&quot;students&quot;)</span> List&lt;Student&gt; students)</span>;</span><br></pre></td></tr></table></figure>
<p>与之对应的 mapper 写成：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO students (stu_name, stu_class) VALUES</span><br><span class="line">    <span class="comment">&lt;!-- 循环生成“(value)”，每一项使用逗号分隔 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;students&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">item</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 循环变量被指定为 student，如果是对象可以使用“.”直接获取属性 --&gt;</span></span><br><span class="line">        (#&#123;student.stuName&#125;, #&#123;student.stuClass&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有一个小注意点，这边接口方法只定义了一个参数，但我们还是还有<code>@Param</code>注解指定参数名，那是因为如果不指定在<code>forearch</code>的<code>collection</code>属性中获取不到。</p>
<h5 id="批量删"><a href="#批量删" class="headerlink" title="批量删"></a>批量删</h5><p>根据数据 id 批量删除数据的 sql 可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (id1, id2, ...)</span><br></pre></td></tr></table></figure>
<p>定义的批量删除数据的接口方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deleteBatch</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> List&lt;Integer&gt; ids)</span>;</span><br></pre></td></tr></table></figure>
<p>与之对应的 mapper 写成：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteBatch&quot;</span>&gt;</span></span><br><span class="line">    DELETE FROM students WHERE stu_id IN</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这边我们使用了<code>open</code>与<code>close</code>属性来给生成的串加上<code>()</code>。</p>
<h5 id="批量改"><a href="#批量改" class="headerlink" title="批量改"></a>批量改</h5><p>批量修改数据没有对应的 sql 语法，只能通过使用多条<code>UPDATE</code>语句实现。定义的接口方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">updateBatch</span><span class="params">(<span class="meta">@Param(&quot;students&quot;)</span> List&lt;Student&gt; students)</span>;</span><br></pre></td></tr></table></figure>
<p>与之对应的 mapper 写成：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateBatch&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;students&quot;</span> <span class="attr">item</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        UPDATE students SET</span><br><span class="line">            stu_name = #&#123;student.stuName&#125;, stu_class = #&#123;student.stuClass&#125;</span><br><span class="line">            WHERE stu_id = #&#123;student.stuId&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到我们使用<code>foreach</code>将整个<code>UPDATE</code>语句包起来了，需要注意语句后面的<code>;</code>。</p>
<h5 id="批量查"><a href="#批量查" class="headerlink" title="批量查"></a>批量查</h5><p>根据数据 id 批量查询数据的 sql 可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (id1, id2...)</span><br></pre></td></tr></table></figure>
<p>定义的批量查询数据的接口方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; <span class="title function_">queryBatch</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> List&lt;Integer&gt; ids)</span>;</span><br></pre></td></tr></table></figure>
<p>与之对应的 mapper 写成：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBatch&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM students WHERE stu_id IN</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="sql-抽取"><a href="#sql-抽取" class="headerlink" title="sql 抽取"></a>sql 抽取</h4><p>sql 抽取是指对于一些常用的 sql 片段，我们可以将其单独定义出来，然后在使用的地方导入进去。这本质上就是字符串的拼接，定义 sql 片段使用<code>sql</code>标签，如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用 id 属性为此片段命名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectSql&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM students</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们可以在需要的地方使用<code>include</code>标签引入这段 sql，如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectSql&quot;</span>/&gt;</span> WHERE stu_id=#&#123;xx&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>include</code>标签里面使用<code>refid</code>属性指定使用哪一个 sql 片段。不同的 mapper 文件之间是隔离的，可以起相同名字的片段。</p>
<h3 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h3><h4 id="按包扫描-mapper"><a href="#按包扫描-mapper" class="headerlink" title="按包扫描 mapper"></a>按包扫描 mapper</h4><p>之前我们每创建一个新的 mapper 都需要将其配置在核心配置文件中，比较麻烦。现在我们可以按照包一次性配置，就很方便。我们只需要在核心配置文件的<code>mappers</code>标签中声明<code>package</code>标签：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.luyan.mappers&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是这么做需要几个强制约定：</p>
<ol>
<li>接口类与其对应的 mapper 文件必须同名。例如<code>UserMapper.java</code>对应的 mapper 文件必须命名为<code>UserMapper.xml</code>；</li>
<li>mapper 文件在<code>resources</code>目录下的结构必须与接口类的目录结构一致。例如接口类都定义在<code>com/luyan/mappers</code>目录下，那么对应的 mapper 文件必须定义在<code>resources/com/luyan/mappers</code>目录下；</li>
</ol>
<p>有一个小注意点，我们在创建包的时候可以使用<code>com.luyan.mappers</code>形式简写多层结构，但是在创建目录的时候若还使用这样的写法只会认为有一个目录的名字叫<code>com.luyan.mappers</code>。因此我们在创建多层目录的时候要么一层一层创建，要么使用<code>com/luyan/mappers</code>形式创建。</p>
<h4 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h4><p>日常开发中分页是很常用的一个功能，往常我们需要通过在 sql 语句中使用<code>LIMIT</code>关键字限制查询的结果来达到分页的目的。现在我们可以使用 MyBatis 的分页插件来做分页。</p>
<h5 id="导包-2"><a href="#导包-2" class="headerlink" title="导包"></a>导包</h5><p>首先我们需要导入分页插件的包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h5><p>导完包之后，我们需要在核心配置文件里面注册这个插件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;helperDialect&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意<code>plugins</code>标签的定义位置，因为 MyBatis 核心配置文件中各个标签的位置是有先后顺序的。</p>
<h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><p>我们只需要正常调用方法，并配置一些页码信息即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先设置分页的信息，即查询第几页、一页有多少条数据</span></span><br><span class="line">PageHelper.startPage(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 正常调用查询方法</span></span><br><span class="line">List&lt;Student&gt; students = mapper.queryAll();</span><br></pre></td></tr></table></figure>
<p>查询方法的定义、mapper 的书写与以前没有任何区别。我们不需要在 sql 语句里面写<code>LIMIT</code>关键字，这些插件都会帮我们做，但是定义的 sql 语句不能使用<code>;</code>结尾。<br>如果我想知道查询的一些信息，例如一共有多少条记录，可以将查询的结果包装成<code>PageInfo</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将查询结果包装成 PageInfo</span></span><br><span class="line">PageInfo&lt;Student&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(students);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取查询的数据</span></span><br><span class="line">List&lt;Student&gt; list = pageInfo.getList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取记录总条数</span></span><br><span class="line"><span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> pageInfo.getTotal();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取总页数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">pages</span> <span class="operator">=</span> pageInfo.getPages();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前页码，从 1 开始</span></span><br><span class="line"><span class="type">int</span> <span class="variable">pageNum</span> <span class="operator">=</span> pageInfo.getPageNum();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取页容量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">pageSize</span> <span class="operator">=</span> pageInfo.getPageSize();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回是否有下一页</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasNextPage</span> <span class="operator">=</span> pageInfo.isHasNextPage();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回是否有上一页</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasPreviousPage</span> <span class="operator">=</span> pageInfo.isHasPreviousPage();</span><br></pre></td></tr></table></figure>
<p>对于使用有几个小注意点：</p>
<ol>
<li>在<code>PageHelper.startPage(3, 2);</code>与<code>PageInfo&lt;Student&gt; pageInfo = new PageInfo&lt;&gt;(students);</code>之间只能有一条查询语句。不然不知道为哪一个查询分页。</li>
<li>使用插件之后返回的数据类型是<code>class com.github.pagehelper.Page</code>，它是<code>ArrayList</code>的子类，因此使用<code>List&lt;&gt;</code>接收完全没有问题。</li>
</ol>
<h4 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h4><p>所谓逆向功能就是将 MyBatis 从半自动 ORM 框架迈进到全自动 ORM 框架，简而言之就是对于单表操作使用 IDEA 插件生成增删改查代码，节省我们精力。</p>
<ol>
<li>安装 IDEA 插件<code>MyBatisX</code>：</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1712502227084-b597ffd7-fbe0-4fee-aacc-8239445bc5b6.png#averageHue=%23f7f7f6&clientId=u8ee06aa7-8e6b-4&from=paste&height=77&id=uf1485a09&originHeight=85&originWidth=330&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=4233&status=done&style=none&taskId=ufa4108b2-5bf7-4a33-8d49-a6f6067a9b5&title=&width=299.99999349767523" alt="image.png"></p>
<ol start="2">
<li>使用 IDEA 自带的数据库组件连接数据库：</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1712562048870-6d1b22ec-502a-4641-8e18-1ef5120ada99.png#averageHue=%23f2f2f2&clientId=uee674009-ee82-4&from=paste&height=256&id=u6cafdf2b&originHeight=256&originWidth=878&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24222&status=done&style=none&taskId=ucac999da-68e9-47ad-9b56-f1b7ebe448a&title=&width=878" alt="image.png"></p>
<ol start="3">
<li>选中需要生成的表右键点击<code>MybatisX-Generator</code>：</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1712562173081-8743dde7-d928-4e62-b219-61b94e610952.png#averageHue=%23f2f2f2&clientId=uee674009-ee82-4&from=paste&height=466&id=ueffb58fb&originHeight=466&originWidth=930&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49049&status=done&style=none&taskId=u19758d8a-45ef-4d38-aadf-8d70c79059b&title=&width=930" alt="image.png"><br>点击<code>finish</code>之后，插件会帮我们根据表生成实体类、数据接口、mapper 文件。生成这些文件之后我们一般会选择需要的部分粘贴复制进行使用，所以逆向工程说白了就是让插件生成一些单表操作的代码。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/03/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/07/03/Spring/" itemprop="url">Spring</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-07-03T17:33:49+08:00">
                2023-07-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Spring 是一个支持快速开发 JavaEE 应用程序的框架。它提供了一系列底层容器和基础设施，并可以和大量常用的开源框架无缝集成，可以说是开发 JavaEE 应用程序的必备。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>Spring 容器是 Spring 框架的核心，是用来管理对象的。容器负责创建对象、配置对象，并管理对象的整个生命周期（从创建到销毁）。<br>Spring 中常见的容器实现类：</p>
<table>
<thead>
<tr>
<th><code>ClassPathXmlApplicationContext</code></th>
<th>通过读取类路径下的 xml 配置文件创建 IoC 容器对象。</th>
</tr>
</thead>
<tbody><tr>
<td><code>FileSystemApplicationContext</code></td>
<td>通过读取文件路径下的 xml 配置文件创建 IoC 容器对象。</td>
</tr>
<tr>
<td><code>AnnotationConfigApplicationContext</code></td>
<td>通过读取 Java 配置类创建 IoC 容器对象。</td>
</tr>
<tr>
<td><code>WebApplicationContext</code></td>
<td>专门为 Web 应用准备，基于 Web 环境创建 IoC 容器对象，并将对象引用存到 ServletContext 域中。</td>
</tr>
</tbody></table>
<p>实际开发中我们用<code>AnnotationConfigApplicationContext</code>和<code>WebApplicationContext</code>比较多。</p>
<h3 id="Ioc-DI"><a href="#Ioc-DI" class="headerlink" title="Ioc &amp; DI"></a>Ioc &amp; DI</h3><h4 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h4><p><strong>loC</strong>（Inversion of Control）即控制反转主要是针对对象的创建和调用控制而言的，也就是说，当应用程序需要使用一个对象时，不再是应用程序直接创建该对象，而是由 loC 容器来创建和管理，即控制由应用程序转移到 IoC 容器中，也就是“反转”了控制权。这种方式基本上是通过依赖查找的方式来实现的，即 loC 容器维护着构成应用程序的对象，并负责创建这些对象。</p>
<h4 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h4><p><strong>DI</strong>（Dependency Injection）即依赖注入是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在 Spring 中，Dl 是通过 XML 配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter 方法注入和接口注入。</p>
<h3 id="xml-配置"><a href="#xml-配置" class="headerlink" title="xml 配置"></a>xml 配置</h3><h4 id="创建-xml-文件"><a href="#创建-xml-文件" class="headerlink" title="创建 xml 文件"></a>创建 xml 文件</h4><p>在进行 xml 配置前我们需要先导包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>首先我们需要创建 xml 文件，一般我们在<code>src/main/resources</code>目录下创建 xml 文件。由于要导必要的约束，因此我们不是直接创建 xml 文件，而是如下图：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1710146296457-b9b1f369-8c25-4bc3-800b-52537f1b3d1e.png#averageHue=%23d9d9d9&clientId=uc976bca4-ef67-4&from=paste&height=673&id=u2189f932&originHeight=673&originWidth=738&originalType=binary&ratio=1&rotation=0&showTitle=false&size=142430&status=done&style=none&taskId=u4fbadd61-fc29-40b3-b512-ff50e67ade2&title=&width=738" alt="image.png"><br>创建出来的 xml 格式如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="配置普通对象"><a href="#配置普通对象" class="headerlink" title="配置普通对象"></a>配置普通对象</h4><p>我们想要将某些类的创建等操作交给 Spring 容器，最简单的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testBean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.luyan.TestBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用<code>bean</code>标签表示一个对象，<code>id</code>属性是这个对象的唯一标识，<code>class</code>属性指定这个类的全限定名。<br>当我们获取 id 为 testBean1 的对象时相当于执行了<code>new com.luyan.TestBean()</code>。<br>但是要<strong>注意</strong>：这样配置的对象，默认是单例模式即每次从 Spring 容器中获取的对象都是同一个对象。</p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>我们正常开发中有些对象是通过工厂模式创建的，工厂模式分为静态工厂和非静态工厂。</p>
<h5 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h5><p>对于静态工厂，对象是通过静态方法返回的，我们可以如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testBean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.luyan.StaticFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getTestBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>id</code>指定对象的唯一标识，<code>class</code>指定静态工厂类，<code>factory-method</code>指定使用工厂类的哪一个静态方法。当我们获取<code>id</code>为 testBean2 的对象时相当于执行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.luyan.StaticFactory.getTestBean()</span><br></pre></td></tr></table></figure>
<h5 id="非静态工厂"><a href="#非静态工厂" class="headerlink" title="非静态工厂"></a>非静态工厂</h5><p>对于非静态工厂，我们需要先实例化工厂对象，然后调用工厂对象的实例方法返回我们需要的对象。因此我们配置的时候需要分两步：</p>
<ul>
<li>将工厂对象配置到 xml 文件中；</li>
<li>使用配置好的工厂对象配置我们需要的对象；<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置工厂类，id 指定为 nsFactory --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;nsFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.luyan.NoneStaticFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testBean3&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;nsFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getTestBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
配置对象的时候使用<code>factory-bean</code>属性指定工厂类的<code>id</code>，<code>factory-method</code>属性指定调用哪一个非静态方法。这样当我们获取<code>id</code>为 testBean3 的对象时相当于执行了：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">com</span>.luyan.NoneStaticFactory().getTestBean()</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><h5 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h5><p>上面的配置都是很简单的配置，没有注入依赖。所谓注入依赖就是传递对象需要的各种参数，如果一个类没有无参构造，那么使用上面的方法配置对象是会报错的。因此这种情况下我们就需要注入依赖，参数可以通过构造方法或对应的<code>Setter</code>指定。假设我们有下面的类定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(String name, <span class="type">int</span> age, UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h5><p>我们现在想把<code>UserService</code>配置到 xml 里面，首先我们肯定需要先把<code>UserDao</code>配置到里面，因为注入的数据也必须受 Spring 管控；其次我们发现<code>UserService</code>没有无参构造，所以我们需要配置构造参数：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 UserDao --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.luyan.UserDao&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置 UserService --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.luyan.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们在<code>UserService</code>的<code>bean</code>标签内部使用<code>constructor-arg</code>标签配置构造参数，<code>value</code>和<code>ref</code>属性都是为了配置参数，<code>value</code>属性用来配置字面量，<code>ref</code>属性用来配置 Spring 里面<code>bean</code>的<code>id</code>。<br>默认情况下配置的构造参数是按照定义的顺序依次配置的，但我们可以使用<code>name</code>或<code>index</code>属性指定具体的参数。<code>name</code>属性里面填写要配置的参数名，<code>index</code>属性里面填写要配置参数的下标（从 0 开始）。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用 index 属性指定参数下标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.luyan.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用 name 属性指定参数名字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.luyan.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面三种配置<code>UserService</code>的方法都相当于执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">com</span>.luyan.UserService(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="keyword">new</span> <span class="title class_">com</span>.luyan.UserDao())</span><br></pre></td></tr></table></figure>
<h5 id="Setter-注入"><a href="#Setter-注入" class="headerlink" title="Setter 注入"></a>Setter 注入</h5><p>我们给对象里面某个变量赋值还可以使用 Setter 注入，Setter 注入就是调用变量对应的 set 方法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.luyan.UserService&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们使用<code>property</code>标签进行 Setter 注入，<code>name</code>属性指定要注入的变量名，<code>value/ref</code>属性指定注入的值。<strong>注意：</strong>Setter 注入并不能绕过构造方法，所以要保证构造参数是齐全的。</p>
<h4 id="获取对象"><a href="#获取对象" class="headerlink" title="获取对象"></a>获取对象</h4><p>我们想要获取配置的对象，首先需要创建 Spring 容器。容器有好几种，我们常用的是<code>ClassPathXmlApplicationContext</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Spring 容器并传入配置名称</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(</span><br><span class="line">        <span class="string">&quot;spring_01.xml&quot;</span>);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService1</span> <span class="operator">=</span> (UserService) applicationContext.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService2</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService3</span> <span class="operator">=</span> applicationContext.getBean(UserService.class);</span><br></pre></td></tr></table></figure>
<p>我们获取对象的时候使用容器的<code>getBean</code>方法，这个方法有三种重载：</p>
<ul>
<li>直接传入一个<code>bean</code>的<code>id</code>，返回一个<code>Object</code>，需要我们手动强转成对应的类型；</li>
<li>传入<code>bean id</code>的同时再传入一个<code>.class</code>表示返回对象的类型，这就不需要强转了；</li>
<li>直接传一个<code>.class</code>，由容器自己寻找合适的<code>bean</code>并返回对象给我们，这种方法有个注意点：<ul>
<li>配置文件中<code>class</code>属性为此类型的<code>bean</code>只能有一个，不然会报错；</li>
</ul>
</li>
</ul>
<p>一些其他注意事项：</p>
<ul>
<li><code>ClassPathXmlApplicationContext</code>的构造方法里面可以传多个配置文件名；</li>
<li>使用<code>getBean</code>时，传入的类型可以是对象的接口类型。</li>
</ul>
<h4 id="周期-作用域"><a href="#周期-作用域" class="headerlink" title="周期 &amp; 作用域"></a>周期 &amp; 作用域</h4><h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><p>交由 Spring 容器管理的对象可以配置生命周期方法，主要有两个周期方法：</p>
<ul>
<li>创建时调用的周期方法；</li>
<li>销毁时调用的周期方法；</li>
</ul>
<p>这两个方法必须使用<code>public void</code>修饰且没有参数，方法名不重要。配置文件中我们可以使用<code>bean</code>标签里面的<code>init-method</code>和<code>destroy-method</code>属性来指定两个周期方法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.luyan.UserDao&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个两个周期方法调用的时机与这个对象的作用域有关，下面我们详细看看。</p>
<h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>作用域主要描述对象在什么范围内有效，我们可以通过<code>bean</code>标签的<code>scope</code>属性来指定。<code>scope</code>属性主要有两个值可选：</p>
<table>
<thead>
<tr>
<th><strong>取值</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>singleton</code></td>
<td>单实例，<strong>默认值</strong></td>
</tr>
<tr>
<td><code>prototype</code></td>
<td>多实例，每次获取的对象都是一个全新的对象</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>Spring 容器启动的时候会创建所有配置的对象到容器中，后面单例模式的对象都是共享的一个，而多例对象每次获取都会重新创建新的。单例对象随着容器的销毁（调用<code>application.close()</code>）而销毁，而多例对象的销毁由用户自己管理，不受容器管控。<br>在<code>WebApplicationContext</code>环境下还有两个值可选（但不常用）：</p>
<table>
<thead>
<tr>
<th><strong>取值</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>request</code></td>
<td>请求范围内有效的实例</td>
</tr>
<tr>
<td><code>session</code></td>
<td>会话范围内有效的实例</td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单例对象，因为是默认值，所以此时可以不指定 scope 属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.luyan.UserDao&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 多例对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.luyan.UserDao&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="标准工厂"><a href="#标准工厂" class="headerlink" title="标准工厂"></a>标准工厂</h4><p>上面我们介绍过两种工厂的配置方法，下面我们介绍一下标准工厂的配置。主要步骤可以分为：</p>
<ol>
<li>创建工厂类实现<code>FactoryBean</code>接口；</li>
<li>实现接口里面必要的方法；</li>
<li>将工厂类配置到 xml 文件里；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> User.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>FactoryBean</code>接口主要有三个方法：</li>
</ol>
<ul>
<li><code>getObject</code>方法书写创建对象的代码；</li>
<li><code>getObjectType</code>方法返回要创建对象的类型；</li>
<li><code>isSingleton</code>方法返回创建的对象是否单例，这个方法默认实现是返回<code>true</code>。</li>
</ul>
<p>接下来我们将工厂配置到 xml 文件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.luyan.UserFactoryBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>class</code>属性填写工厂的全限定符，因为获取这个<code>bean</code>的时候返回的是实体类，所以我们将这边的<code>id</code>属性指定为<code>user</code>。<br>从本质上讲，这种方式就是非静态工厂创建对象的方法。因此实际上工厂对象也是存在于容器中的，对应的工厂类对象可以使用<code>id</code>为<code>&amp;user</code>获取（就是在实体类的<code>id</code>前面加上<code>&amp;</code>）。<br>如果我们想创建对象的时候，有些信息能够通过配置获取，应该怎么做？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(userName);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> User.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.luyan.UserFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们的实现思路是通过 Setter 给工厂类传递参数，然后<code>getObject</code>方法直接访问这个变量即可。</p>
<h4 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h4><p>开发时有些数据是配置在<code>properties</code>文件里面的，我们的 xml 可以读取这些数据。</p>
<ul>
<li>首先我们在<code>main/resources</code>目录下创建<code>properties</code>文件；</li>
<li>按照下面的方式配置并读取<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置要读取的属性文件路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:data.properties&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.luyan.UserFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过 $&#123;属性名&#125; 获取对应的属性值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
我们在获取的时候可能获取不到配置的属性，此时我们可以<code>$&#123;name:默认值&#125;</code>添加默认值。</li>
</ul>
<h3 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h3><h4 id="Spring-bean"><a href="#Spring-bean" class="headerlink" title="Spring bean"></a>Spring bean</h4><p>实际开发中我们使用注解配置会更多一点，Spring bean 的配置主要有以下几种：</p>
<table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>@Component </code></td>
<td>用来标识 Spring bean，标注之后这个类就由 Spring 管控。</td>
</tr>
<tr>
<td><code>@Repository </code></td>
<td>功能与<code>@Component</code>一样，主要用于 DAO 层的标注。</td>
</tr>
<tr>
<td><code>@Service </code></td>
<td>功能与<code>@Component</code>一样，主要用于 Service 层的标注。</td>
</tr>
<tr>
<td><code>@Controller </code></td>
<td>功能与<code>@Component</code>一样，主要用于 Controller 层的标注。</td>
</tr>
</tbody></table>
<p>这四种注解其实都是等价的，只不过为了更好的代码可读性人为的起了四个名字。因为这些注解都是为了标注 Spring bean 的，所以这些注解只能有用类上，不能用于方法上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span>  <span class="comment">// 因为是 DAO 层，所以我们使用 Repository 进行注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用这些注解之后，还需要将包配置在 xml 里面这些注解才会生效。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.luyan&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>base-package</code>属性用来配置 Spring 扫描的根包，这个包下面的所有子包都会参与扫描。没有参与扫描的包下的注解类是不会被 Spring 管控的。<br>有时我们会排除掉某些注解，不让 Spring 扫描它。我们可以：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.luyan&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Service&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种写法是指我们会扫描<code>com.luyan</code>包下所有的非<code>@Service</code>注解。<br>有指定不包含的，就有指定包含的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.luyan&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Service&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这么写是指只扫描<code>com.luyan</code>包下<code>@Service</code>注解，记得把<code>use-default-filters</code>属性置为<code>false</code>。<br>我们使用注解将类配置到容器之后，<code>id</code>属性默认是类名的首字母小写。例如<code>UserDao</code>使用注解配置之后，在容器里的<code>id</code>默认为<code>userDao</code>。当然我们可以在注解里面传参数修改这个值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;UD&quot;)</span>  <span class="comment">// 将这个类 id 命名为 UD</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="周期-作用域-1"><a href="#周期-作用域-1" class="headerlink" title="周期 &amp; 作用域"></a>周期 &amp; 作用域</h4><p>之前我们讲过使用 xml 配置初始化和销毁方法，我们现在看看注解的配置方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@PostConstruct</code>表示初始化注解，<code>@PreDestroy</code>表示销毁注解。这两个方法的定义还是需要满足<code>public void</code>修饰、无参这两个条件。触发的时机也和上面 xml 的配置是一样的。<br>关于<code>scope</code>的配置也使用注解，看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难理解，一个是单例，一个是多例，其中单例是默认值。<code>Scope</code>注解即可以放在类上，也可以放在方法上（用于方法上主要为了配置工厂方法）。</p>
<h4 id="依赖注入-1"><a href="#依赖注入-1" class="headerlink" title="依赖注入"></a>依赖注入</h4><h5 id="引用类型注入"><a href="#引用类型注入" class="headerlink" title="引用类型注入"></a>引用类型注入</h5><p>引用类型注入主要使用<code>@Autowired</code>注解，这个注解可以写在字段上、Setter 上、构造上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以将<code>Autowired</code>翻译成自动装配，装配的时候有以下几种情况（以这边的代码举例）：</p>
<ul>
<li>如果容器里没有这个类型的对象，则装配失败，报错；</li>
<li>如果容器里有唯一的<code>UserDao</code>类型的对象，则使用这个对象进行装配；</li>
<li>如果容器里有多个<code>UserDao</code>类型的对象，则会使用定义的变量名作为<code>id</code>寻找对象。</li>
</ul>
<p>有多个对象的时候的，我们可以使用<code>@Qualifier(&quot;userDao&quot;) </code>注解来指定装配对象的<code>id</code>，<code>@Qualifier</code>注解一定要和<code>@Autowired</code>注解配合使用。<br>我们将注解放到 Setter 上，代码就变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;userDao&quot;)</span>  <span class="comment">// 指定要装配对象的 id</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Setter 上面加注解，会在创建对象的时候将数据注入到 Setter 的形参里面。<br>除此之外，我们还可以使用<code>@Resource</code>注解来替代<code>@Autowired+@Qualifier</code>的组合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource(name = &quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边我们将注解放到构造方法上面，创建对象的时候会将数据注入到构造形参里。<br>但是注意，使用<code>@Resource</code>注解需要导额外的包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="值类型注入"><a href="#值类型注入" class="headerlink" title="值类型注入"></a>值类型注入</h5><p>对于值类型的注入，我们可以使用<code>@Value</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;张三&quot;)</span></span><br><span class="line">    String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;19&quot;)</span>  <span class="comment">// 注意：注解内部需要的是字符串</span></span><br><span class="line">    <span class="type">int</span> gae;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只是这样用，还不如直接使用<code>int age = 19</code>这样的写法直接赋值，<code>@Value</code>注解主要用于从配置文件获取数据注入的场景。和使用 xml 类似，我们需要先将<code>properties</code>文件的路径配置到 xml 文件中，然后直接使用<code>$&#123;&#125;</code>来获取。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 properties 文件路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:data.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;username&#125;&quot;)</span>  <span class="comment">// 使用小脚本直接获取配置文件的内容</span></span><br><span class="line">    String username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><p>目前为止，我们学了如何使用注解配置 Spring。但还是没有完全摆脱 xml 文件，例如：</p>
<ul>
<li>我们需要使用 xml 配置扫描包，不然注解无法生效；</li>
<li>我们需要使用 xml 导入<code>properties</code>文件，否则无法使用小脚本；</li>
<li>对于三方库的类，我们无法使用注解配置它们；</li>
</ul>
<p>为了解决这些问题，Spring 支持我们创建配置类来完全摆脱 xml。</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;classpath:data.properties&quot;)</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.luyan&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们创建了一个类<code>JavaConfiguration</code>，我们习惯上把这个类放到<code>config</code>包下。我们为这个类添加了三个注解：</p>
<ul>
<li><code>@Configuration</code>注解表示将当前类作为配置类；</li>
<li><code>@ComponentScan</code>注解用来指定扫描的包，当需要指定多个包时可以传<code>&#123;&quot;package1&quot;, &quot;package2&quot;&#125;</code>，实际上就是给一个字符串数组赋值；</li>
<li><code>@PropertySource</code>注解用来指定配置文件，当需要指定多个配置文件时可以传<code>&#123;&quot;path1&quot;, &quot;path2&quot;&#125;</code>，也是给一个字符串数组赋值；</li>
</ul>
<p>当然我们光创建配置类是没有用的，我们需要在创建 Spring 容器的时候指定配置类才行。我们这边创建<code>AnnotationConfigApplicationContext</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> </span><br><span class="line">    <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(JavaConfiguration.class);</span><br></pre></td></tr></table></figure>
<h4 id="配置三方类对象"><a href="#配置三方类对象" class="headerlink" title="配置三方类对象"></a>配置三方类对象</h4><h5 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h5><p>下面看看如何配置三方库里面的对象，假设我们有一个三方库的类<code>ThirdPart</code>，我们可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&quot;com.luyan&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ThirdPart <span class="title function_">thirdPart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThirdPart</span> <span class="variable">thirdPart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThirdPart</span>();</span><br><span class="line">        thirdPart.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        thirdPart.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> thirdPart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们主要需要在配置类里面写一个配置方法，这个方法有以下注意点：</p>
<ul>
<li>方法必须被<code>@Bean</code>注解；</li>
<li>方法返回值指定为你需要配置的对象的类型；</li>
<li>方法名默认会作为这个对象在容器里的<code>id</code>；</li>
</ul>
<p>我们只需要在这个方法里面写创建对象的过程，并将创建的对象返回即可。</p>
<h5 id="修改-bean-id"><a href="#修改-bean-id" class="headerlink" title="修改 bean id"></a>修改 bean id</h5><p>上面我们说默认会使用方法名作为该对象在容器里的<code>id</code>，我们可以通过修改<code>@Bean</code>注解里面的<code>name/value</code>属性修改其<code>id</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;anotherId&quot;)</span></span><br><span class="line"><span class="comment">// @Bean(name = &quot;anotherId&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ThirdPart <span class="title function_">thirdPart</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="周期方法"><a href="#周期方法" class="headerlink" title="周期方法"></a>周期方法</h5><p>如果我们想给三方库的对象添加初始化与销毁方法，可以指定<code>@Bean</code>注解里面的<code>initMethod</code>和<code>destroyMethod</code>属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(value = &quot;thirdId&quot;, initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ThirdPart <span class="title function_">thirdPart</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要在<code>initMethod</code>和<code>destroyMethod</code>属性里面填写对应的方法名即可，周期方法的定义要求与之前是一样。</p>
<h5 id="作用域-1"><a href="#作用域-1" class="headerlink" title="作用域"></a>作用域</h5><p>如果我们想给三方对象设置单例还是多例，可以在方法上加一个<code>@Scope</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span>  <span class="comment">// 多例</span></span><br><span class="line"><span class="meta">@Bean(value = &quot;thirdId&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ThirdPart <span class="title function_">thirdPart</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="基础类型注入"><a href="#基础类型注入" class="headerlink" title="基础类型注入"></a>基础类型注入</h5><p>很多时候我们创建三方对象的时候，需要注入一些数据进去。我们先看看基本数据类型的注入，一种方式是直接写数据的字面量就像上面使用的<code>thirdPart.setUsername(&quot;root&quot;)</code>；如果要注入的数据存在于<code>properties</code>文件里面，此时如何注入呢？<br>一种解决方案如下，定义类变量并使用<code>@Value</code>将属性注入进去，然后在方法里面访问变量的值即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;classpath:data.properties&quot;)</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.luyan&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ThirdPart <span class="title function_">thirdPart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThirdPart</span> <span class="variable">thirdPart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThirdPart</span>();</span><br><span class="line">        thirdPart.setUsername(username);</span><br><span class="line">        thirdPart.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> thirdPart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方案是直接对参数做<code>@Value</code>注解，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ThirdPart <span class="title function_">thirdPart</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@Value(&quot;$&#123;username&#125;&quot;)</span> String username, </span></span><br><span class="line"><span class="params">        <span class="meta">@Value(&quot;$&#123;password&#125;&quot;)</span> String password)</span> &#123;</span><br><span class="line">    <span class="type">ThirdPart</span> <span class="variable">thirdPart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThirdPart</span>();</span><br><span class="line">    thirdPart.setUsername(username);</span><br><span class="line">    thirdPart.setPassword(password);</span><br><span class="line">    <span class="keyword">return</span> thirdPart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两种方法都可以实现读取<code>properties</code>文件，一般情况下数据需要被多个方法共享的，使用定义变量的方式，如果数据只有某个方法需要那就直接使用参数注入的方式。</p>
<h5 id="引用类型注入-1"><a href="#引用类型注入-1" class="headerlink" title="引用类型注入"></a>引用类型注入</h5><p>引用类型数据的注入，有两种方式：</p>
<ol>
<li><p>当数据也是在 Java 配置类里面使用<code>@Bean</code>注解的时候，我们可以直接调用对应的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ThirdPart <span class="title function_">thirdPart</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@Value(&quot;$&#123;username&#125;&quot;)</span> String username,</span></span><br><span class="line"><span class="params">        <span class="meta">@Value(&quot;$&#123;password&#125;&quot;)</span> String password)</span> &#123;</span><br><span class="line">    <span class="type">ThirdPart</span> <span class="variable">thirdPart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThirdPart</span>();</span><br><span class="line">    thirdPart.setUsername(username);</span><br><span class="line">    thirdPart.setPassword(password);</span><br><span class="line">    <span class="keyword">return</span> thirdPart;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ThirdService <span class="title function_">thirdService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThirdService</span> <span class="variable">thirdService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThirdService</span>();</span><br><span class="line">    <span class="comment">// 需要一个 ThirdPart，直接调用上面的方法获取</span></span><br><span class="line">    <span class="comment">// 需要参数的话随便写，反正上面的参数是注入进去的与实参无关</span></span><br><span class="line">    thirdService.setContent(thirdPart(<span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line">    <span class="keyword">return</span> thirdService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据不是在 Java 配置类里面定义的，那我们直接通过参数注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ThirdService <span class="title function_">thirdService</span><span class="params">(ThirdPart thirdPart)</span> &#123;</span><br><span class="line">    <span class="type">ThirdService</span> <span class="variable">thirdService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThirdService</span>();</span><br><span class="line">    thirdService.setContent(thirdPart);</span><br><span class="line">    <span class="keyword">return</span> thirdService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边只是定义了一个形参<code>thirdPart</code>，其它什么都没做。但是容器在创建<code>ThirdService</code>对象时会自己进行依赖注入，注入时：</p>
<ul>
<li>若容器里没有<code>ThirdPart</code>对象，会报错；</li>
<li>有唯一的<code>ThirdPart</code>对象，会使用这个对象进行注入；</li>
<li>有多个<code>ThirdPart</code>对象，会将形参作为<code>id</code>寻找对应的对象，找不到会报错；</li>
</ul>
</li>
</ol>
<p>第二种方式是推荐的写法！</p>
<h4 id="多个配置类整合"><a href="#多个配置类整合" class="headerlink" title="多个配置类整合"></a>多个配置类整合</h4><p>当我们项目里面定义的配置类比较多的时候，一种方式是创建容器的时候导入多个配置类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(</span><br><span class="line">    JavaConfigurationA.class, JavaConfigurationB.class);</span><br></pre></td></tr></table></figure>
<p>有多少个配置类就需要在构造方法里面引入多少个配置类，写法比较臃肿。<br>第二个做法是使用<code>@Import</code>注解将多个配置类整合成一个，然后创建容器的时候导入那一个就行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有多少就导多少</span></span><br><span class="line"><span class="meta">@Import(&#123;JavaConfigurationA.class, JavaConfigurationB.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整合测试"><a href="#整合测试" class="headerlink" title="整合测试"></a>整合测试</h3><p>我们写单元测试的时候，第一件事就是创建容器，很烦。于是就有了专门整合 Spring 测试的包，首先导包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之后创建测试类、编写测试方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(JavaConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThirdService thirdService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(thirdService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本上和之前没有区别，不过多了<code>@SpringJUnitConfig(JavaConfiguration.class)</code>。这个注解表示框架会自己帮我们使用<code>JavaConfiguration</code>配置类创建一个容器，后面就可以直接按照 Spring 的写法进行依赖注入，简化测试代码的书写。<br>框架除了能根据配置类创建容器，还可以根据 xml 文件创建容器，不过注解要改成<code>@SpringJUnitConfig(location=&quot;classpath:data.properties&quot;)</code>。</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP 是面向切面编程，一般的应用场景是在某些方法执行前、执行后、出异常等情况下做一些特殊的处理。例如某些方法只有登录用户才能访问，这就需要在方法执行前做一个验证；再如某些方法在执行的各个阶段需要使用日志记录某些信息。在这些情况下，日志也好、权限验证也罢，这部分代码都是通用的，在每个方法里面写一遍就很冗余，于是出现了面向切面编程。</p>
<h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><p>我们的需求是写一个计算器类，它能够做简单的加减乘除，我们希望在这些方法里面加一点日志输出。使用 Spring AOP 有以下五个步骤：</p>
<h5 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="定义目标类"><a href="#定义目标类" class="headerlink" title="定义目标类"></a>定义目标类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  <span class="comment">// 想使用 Spring 框架给这个类创建代理类，这个类必须归容器管</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i + j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i * j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i / j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要被代理的类已经定义好了，需要被增强的方法也写好了。</p>
<h5 id="定义切面类"><a href="#定义切面类" class="headerlink" title="定义切面类"></a>定义切面类</h5><p>我们把增强的代码写到切面类中（这个类一般放在<code>advice</code>包里）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>  <span class="comment">// 切面类需要 @Aspect 注解</span></span><br><span class="line"><span class="meta">@Component</span>  <span class="comment">// 切面类也需要归容器管</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.luyan.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法开始了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;execution(* com.luyan.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法返回了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;execution(* com.luyan.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法出异常了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.luyan.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法finally了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增强方法都是打印一句话。重点介绍一下各个与增强相关的注解：</p>
<ul>
<li><code>@Before</code>标注前置增强；</li>
<li><code>@AfterReturning</code>标注后置增强；</li>
<li><code>@AfterThrowing</code>标注异常增强；</li>
<li><code>@After</code>标注 finally 增强；</li>
<li><code>@Around</code>标注环绕增强；</li>
</ul>
<p>这些注解都表示一种位置，即增强的代码放在哪。例如我们需要增强<code>add</code>方法，容器会创建一个代理类，各个增强的位置如下伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 前置增强的位置</span></span><br><span class="line">    add();  <span class="comment">// 核心代码</span></span><br><span class="line">    <span class="comment">// 后置增强的位置</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 异常增强的位置</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// finally 增强的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说完了增强相关的注解之后，再看看它们的参数。这些参数都是切点表达式，我们这边都写为<code>execution(* com.luyan.service.*.*(..))</code>，这表示这些增强方法会作用在<code>com.luyan.service</code>包下所有类中满足：（1）返回值类型任意；（2）方法名任意；（3）方法参数任意；的方法上。</p>
<h5 id="打开代理开关"><a href="#打开代理开关" class="headerlink" title="打开代理开关"></a>打开代理开关</h5><p>下面我们需要打开自动代理开关，可以在 xml 里面配置<code>&lt;aop:aspectj-autoproxy/&gt;</code>，也可以在配置类上加<code>@EnableAspectJAutoProxy</code>注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.luyan&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(JavaConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Calculator calculator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> calculator.add(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码中变量<code>calculator</code>会自动装配为代理对象，但有一个注意点：如果这个类实现了某个接口，那么需要使用接口来定义变量；没有实现接口，就直接使用自己的类名定义变量。<br>之所以会这样，是因为 Spring 框架底层做动态代理的时候：</p>
<ul>
<li>若目标类实现了接口，底层会使用 JDK 代理技术，这种情况下代理类和目标类不是一个类型，但一定实现同一个接口，因此需要使用接口来定义变量。</li>
<li>若目标类没实现接口，底层会使用 cglib 代理技术，这种情况下代理类是目标类的子类，因此可以直接使用原类型接收。</li>
</ul>
<h4 id="获取切点信息"><a href="#获取切点信息" class="headerlink" title="获取切点信息"></a>获取切点信息</h4><p>上面简单使用了 AOP 技术，但没什么实用价值。我们在做 AOP 的时候往往想要关注：</p>
<ol>
<li>切点方法的相关信息：<ol>
<li>所在类信息；</li>
<li>当前的方法名；</li>
<li>当前方法的参数；</li>
</ol>
</li>
<li>切点方法的返回值；</li>
<li>切点方法产生的异常信息；</li>
</ol>
<h5 id="方法相关信息"><a href="#方法相关信息" class="headerlink" title="方法相关信息"></a>方法相关信息</h5><p>我们在所有的增强阶段都可以获取方法的相关信息，下面以<code>@Before</code>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(* com.luyan.Calculator.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取目标类信息 class com.luyan.Calculator</span></span><br><span class="line">    System.out.println(joinPoint.getTarget().getClass());</span><br><span class="line">    <span class="comment">// 获取增强的方法名 add</span></span><br><span class="line">    System.out.println(joinPoint.getSignature().getName());</span><br><span class="line">    <span class="keyword">for</span> (Object arg : joinPoint.getArgs()) &#123;  <span class="comment">// 获取目标方法的所有参数</span></span><br><span class="line">        System.out.println(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我只需要在增强代码所在的方法上加一个<code>JoinPoint</code>类型参数，就可以从这个参数里获取我们需要的信息。具体获取方式看上面的例子。</p>
<h5 id="方法返回值"><a href="#方法返回值" class="headerlink" title="方法返回值"></a>方法返回值</h5><p>获取方法的返回值只能在<code>@afterReturning</code>阶段，具体操作如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(value = &quot;execution(* com.luyan.Calculator.*(..))&quot;, returning = &quot;result&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(<span class="type">int</span> result)</span> &#123;</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只需要在方法上定义一个形参用来接受目标方法的返回值，在<code>@AfterReturning</code>注解里使用<code>returning</code>属性指定将返回值赋给哪一个形参。</p>
<h5 id="方法异常"><a href="#方法异常" class="headerlink" title="方法异常"></a>方法异常</h5><p>获取目标方法异常只能在<code>@AfterThrowing</code>阶段，具体操作如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(value = &quot;execution(* com.luyan.Calculator.*(..))&quot;, throwing = &quot;throwable&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Throw&quot;</span> + throwable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与获取返回值类似，我们在方法上定义一个形参用来接受异常，并在<code>@AfterThrowing</code>注解里面使用<code>throwing</code>属性指定接受异常的形参。</p>
<h4 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a>切点表达式</h4><h5 id="语法介绍"><a href="#语法介绍" class="headerlink" title="语法介绍"></a>语法介绍</h5><p>切点表达式能够指定增强位置，本节详细介绍一下切点表达式。下面是一个完整的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> <span class="type">int</span> com.luyan.Calculator.add(<span class="type">int</span>, <span class="type">int</span>))</span><br></pre></td></tr></table></figure>
<p><code>execution()</code>是固定写法，下面详细介绍一下内部表达式的组成部分：</p>
<ol>
<li>访问修饰符部分，对应案例的<code>public</code>；这个部分可以<strong>省略</strong>，省略表示匹配任意访问修饰符。</li>
<li>方法返回值类型部分，对应案例的<code>int</code>；这边可以使用<code>*</code>表示任意返回值类型。</li>
<li>目标类的全限定名部分，对应案例的<code>com.luyan.Calculator</code>；这个部分也可以<strong>省略</strong>，省略表示匹配任意类型。这个部分可以模糊匹配：<ol>
<li>命名模糊：<code>com.luyan.service.*tor</code>匹配<code>com.luyan.service</code>包下命名以<code>tor</code>结尾的所有类，命名模糊也可以在包上模糊；</li>
<li>单层模糊：<code>com.luyan.*.Calculator</code>匹配<code>com.luyan</code>为根包、<code>Calculator</code>为类名、子包任意的情况，子包层数只有一层；</li>
<li>多层模糊：<code>com..Calculator</code>匹配<code>com</code>为根包、<code>Calculator</code>为类名、子包任意的情况，子包层数任意；</li>
</ol>
</li>
<li>方法名部分，对应案例的<code>add</code>；可以使用<code>*</code>模糊匹配：<ol>
<li>直接写一个<code>*</code>匹配所有方法；</li>
<li>写<code>set*</code>匹配以<code>set</code>开头的所有方法；</li>
</ol>
</li>
<li>方法参数类型列表，对应案例的<code>(int, int)</code>；<ol>
<li><code>()</code>匹配无参方法；</li>
<li><code>(int)</code>匹配有一个<code>int</code>类型参数的方法；</li>
<li><code>(*)</code>匹配有一个任意类型参数的方法；</li>
<li><code>(..)</code>匹配任意类型参数的方法；</li>
<li><code>b c d</code>三种情况可组合使用，例如<code>(*, int)</code>、<code>(String, ..)</code>、<code>(*, ..)</code>；</li>
</ol>
</li>
</ol>
<p>将这六个部分整合成<code>1? 2 3?4(5)</code>形式就是一个完整的切点表达式。</p>
<h5 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h5><ol>
<li><p>查询某包某类下，访问修饰符公有，返回值类型<code>int</code>的所有方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> com.luyan.Calculator.*(..)</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询某包某类中第一参数类型为<code>String</code>的所有方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* com.luyan.Calculator.*(String, ..)</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询全部包下，无参数的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* *()  <span class="comment">// 省略访问修饰符、返回值类型任意、省略类全限定名、方法名任意、无参</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查询<code>com</code>包下，以<code>int</code>参数类型结尾的所有方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* com..*(.., <span class="type">int</span>)  <span class="comment">// 省略了类名</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查询某包下类名以<code>Service</code>结尾，私有且返回值类型为<code>int</code>的所有无参方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> com.luyan.*Service.*()</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="提取切点表达式"><a href="#提取切点表达式" class="headerlink" title="提取切点表达式"></a>提取切点表达式</h5><p>很多增强方法的切点表达式是一样的，这种情况下挨个写不方便维护。于是我们想提取切点表达式，我们可以将切点表达式提取到当前类之中，也可以单独创建一个类专门存储切点表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.luyan.Calculator.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pc</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before(&quot;pc()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们定义一个<code>public void</code>修饰的空方法<code>pc</code>，这个方法使用<code>@Pointcut</code>注解，注解里面写上一个切点表达式。下面需要切点表达式的地方直接改成这个方法的调用即可，就像我们这边的<code>@Before(&quot;pc()&quot;)</code>。<br>上面是将切点表达式提取到当前类中，提取到一个单独类也是一样的。定义一个类，注意这个类要使用<code>@Component</code>注解且一般位于<code>pointcut</code>包下，里面写上一样的定义方法。用的时候需要写上方法的全限定名，例如<code>com.luyan.pointcut.MyPointcut.pc()</code>。</p>
<h4 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h4><p>我们之前看过前置通知、后置通知、异常通知、finally 通知，还剩下一个环绕通知。和其他通知相比，环绕通知可以自定义位置，例如看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;com.luyan.pointcut.MyPointcut.pc()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这边写操作相当于前置通知</span></span><br><span class="line">        result = joinPoint.proceed(args);  <span class="comment">// 执行目标方法</span></span><br><span class="line">        <span class="comment">// 这边写操作相当于后置通知</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="comment">// 这边写操作相当于异常通知</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  <span class="comment">// 把异常抛给调用者</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 这边写操作相当于 finally 通知</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>环绕通知方法使用<code>@Around</code>注解，注解里面一样写切点表达式。这个方法返回值类型是<code>Object</code>，有一个<code>ProceedingJoinPoint</code>类型的参数。</p>
<ul>
<li>我们可以使用<code>joinPoint.proceed(args)</code>来调用目标方法，方法运行必要的参数通过<code>joinPoint.getArgs()</code>获取；</li>
<li>目标方法的返回结果作为这个代理方法的返回结果；</li>
<li>只要在案例中注释的部分写上对应的代码即可；</li>
</ul>
<h4 id="切面优先级"><a href="#切面优先级" class="headerlink" title="切面优先级"></a>切面优先级</h4><p>有些目标方法上可以能需要多个通知，例如事务相关通知、日志相关通知。如果我想控制通知的优先级怎么办？我们可以在切面类上加注解<code>@Order(10) </code>，注解里面的值越小代表通知的优先级越高，默认值是<code>Integer.MAX_VALUE </code>即最小优先级。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAdvice</span> &#123;</span><br><span class="line">    <span class="comment">// 切点方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优先级越高的通知前置通知越先执行，后置通知越后执行。如果有两个通知类似于下面的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 前置通知</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 前置通知</span></span><br><span class="line">        target();</span><br><span class="line">        <span class="comment">// 后置通知</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="comment">// 异常通知</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// finally 通知</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后置通知</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    <span class="comment">// 异常通知</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// finally 通知</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到不同通知之间是一种层级结构的关系，优先级高的通知在外层，优先级低的通知在内层。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>本节主要讲解 Spring 对事务的支持，在此之前我们需要先看一下如何使用<code>JdbcTemplate </code>操作数据库。而<code>JdbcTemplate </code>需要一个连接池，国内比较流行的连接池是 Druid 连接池。</p>
<h4 id="Druid-连接池"><a href="#Druid-连接池" class="headerlink" title="Druid 连接池"></a>Druid 连接池</h4><h5 id="导包-1"><a href="#导包-1" class="headerlink" title="导包"></a>导包</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">dataSource.setDriverClassName(driver);</span><br><span class="line">dataSource.setUrl(url);</span><br><span class="line">dataSource.setUsername(username);</span><br><span class="line">dataSource.setPassword(password);</span><br></pre></td></tr></table></figure>
<p>创建连接池对象的时候往往需要一些数据库相关信息，这些信息我们一般都会封装在一个<code>properties</code>文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/&lt;数据库名称&gt;</span><br><span class="line">jdbc.username=用户名</span><br><span class="line">jdbc.password=连接密码</span><br></pre></td></tr></table></figure>
<h4 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h4><h5 id="导包-2"><a href="#导包-2" class="headerlink" title="导包"></a>导包</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="创建对象-1"><a href="#创建对象-1" class="headerlink" title="创建对象"></a>创建对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">jdbcTemplate.setDataSource(dataSource);  <span class="comment">// 这边一般使用 Druid 连接池对象</span></span><br></pre></td></tr></table></figure>
<h5 id="增、删、改数据"><a href="#增、删、改数据" class="headerlink" title="增、删、改数据"></a>增、删、改数据</h5><p><code>JdbcTemplate</code>里面有一个<code>update</code>方法可以实现增、删、改数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="keyword">final</span> String sql, Object... args)</span></span><br></pre></td></tr></table></figure>
<p>使用的步骤很简单：（1）创建<code>JdbcTemplate</code>对象；（2）定义 sql 语句；（3）调用<code>update</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入学生信息</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO students VALUES (NULL, ?, ?);&quot;</span>;</span><br><span class="line">jdbcTemplate.update(sql, <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;高三六班&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改学生信息</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE students SET class=? WHERE id=?;&quot;</span>;</span><br><span class="line">jdbcTemplate.update(sql, <span class="string">&quot;高三七班&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除学生</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;DELETE FROM students WHERE id=?;&quot;</span>;</span><br><span class="line">jdbcTemplate.update(sql, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>使用很简单，sql 语句里面允许使用<code>?</code>作为占位符，调用<code>update</code>方法的时候通过参数传递占位符。</p>
<h5 id="查询简单类型"><a href="#查询简单类型" class="headerlink" title="查询简单类型"></a>查询简单类型</h5><p>当我们需要查询的数据是一个数字或字符串时可以使用下面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">queryForObject</span><span class="params">(String sql, Class&lt;T&gt; requiredType, Object... args)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT COUNT(*) FROM students;&quot;</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">nums</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, Long.class);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id FROM students WHERE sname=?;&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, Integer.class, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT sname FROM students WHERE id=?;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, String.class, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>如果查询的值类型与传递进去的类型不一致，会报错！</p>
<h5 id="查询-Map"><a href="#查询-Map" class="headerlink" title="查询 Map"></a>查询 Map</h5><p><code>JdbcTemplate</code>提供了<code>queryForMap</code>方法用来将一条记录封装成一个<code>Map</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">queryForMap</span><span class="params">(String sql, <span class="meta">@Nullable</span> Object... args)</span></span><br></pre></td></tr></table></figure>
<p>这个方法返回若干个键值对，键是字段名，值是字段值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM students WHERE id=?;&quot;</span>;</span><br><span class="line"><span class="comment">// &#123;id=2, sname=李四, class=高一五班&#125;</span></span><br><span class="line">Map&lt;String, Object&gt; stu = jdbcTemplate.queryForMap(sql, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>如果查询的记录不止一条，会报错！</p>
<h5 id="查询-List"><a href="#查询-List" class="headerlink" title="查询 List"></a>查询 List</h5><p><code>JdbcTemplate</code>提供了<code>queryForList</code>方法将多条记录封装成<code>List</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">queryForList</span><span class="params">(String sql, Object... args)</span></span><br></pre></td></tr></table></figure>
<p>显然这个方法会将每一条记录封装成<code>Map&lt;String, Object&gt;</code>，然后放进一个<code>List</code>里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM students;&quot;</span>;</span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; students = jdbcTemplate.queryForList(sql);</span><br></pre></td></tr></table></figure>
<h5 id="查询对象"><a href="#查询对象" class="headerlink" title="查询对象"></a>查询对象</h5><p>除此之外<code>JdbcTemplate</code>还支持返回自定义对象列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">query</span><span class="params">(String sql, RowMapper&lt;T&gt; rowMapper, Object... args)</span></span><br></pre></td></tr></table></figure>
<p><code>RowMapper</code>是一个接口，里面有唯一的方法<code>mapRow </code>。我们需要在这个方法里面生成自定义对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM students WHERE class LIKE &#x27;高一%&#x27;;&quot;</span>;</span><br><span class="line">List&lt;Student&gt; students = jdbcTemplate.query(sql, <span class="keyword">new</span> <span class="title class_">RowMapper</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">mapRow</span><span class="params">(ResultSet rs, <span class="type">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        user.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        user.setName(rs.getString(<span class="string">&quot;sname&quot;</span>));</span><br><span class="line">        user.setClazz(rs.getString(<span class="string">&quot;class&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>mapRow</code>方法会传进来一个结果集，我们要做的就是将结果集映射到自定义对象。<br>我们每次查询对象都这么映射就显得很麻烦，官方提供了一个<code>RowMapper</code>的实现类<code>BeanPropertyRowMapper</code>，它能帮我们将数据库字段与实体类变量映射起来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, sname AS name, class AS clazz FROM students;&quot;</span>;</span><br><span class="line">List&lt;Student&gt; students = jdbcTemplate.query(</span><br><span class="line">    sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(Student.class));</span><br></pre></td></tr></table></figure>
<p>如果实体类与数据库字段不匹配，那么查询的时候使用<code>as</code>关键字改一下名字。</p>
<h4 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h4><h5 id="导包-3"><a href="#导包-3" class="headerlink" title="导包"></a>导包</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="配置事务管理器"><a href="#配置事务管理器" class="headerlink" title="配置事务管理器"></a>配置事务管理器</h5><p>首先我们需要将事务管理器配置到 Spring 容器中，因为这是三方类，所以在配置类中定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> TransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">    <span class="type">DataSourceTransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">    tm.setDataSource(dataSource);  <span class="comment">// 这边使用 Druid 连接池即可</span></span><br><span class="line">    <span class="keyword">return</span> tm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="简单使用事务"><a href="#简单使用事务" class="headerlink" title="简单使用事务"></a>简单使用事务</h5><p>我们下面在需要使用事务的方法上添加<code>@Transactional</code>注解即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE students SET class=? WHERE id=?&quot;</span>;</span><br><span class="line">    jdbcTemplate.update(sql, <span class="string">&quot;初中一班&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;  <span class="comment">// 模拟出错，测试事务是否开启成功</span></span><br><span class="line">    jdbcTemplate.update(sql, <span class="string">&quot;初中二班&quot;</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a>只读事务</h5><p><code>@Transactional</code>注解除了可以加在方法上，还可以加在类上。这种情况下该类里面所有的方法都会被加上事务，这就会产生一个问题：如果一个方法里面只会查询数据而不会修改数据，但因为类上有事务注解导致这个查询方法上面也有了事务，这就会降低查询代码的执行效率。<br>解决方案是在只读方法上加注解<code>@Transactional(readOnly = true) </code>来覆盖掉类上的注解，可以发现注解里面多了一个<code>readOnly</code>参数，这表示这是只读事务，效率就会提升很多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getXXX</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h5><p>有时候因为我们代码的问题，导致一个事务方法执行了很长时间，这会占用大量的资源。因此我们一般会给事务方法添加一个超时时间，即超过指定时长还没结束的事务方法将会被回滚。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(timeout = 3)</span>  <span class="comment">// 单位是秒</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE students SET class=? WHERE id=?&quot;</span>;</span><br><span class="line">    jdbcTemplate.update(sql, <span class="string">&quot;py中一班&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">    jdbcTemplate.update(sql, <span class="string">&quot;java中一班&quot;</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然这个方法不能在三秒内结束，因此三秒后这个程序会抛出<code>TransactionTimedOutException</code>异常。但是有趣的是，如果程序卡住的位置已经没有数据库操作了，是不会抛异常的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(timeout = 3)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE students SET class=? WHERE id=?&quot;</span>;</span><br><span class="line">    jdbcTemplate.update(sql, <span class="string">&quot;py中一班&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到程序在卡住之前所有的数据库操作已经做完了，这种情况下是不会抛异常的，会一直等待下去直到运行结束或出现其它异常。</p>
<h5 id="异常指定"><a href="#异常指定" class="headerlink" title="异常指定"></a>异常指定</h5><p>我们使用<code>@Transactional</code>直接添加事务之后，如果一个方法执行期间抛出<code>RuntimeException</code>则会执行回滚操作，否则会执行提交操作。我们知道，<code>Exception</code>里面除了<code>RuntimeException</code>还有<code>IOException</code>与<code>SQLException</code>。也就是说如果代码运行期间抛出这两个异常，事务也会被提交，这显然是不合理的，我们可以使用<code>rollbackFor</code>属性指定回滚的异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定为 Exception 表示所有异常都会回滚</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 数据库操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，还可以使用<code>noRollbackFor</code>属性指定遇到什么异常不回滚。</p>
<h5 id="隔离级别设置"><a href="#隔离级别设置" class="headerlink" title="隔离级别设置"></a>隔离级别设置</h5><p>数据库事务的隔离级别是指在多个事务并发执行时，数据库系统为了保证数据一致性所遵循的规定。常见的隔离级别包括：</p>
<ul>
<li>读未提交（Read Uncommited）：事务可以读取未被提交的数据，容易产生脏读、不可重复读和幻读等问题。实现简单但不太安全，一般不用；</li>
<li>读已提交（Read Committed）：事务只能读取已经提交的数据，可以避免脏读问题，但可能引发不可重复读和幻读；</li>
<li>可重复读（Repeatable Read）：在一个事务中，相同的查询将返回相同的结果集，不管其他事务对数据做了什么修改，可以避免脏读和不可重复读，但仍有幻读的问题；</li>
<li>串行化（Serializable）：最高的隔离级别，完全禁止了并发，只允许一个事务执行完毕之后才能执行另一个事务。可以避免以上所有问题，但效率较低，不适用于高并发场景。</li>
</ul>
<p>下面解释一下什么叫脏读、不可重复读、幻读：</p>
<ul>
<li>脏读：事务内读取到其它事务未被提交的数据，这显然是不合理的；</li>
<li>不可重复读：一次事务内读取到其它事务已经提交的修改数据，导致两次读取结果不同；</li>
<li>幻读：一次事务内读取到其它事务已经提交的插入数据，导致两次读取结果不同；</li>
</ul>
<p>在 Spring 事务内可以使用<code>@Transactional</code>注解的<code>isolation</code>属性来指定隔离级别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置为第二级别</span></span><br><span class="line"><span class="meta">@Transactional(isolation = Isolation.READ_COMMITTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 数据库操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>隔离级别默认是第三级，我们常用的是第二级，因为第二级并发效率较高。</p>
<h5 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h5><p>事务传播行为是指在一个事务方法内部调用另一个事务方法（下面我们简称为父事务与子事务），这个子事务是继承父事务还是开新事务。我们可以在子事务方法上加注解来指定传播行为，一般常用的传播行为有两个：</p>
<ul>
<li><code>Propagation.REQUIRED</code><strong>默认值</strong>，如果父方法有事务就使用父方法的事务，否则就开新事务；</li>
<li><code>Propagation.REQUIRES_NEW</code>无论父方法是否有事务，都新开事务；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 数据库操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
常见的应用：Service 层有一个方法调用两个 Dao 层的方法，并且想让这两个方法要么都成功，要么都失败。就可以让这两个 Dao 层方法与 Service 层的方法共用一个事务，这样不论谁报错，整体都会回滚。<br>但是要注意，如果父方法与子方法在一个类里定义，是不能共享事务的。也就是说，父事务方法与子事务方法不能在同一个类里定义。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/29/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8810%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/06/29/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8810%EF%BC%89/" itemprop="url">Java 基础系列（10）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-06-29T12:12:03+08:00">
                2023-06-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><h4 id="写时复制容器"><a href="#写时复制容器" class="headerlink" title="写时复制容器"></a>写时复制容器</h4><h5 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h5><p>为了避免多线程同时读与写列表导致抛<code>ConcurrentModificationException</code>，<code>CopyOnWriteArrayList</code>就出现了。<code>CopyOnWriteArrayList</code>的用法和<code>ArrayList</code>基本是一样的，但它具备以下特性：</p>
<ul>
<li>线程安全，支持多线程并发访问；</li>
<li>它以原子方式支持一些复合操作；</li>
</ul>
<p><code>CopyOnWriteArrayList</code>支持以下两个原子复合操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不存在才添加，返回是否添加</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addIfAbsent</span><span class="params">(E e)</span></span><br><span class="line"><span class="comment">// 批量添加 c 里面非重复元素，不存在才添加，返回添加的元素个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addAllAbsent</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br></pre></td></tr></table></figure>
<p><code>CopyOnWriteArrayList</code>内部也是维护一个数组，每次修改的时候会创建一个新数组并在新数组里面做修改，修改完毕之后将新数组的引用赋值给<code>CopyOnWriteArrayList</code>里面的变量。读取元素的时候，先拿到内部数组的引用，然后访问对应的数组读取内容。<br>接下来我们看一下部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部维护的数组和锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">transient</span> Object[] array;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setArray</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);  <span class="comment">// 构造里默认创建一个空数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, elements, <span class="number">0</span>, elements.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，思路我们在上面已经说过了。<br>之前想要实现容器能并发访问，都是加锁。那么加了锁之后所有线程必须依次进行访问，时间成本太高了。现在这种思路每次修改都要复制一份数组，是不是对内存不太友好？是这样的！所以这个类适合<strong>读多写少</strong>的场景，它支持并发读，相比加锁一个个读效率提升很多。</p>
<h5 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h5><p><code>CopyOnWriteArraySet</code>使用和普通的集合也是基本一样，但它是线程安全的。它的内部使用<code>CopyOnWriteArrayList</code>实现，我们看它的部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArraySet</span><span class="params">()</span> &#123;</span><br><span class="line">    al = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> al.addIfAbsent(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> al.contains(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也正是因为它使用<code>CopyOnWriteArrayList</code>实现，所以相较于其它的<code>Set</code>，它的性能较低、不适用于元素个数较多的场景。<br>总结下来，<code>CopyOnWriteArrayList</code>和<code>CopyOnWriteArraySet</code>都适用于读远多于写、集合不太大的场景。</p>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><h5 id="并发安全"><a href="#并发安全" class="headerlink" title="并发安全"></a>并发安全</h5><p>之前介绍的<code>HashMap</code>并不是并发安全的，尤其在并发更新的情况下，<code>HashMap</code>会陷入死循环并占满 CPU。想要并发使用，我们可以使用之前介绍过的<code>Collections.synchronizedMap</code>，这是一个同步容器，但它存在以下问题：</p>
<ul>
<li>每个方法的调用都需要同步，效率低下；</li>
<li>对于迭代和复合操作，需要我们手动加锁，比较麻烦。</li>
</ul>
<p>在这种情况下，<code>ConcurrentHashMap</code>就出现了。</p>
<h5 id="原子复合操作"><a href="#原子复合操作" class="headerlink" title="原子复合操作"></a>原子复合操作</h5><p><code>ConcurrentHashMap</code>不仅实现了<code>Map</code>接口，它还实现了<code>ConcurrentMap</code>接口。接口中定义了一些条件更新操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConcurrentMap</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="comment">// 条件更新，key 存在时将其值设为 value 并返回 oldValue；否则返回 null</span></span><br><span class="line">    V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span>;</span><br><span class="line">    <span class="comment">// 条件删除，key 存在且其值是 value 则删除此键值对并返回 true；否则返回 false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span>;</span><br><span class="line">    <span class="comment">// 条件替换，key 存在且其值为 value 则将值修改为 newValue 并返回 true；否则返回 false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">replace</span><span class="params">(K key, V oldValue, V newValue)</span>;</span><br><span class="line">    <span class="comment">// 条件替换，key 存在时将其值替换成 value 并返回 oldValue；否则返回 null</span></span><br><span class="line">    V <span class="title function_">replace</span><span class="params">(K key, V value)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ConcurrentHashMap</code>对这些方法的实现都是原子的，所以不需要我们手动加锁。</p>
<h5 id="基本机制"><a href="#基本机制" class="headerlink" title="基本机制"></a>基本机制</h5><p><code>ConcurrentHashMap</code>是如何实现的高并发？简单讲有两点：</p>
<ol>
<li>分段锁；</li>
<li>读不需要加锁；</li>
</ol>
<p>同步容器使用<code>synchronized</code>，所有方法都要竞争一个锁。而<code>ConcurrentHashMap</code>采用分段锁技术，将数据分为多个段，每个段都有独立的锁，每个段也相当于一个独立的哈希表。无论是保存键值对还是根据键进行查找，都先根据键的哈希值映射到段，再在段对应的哈希表里进行操作。<br>采用分段锁可以大大提高并发度，多个段之间可以并行读写。默认情况下有 16 个段，这个数字可以通过构造传递：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span></span><br></pre></td></tr></table></figure>
<p>这边的<code>concurrencyLevel</code>表示预估的并行线程数，<code>ConcurrentHashMap</code>可以将其转换成 2 的整次幂。例如 14 会被转成 16, 25 会被转成 32。对每个段的数据进行读写时：</p>
<ul>
<li>写操作需要获取锁，不能并行；</li>
<li>读操作可以并行；</li>
<li>读写可以并行，即写的同时可以读；</li>
</ul>
<p>这些特性使得<code>ConcurrentHashMap</code>的并行度远远高于同步容器。</p>
<h5 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h5><p>上面说<code>ConcurrentHashMap</code>允许读和写并行执行，那么如果在读的过程中进行修改会出现什么现象？<br>答：<code>ConcurrentHashMap</code>迭代器创建完毕之后，会按照哈希表的结构依次遍历每一个元素。若在遍历的过程中修改哈希表，此时有两种情况：</p>
<ul>
<li>修改的部分已经遍历过了，迭代器无法反映出本次修改；</li>
<li>相反，修改的部分还没遍历到，那么新修改的部分会被遍历到；</li>
</ul>
<p>这就是弱一致性，下面看一个示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;abstract&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;basic&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                System.out.println(entry.getKey() + <span class="string">&quot;--&quot;</span> + entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);  <span class="comment">// 确保线程启动成功</span></span><br><span class="line">    map.put(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;call&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码会创建一个<code>ConcurrentHashMap</code>对象，并存储两个键值对。然后启动线程遍历所有键值对，遍历过程中往里面又添加了一个键值对。若是执行<code>map.put(&quot;c&quot;, &quot;call&quot;)</code>，则三个键值对都能遍历到；相对的，若是执行<code>map.put(&quot;0&quot;, &quot;call&quot;)</code>，则新添加的键值对是遍历不到的。<br>此外 Java 中没有并发版本的<code>HashSet</code>，但我们可以通过<code>Collections.newSetFromMap</code>方法基于<code>ConcurrentHashMap</code>创建一个。</p>
<h4 id="基于跳表的-Map-与-Set"><a href="#基于跳表的-Map-与-Set" class="headerlink" title="基于跳表的 Map 与 Set"></a>基于跳表的 Map 与 Set</h4><p>上面说的<code>ConcurrentHashMap</code>是不排序的并发<code>Map</code>，想要排序可以使用<code>ConcurrentSkipListMap</code>。基于<code>ConcurrentSkipListMap</code>的有序集合是<code>ConcurrentSkipListSet</code>，因此我们主要讲讲<code>ConcurrentSkipListMap</code>。<br><code>ConcurrentSkipListMap</code>是基于跳跃表实现的，跳跃表是一种数据结构，回头看。<code>ConcurrentSkipListMap</code>有如下特点：</p>
<ul>
<li>不适用锁，所有操作都是不阻塞的；所有操作都可以并行，包括写与写之间也可以并行。</li>
<li>与<code>ConcurrentHashMap</code>类似，<code>ConcurrentSkipListMap</code>也是弱一致性的。</li>
<li><code>ConcurrentSkipListMap</code>也实现了<code>ConcurrentMap</code>接口。</li>
<li><code>ConcurrentSkipListMap</code>是按键有序的，默认会调用 key 的<code>compareTo</code>方法。我们也可以在创建<code>ConcurrentSkipListMap</code>的时候传一个<code>Comparator</code>进去。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentSkipListMap</span>&lt;&gt;(</span><br><span class="line">        Collections.reverseOrder());</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>);</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>
这段代码会输出<code>&#123;c=3, b=2, a=1&#125;</code>，可见我们传递进去的逆序排序器是有效的。<br>我们接下来看看跳跃表，跳表是基于链表的，只是在链表的基础上加上了多层索引结构。跳表主要是为了解决链表查找效率低的问题，假设容器中包含如下有序元素：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">21</span>, <span class="number">25</span>, <span class="number">26</span></span><br></pre></td></tr></table></figure>
<code>ConcurrentSkipListMap</code>会构造出如下的跳表结构：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1710503016242-6a24184d-aa7a-44e5-a748-4d1821b9fc05.png#averageHue=%23f4f4f4&clientId=u64facbf8-ecf5-4&from=paste&height=255&id=u701a4910&originHeight=281&originWidth=866&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=72016&status=done&style=none&taskId=u20cb4a87-5950-4a85-b238-0ef2b2ff6e9&title=&width=787.2727102090508" alt="image.png"><br>构造出这样的有序跳表之后，想要从中查找元素就可以使用类似二分查找的策略了。例如我想查找 8 和 19 可以按照下面图的策略找：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1710503186832-68cfd842-8a50-46b3-a4ad-b3cdca360d6a.png#averageHue=%23f5f5f5&clientId=u64facbf8-ecf5-4&from=paste&height=272&id=uf465800a&originHeight=299&originWidth=873&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=81660&status=done&style=none&taskId=u8fdd089b-6388-429a-a136-e33f5125efa&title=&width=793.636346434759" alt="image.png"><br>具体跳表的实现还是很复杂的，我们不过度展开，只是简单看其原理。</li>
</ul>
<h4 id="并发队列-TODO"><a href="#并发队列-TODO" class="headerlink" title="并发队列 TODO"></a>并发队列 TODO</h4><p>&#x2F;&#x2F; TODO</p>
<h3 id="动态与函数式编程"><a href="#动态与函数式编程" class="headerlink" title="动态与函数式编程"></a>动态与函数式编程</h3><h4 id="反射-TODO"><a href="#反射-TODO" class="headerlink" title="反射 TODO"></a>反射 TODO</h4><h4 id="注解-TODO"><a href="#注解-TODO" class="headerlink" title="注解 TODO"></a>注解 TODO</h4><h4 id="动态代理-TODO"><a href="#动态代理-TODO" class="headerlink" title="动态代理 TODO"></a>动态代理 TODO</h4><h4 id="类加载机制-TODO"><a href="#类加载机制-TODO" class="headerlink" title="类加载机制 TODO"></a>类加载机制 TODO</h4><h4 id="正则表达式-TODO"><a href="#正则表达式-TODO" class="headerlink" title="正则表达式 TODO"></a>正则表达式 TODO</h4><h4 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h4><h5 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h5><h6 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h6><p>目前学到的很多 API 需要一个接口参数，例如<code>Arrays</code>类中的排序方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>这边的第二个参数需要一个比较器进去，那我们真的需要一个接口对象吗？实际上，这边需要的只是一种排序规则，说白了就是一段代码块或者说需要的只是一个函数。但 Java 不支持传递方法或函数，因此设计成接口，而我们调用方需要实现这个接口并传给功能提供方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Person[] persons = <span class="keyword">new</span> <span class="title class_">Person</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小红&quot;</span>, <span class="number">16</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小华&quot;</span>, <span class="number">21</span>),</span><br><span class="line">&#125;;</span><br><span class="line">Arrays.sort(persons, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这个例子里面，真正起作用的只有一行代码，但我们写出来却有很多。为了简化书写，Lambda 就出现了。</p>
<h6 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h6><p>我们使用 Lambda 表达式实现上面的案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(persons, (Person o1, Person o2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以看到代码简洁了许多，我们这边没有实现接口而是直接使用 Lambda 表达式代替。形式上，Lambda 表达式由以下部分构成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(参数列表) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>形似匿名函数的定义。<br>在此基础上，Lambda 表达式还有以下简化：</p>
<ul>
<li>参数列表的参数类型可以省略；</li>
<li>如果只有一个参数，可以省略小括号；</li>
<li>如果方法体内部只有一条返回语句，可以省略大括号；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(persons, (o1, o2) -&gt; o1.getAge() - o2.getAge());</span><br></pre></td></tr></table></figure>
<strong>注意：</strong>只有存在一个接口方法的接口可以使用 Lambda 表达式替代，毕竟方法多了就不知道对应哪一个接口方法了。此外，我们在 Lambda 表达式里面也可以使用外部的变量，但要求该变量实际是<code>final</code>的（可以不定义成常量，但不得修改）。</li>
</ul>
<h6 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h6><p>函数式接口特指仅含有一个抽象方法的接口，我们上面能被 Lambda 表达式替换的接口就是函数式接口。我们可以直接把 Lambda 表达式赋值给一个函数式接口，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; cmp = (o1, o2) -&gt; o1.getAge() - o2.getAge();</span><br></pre></td></tr></table></figure>
<p>Java 提供了很多函数式接口，整理如下：</p>
<table>
<thead>
<tr>
<th><strong>接口</strong></th>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>Predicate&lt;T&gt;</code></td>
<td><code>boolean test(T t)</code></td>
<td>测试是否满足条件</td>
</tr>
<tr>
<td><code>Function&lt;T, R&gt;</code></td>
<td><code>R apply(T t)</code></td>
<td>类型<code>T</code>转<code>R</code></td>
</tr>
<tr>
<td><code>UnaryOperator&lt;T&gt;</code></td>
<td><code>T apply(T t)</code></td>
<td>同类型转换</td>
</tr>
<tr>
<td><code>Consumer&lt;T&gt;</code></td>
<td><code>void accept(T t)</code></td>
<td>单个对象的消费者</td>
</tr>
<tr>
<td><code>Supplier&lt;T&gt;</code></td>
<td><code>T get()</code></td>
<td>工厂方法</td>
</tr>
<tr>
<td><code>BiFunction&lt;T, U, R&gt;</code></td>
<td><code>R apply(T t, U u)</code></td>
<td>接受两个参数，转为<code>R</code></td>
</tr>
<tr>
<td><code>BinaryOperator&lt;T&gt;</code></td>
<td><code>T apply(T t, T u)</code></td>
<td>接受两个<code>T</code>，转为<code>T</code></td>
</tr>
<tr>
<td><code>BiConsumer&lt;T, U&gt;</code></td>
<td><code>void accept(T t, U u)</code></td>
<td>两个对象的消费者</td>
</tr>
<tr>
<td><code>BiPredicate&lt;T, U&gt;</code></td>
<td><code>boolean test(T t, U u)</code></td>
<td>测试是否满足条件</td>
</tr>
</tbody></table>
<p>这些函数式接口被广泛应用于函数式数据处理<code>Stream</code>相关类中，例如：</p>
<ul>
<li>对列表中每个元素做变换可以使用<code>Function</code>接口；</li>
<li>对列表里每一个元素做某种操作可以使用<code>Consumer</code>接口；</li>
<li>实现一个过滤器对列表元素做筛选可以使用<code>Predicate</code>接口；</li>
</ul>
<p>举个例子，我们现在有一个<code>Person</code>列表，想要处理获取所有人姓名的列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">map</span><span class="params">(List&lt;Person&gt; personList, </span></span><br><span class="line"><span class="params">                               Function&lt;Person, String&gt; converter)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Person person : personList) &#123;</span><br><span class="line">        list.add(converter.apply(person));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Person&gt; personList = List.of(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小红&quot;</span>, <span class="number">16</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小华&quot;</span>, <span class="number">21</span>)</span><br><span class="line">    );</span><br><span class="line">    List&lt;String&gt; names = map(personList, person -&gt; person.getName());</span><br><span class="line">    System.out.println(names);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们自己实现了一个<code>map</code>方法，这个方法接受一个列表以及映射规则，返回给我们映射结果。使用的时候，我们直接使用 Lambda 表达式替换接口实现，这是非常好用且优雅的。</p>
<h6 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h6><p>Lambda 经常被用于调用某个对象的方法，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = map(personList, person -&gt; person.getName());</span><br></pre></td></tr></table></figure>
<p>这个例子里，Lambda 表达式主要就是调用<code>person</code>对象的<code>getName</code>方法。对于这种没有复杂逻辑，仅仅是方法调用的情形，Lambda 表达式可以进一步简化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = map(personList, Person::getName);</span><br></pre></td></tr></table></figure>
<p><code>Person::getName</code>是 Java8 新语法，称为方法引用。它由<code>::</code>隔开，前面是类名或实例变量名，后面是方法名。</p>
<ol>
<li><p>静态方法只能使用类名进行引用，假设<code>Person</code>类有<code>getCollege</code>静态方法，则有以下等价关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person 类的静态方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCollege</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Jiangsu&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两种写法等价，引用静态方法的等价 Lambda 是无参的</span></span><br><span class="line">Supplier&lt;String&gt; s = Person::getCollege;</span><br><span class="line">Supplier&lt;String&gt; s = () -&gt; Person.getCollege();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用类名引用实例方法，Lambda 表达式第一个参数默认是实例对象，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两句等价，转换成 Lambda 会有一个实例对象作为参数</span></span><br><span class="line">Function&lt;Person, String&gt; f = Person::getName;</span><br><span class="line">Function&lt;Person, String&gt; f = p -&gt; p.getName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda 第一个参数仍然是实例对象，第二个参数是被调函数需要的参数</span></span><br><span class="line"><span class="comment">// 最多就两个参数，第一个是实例对象，因此引用的方法最多可以携带一个参数</span></span><br><span class="line">BiConsumer&lt;Person, String&gt; f = Person::setName;</span><br><span class="line">BiConsumer&lt;Person, String&gt; f2 = (p, name) -&gt; p.setName(name);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用实例对象引用实例方法表示所有操作都使用当前对象的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xxx&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用实例变量引用方法，会直接调用该实例对象的方法</span></span><br><span class="line">Supplier&lt;String&gt; f = person::getName;</span><br><span class="line">Supplier&lt;String&gt; f2 = () -&gt; person.getName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer 的泛型类型是参数的类型</span></span><br><span class="line">Consumer&lt;String&gt; f = person::setName;</span><br><span class="line">Consumer&lt;String&gt; f2 = (name) -&gt; person.setName(name);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用类名引用构造方法，这种情况下没有默认参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以看到所有的参数都作为构造方法的参数</span></span><br><span class="line">BiFunction&lt;String, Integer, Person&gt; f = Person::<span class="keyword">new</span>;</span><br><span class="line">BiFunction&lt;String, Integer, Person&gt; f = (name, age) -&gt; <span class="keyword">new</span> <span class="title class_">Person</span>(name, age);</span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="函数复合"><a href="#函数复合" class="headerlink" title="函数复合"></a>函数复合</h6><p>使用 Lambda 表达式相当于我们可以把方法当做参数进行传递，函数复合指的是一个方法参数与返回值都是一段代码。例如在对数组进行排序的时候，我们往往使用 Lambda 表达式替换<code>Comparator</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(persons, (p1, p2) -&gt; p1.getAge() - p2.getAge());</span><br></pre></td></tr></table></figure>
<p>对于这种写法我觉得可读性不是很好，对此<code>Comparator</code>类提供了<code>comparing</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> U&gt;&gt; Comparator&lt;T&gt; <span class="title function_">comparing</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T, ? extends U&gt; keyExtractor)</span> </span><br><span class="line">&#123;</span><br><span class="line">    Objects.requireNonNull(keyExtractor);</span><br><span class="line">    <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)</span><br><span class="line">        (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码看起来很复杂，实际上是把类型<code>T</code>先转成<code>U</code>，然后进行比较。基于此按照年龄进行排序可以写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(persons, Comparator.comparing(Person::getAge));</span><br></pre></td></tr></table></figure>
<p>除了<code>comparing</code>方法，还有以下两个较为常用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逆序比较器</span></span><br><span class="line"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title function_">reversed</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.reverseOrder(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二次比较</span></span><br><span class="line"><span class="keyword">default</span> &lt;U <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> U&gt;&gt; Comparator&lt;T&gt; <span class="title function_">thenComparing</span><span class="params">(</span></span><br><span class="line"><span class="params">        Function&lt;? <span class="built_in">super</span> T, ? extends U&gt; keyExtractor)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> thenComparing(comparing(keyExtractor));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二次比较的具体实现</span></span><br><span class="line"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title function_">thenComparing</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> compare(c1, c2);</span><br><span class="line">        <span class="keyword">return</span> (res != <span class="number">0</span>) ? res : other.compare(c1, c2);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这些方法，我们想按照年龄降序排序、年龄一样按照姓名排序可以实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; comparator = Comparator.comparing(Person::getAge)</span><br><span class="line">        .reversed()</span><br><span class="line">        .thenComparing(Person::getName);</span><br><span class="line">Arrays.sort(persons, comparator);</span><br></pre></td></tr></table></figure>
<p>最后再说一个平常用的较多的方法，<code>Function</code>类中有一个<code>andThen</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &lt;V&gt; Function&lt;T, V&gt; <span class="title function_">andThen</span><span class="params">(Function&lt;? <span class="built_in">super</span> R, ? extends V&gt; after)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法能返回一个映射器，首先实现<code>T -&gt; R</code>的映射，然后实现<code>R -&gt; V</code>的映射。例如我有一个<code>Person</code>列表，我想获取所有人姓名的首字母可以写出如下映射器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Person, String&gt; f = ((Function&lt;Person, String&gt;) Person::getName</span><br><span class="line">                             .andThen(name -&gt; name.substring(<span class="number">0</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<h5 id="函数式数据处理-基本使用"><a href="#函数式数据处理-基本使用" class="headerlink" title="函数式数据处理-基本使用"></a>函数式数据处理-基本使用</h5><p>Java8 引入了<code>Stream</code>接口即流式操作，典型的场景有对列表元素做过滤、转换等。下面我们看其基本使用。<code>Collection</code>接口中提供了两个获取<code>Stream</code>的默认方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序流，单线程</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并行流，背后可能是多线程</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">parallelStream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个例子，我有一个人员列表，我想打印所有年纪 ≥ 18 的人员姓名，可以如下实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">personList.stream()</span><br><span class="line">        .filter(person -&gt; person.getAge() &gt;= <span class="number">18</span>)  <span class="comment">// 过滤</span></span><br><span class="line">        .map(Person::getName)  <span class="comment">// 转化</span></span><br><span class="line">        .forEach(System.out::println);  <span class="comment">// 挨个操作</span></span><br></pre></td></tr></table></figure>
<p>简直不要太优雅。但这相当于遍历了列表很多次吧？会不会影响效率？其实并不会，因为<code>filter</code>与<code>map</code>是中间操作，只会构建流水线并不会触发执行。而<code>forEach</code>是终端操作，遇到时会触发执行。</p>
<h6 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h6><p>流的中间操作主要包含<code>distinct、sorted、skip、limit、peek、mapToLong、mapToInt、mapToDouble、flatMap</code>等。下面我们一一看下。</p>
<ol>
<li><p><code>distinct</code>可以对流中的元素去重；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; res = personList.stream()</span><br><span class="line">        .map(Person::getAge)</span><br><span class="line">        .distinct()</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>这个案例会统计所有人员不同的年纪，<code>distinct</code>操作内部会使用<code>HashSet</code>进行去重。<br><code>collect</code>是一个终端操作，它能够将流水线上的元素收集起来，这边将元素收集到一个列表中。</p>
</li>
<li><p><code>sorted</code>可以对流中的元素排序，具体有两种形式；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">()</span>  <span class="comment">// 要求流水线上的元素实现 Comparable 接口</span></span><br><span class="line"><span class="comment">// 自定义比较器</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; res = personList.stream()</span><br><span class="line">        .sorted(Comparator.comparing(Person::getAge)</span><br><span class="line">                .reversed()</span><br><span class="line">                .thenComparing(Person::getName)</span><br><span class="line">        ).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>skip</code>可以跳过指定数目元素，<code>limit</code>可以限制流水线上最大元素数目；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; res = personList.stream()</span><br><span class="line">        .skip(<span class="number">2</span>).limit(<span class="number">1</span>)  <span class="comment">// 跳过 2 个元素后，取 1 个元素，后面的元素忽略</span></span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>dropWhile</code>满足条件一直跳过，<code>takeWhile</code>满足条件一会获取；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; personList = List.of(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小红&quot;</span>, <span class="number">16</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小华&quot;</span>, <span class="number">18</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小刚&quot;</span>, <span class="number">22</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 满足条件一直获取，直到遇到一个不满足条件的，将其及之后的元素忽略</span></span><br><span class="line"><span class="comment">// [小明]</span></span><br><span class="line">List&lt;Person&gt; res = personList.stream()</span><br><span class="line">        .takeWhile(person -&gt; person.getAge() &gt; <span class="number">17</span>)</span><br><span class="line">        .map(Person::getName)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 满足条件一直跳过，直到遇到一个不满足条件的，将其及之后的元素全部通过</span></span><br><span class="line"><span class="comment">// [小红, 小华, 小刚]</span></span><br><span class="line">List&lt;Person&gt; res = personList.stream()</span><br><span class="line">        .dropWhile(person -&gt; person.getAge() &gt; <span class="number">17</span>)</span><br><span class="line">        .map(Person::getName)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>peek</code>可以对所有元素做某种操作，一般用来查看流中元素；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; res = personList.stream()</span><br><span class="line">        .peek(System.out::println)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>mapToLong/mapToInt/mapToDouble</code>将元素映射到基本数据类型；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对所有人年龄求和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> personList.stream()</span><br><span class="line">        .mapToInt(Person::getAge).sum();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>flatMap</code>可以将每个元素转换成一个流，然后所有元素流合并成一个流；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = List.of(<span class="string">&quot;abc def&quot;</span>, <span class="string">&quot;hij&quot;</span>, <span class="string">&quot;klm nop&quot;</span>);</span><br><span class="line">strings.stream().flatMap(</span><br><span class="line">    s -&gt; Arrays.stream(s.split(<span class="string">&quot; &quot;</span>))  <span class="comment">// 按空格分割并返回为流，最终会把所有单词流转到下一步</span></span><br><span class="line">).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h6><p>中间操作并不会触发执行，返回的也是<code>Stream</code>。终端操作能够触发执行，并且能够返回有用的值。常用的终端操作除了<code>collect</code>外还有<code>max、min、count、allMatch、anyMatch、noneMatch、findFirst、findAny、forEach、toArray、reduce</code>等。</p>
<ol>
<li><p><code>max/min</code>可以获取流中的最大元素或最小元素；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法的签名如下，传进去一个比较器用于比较大小</span></span><br><span class="line"><span class="comment">// 返回值类型不是 T 而是 Optional&lt;T&gt;，这表示返回的结果可能为 null</span></span><br><span class="line">Optional&lt;T&gt; <span class="title function_">max</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span></span><br><span class="line">Optional&lt;T&gt; <span class="title function_">min</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Optional 类有以下方法 */</span></span><br><span class="line"><span class="comment">// value 不为 null 时返回 true</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPresent</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 返回实际值，若 value 为 null 则抛 NoSuchElementException</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span></span><br><span class="line"><span class="comment">// value 不为 null 就返回 value 否则返回 other</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">orElse</span><span class="params">(T other)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 value 为 null 的 Optional 对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title function_">empty</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 使用参数创建一个 Optional 对象，传入的 value 不能为 null</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">of</span><span class="params">(T value)</span></span><br><span class="line"><span class="comment">// 使用参数创建一个 Optional 对象，传入的 value 可以为 null</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">ofNullable</span><span class="params">(T value)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接使用 get 获取值</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> personList.stream().max(Comparator.comparing(Person::getAge)).get();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>count</code>可以统计流水线上元素个数；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计成年人的数目，返回的是 long</span></span><br><span class="line"><span class="type">long</span> <span class="variable">cnt</span> <span class="operator">=</span> personList.stream().filter(p -&gt; p.getAge() &gt;= <span class="number">18</span>).count();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Match</code></p>
<ol>
<li><code>allMatch</code>流水线所有元素都满足条件返回<code>true</code>，否则返回<code>false</code>；</li>
<li><code>anyMatch</code>流水线有元素满足条件返回<code>true</code>，否则返回<code>false</code>；</li>
<li><code>noneMatch</code>流水线没有元素满足条件返回<code>true</code>，否则返回<code>false</code>；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> personList.stream().allMatch(p -&gt; p.getAge() &gt;= <span class="number">18</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> personList.stream().anyMatch(p -&gt; p.getAge() &gt;= <span class="number">18</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> personList.stream().noneMatch(p -&gt; p.getAge() &gt;= <span class="number">18</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><code>findFirst/findAny</code>可以从流中查找元素；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; <span class="title function_">findFirst</span><span class="params">()</span>  <span class="comment">// 返回流中第一个元素（即使在并行流中也保证能获取第一个）</span></span><br><span class="line">Optional&lt;T&gt; <span class="title function_">findAny</span><span class="params">()</span>  <span class="comment">// 返回流中第一个元素（不保证顺序，并行流中谁先到就返回谁）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>forEach/forEachOrdered</code>可以遍历每个元素并执行某操作；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并行流下顺序不能保证</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span></span><br><span class="line"><span class="comment">// 可以保证并行流下也是有序的</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">forEachOrdered</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toArray</code>可以使用流元素构建数组；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] toArray()  <span class="comment">// 默认无参方法返回一个 Object 数组</span></span><br><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator)  <span class="comment">// 指定数组类型</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] objects = personList.stream().toArray();</span><br><span class="line"><span class="comment">// 没什么神秘的，传递数组的构造方法进去即可</span></span><br><span class="line">Person[] arr = personList.stream().toArray(Person[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>reduce</code>可以折叠流，即按照某个原则将流元素折叠成一个值；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; <span class="title function_">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line">T <span class="title function_">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line">&lt;U&gt; U <span class="title function_">reduce</span><span class="params">(U identity, BiFunction&lt;U, ? <span class="built_in">super</span> T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>第一个<code>reduce</code>函数，会先使用流中前两个元素得出运算结果，后面每次使用运算结果与下一个元素运算得出结果，以此类推最终得出一个结果；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取年纪最大的人员，Lambda 两个参数都是元素类型</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> personList.stream().reduce(</span><br><span class="line">    (a, b) -&gt; a.getAge() &gt; b.getAge() ? a : b</span><br><span class="line">).get();</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二个<code>reduce</code>函数，多一个<code>identity</code>参数表示初值。一开始会使用初值与第一个元素进行计算，后面按照上面的流程；</p>
</li>
<li><p>上面两种元素类型是<code>T</code>返回类型也是<code>T</code>，使用起来不是很方便。最后一个<code>reduce</code>函数是一个通用的函数，不要求返回类型一致。第三个参数在并行流下有用，表示多个线程的处理结果如何合并；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对所有人年纪求和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> personList.stream().reduce(<span class="number">0</span>, (sum, p) -&gt; sum += p.getAge(), Integer::sum);</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h6><p>目前我们都是使用<code>Collection</code>接口提供的方法获取流，除此之外还有一些其它方式获取流。例如在<code>Arrays</code>类中就提供了如下两个方法获取流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数组包装成流对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">stream</span><span class="params">(T[] array)</span></span><br><span class="line"><span class="comment">// 将数组的一部分包装成流对象，顾头不顾尾</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">stream</span><span class="params">(T[] array, <span class="type">int</span> startInclusive, <span class="type">int</span> endExclusive)</span></span><br></pre></td></tr></table></figure>
<p><code>Stream</code>类本身就有一些静态方法获取流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个空流</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">empty</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 返回只包含一个元素 t 的流</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T t)</span></span><br><span class="line"><span class="comment">// 使用传进来的元素构建流</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T... values)</span></span><br><span class="line"><span class="comment">// 通过 Supplier（工厂）生成流，数目无限</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">generate</span><span class="params">(Supplier&lt;T&gt; s)</span></span><br><span class="line"><span class="comment">// 生成无限流，元素为 seed, f(seed), f(f(seed))...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span></span><br></pre></td></tr></table></figure>
<p>一些案例有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成并输出 5 个随机数</span></span><br><span class="line">Stream.generate(Math::random).limit(<span class="number">5</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出前 5 个奇数</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>, i -&gt; i + <span class="number">2</span>).limit(<span class="number">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h5 id="函数式数据处理-收集器-TODO"><a href="#函数式数据处理-收集器-TODO" class="headerlink" title="函数式数据处理-收集器 TODO"></a>函数式数据处理-收集器 TODO</h5><h5 id="组合式异步编程-TODO"><a href="#组合式异步编程-TODO" class="headerlink" title="组合式异步编程 TODO"></a>组合式异步编程 TODO</h5><h5 id="Java8-的日期和时间-TODO"><a href="#Java8-的日期和时间-TODO" class="headerlink" title="Java8 的日期和时间 TODO"></a>Java8 的日期和时间 TODO</h5>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/index.html">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lu Yan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
