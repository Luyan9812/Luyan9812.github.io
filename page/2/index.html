<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Luyan&#39;s Bolg">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Luyan&#39;s Bolg">
<meta property="og:locale">
<meta property="article:author" content="Lu Yan">
<meta property="article:tag" content="Java, Vue3, Spring, MySQL">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/page/2/"/>





  <title>Luyan's Bolg</title>
  








<meta name="generator" content="Hexo 7.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Luyan's Bolg</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不积跬步，无以至千里；不积小流，无以成江海。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/index.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/20/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8809%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/06/20/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8809%EF%BC%89/" itemprop="url">Java 基础系列（09）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-06-20T12:09:54+08:00">
                2023-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h3><h4 id="线程基本概念"><a href="#线程基本概念" class="headerlink" title="线程基本概念"></a>线程基本概念</h4><p>线程表示一条单独的执行流，它有自己的程序执行计数器，有自己的栈。</p>
<h5 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h5><p>创建线程有两个方式，一种是继承<code>Thread</code>类，一种是实现<code>Runnable</code>接口。</p>
<h6 id="继承-Thread"><a href="#继承-Thread" class="headerlink" title="继承 Thread"></a>继承 Thread</h6><p>一个类继承<code>Thread</code>类并实现<code>run</code>方法来实现一个线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>run</code>方法类似于单线程下的<code>main</code>方法，线程从<code>run</code>的第一条语句开始执行直到结束。<br>线程想要执行需要先创建线程对象，再调用对象的<code>start</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HelloThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
<p>为什么重写<code>run</code>方法却需要调用<code>start</code>方法？因为<code>start</code>是启动线程方法，可以使线程成为一条独立的执行流，操作系统也会为其分配必要的资源。而<code>run</code>方法则定义线程要做的事情。<br>如果我不调用<code>start</code>而是直接调用<code>run</code>会怎样？其实从本质讲<code>run</code>就是一个普通的方法，直接调用<code>run</code>方法并不会新开线程，而是在本线程执行这个方法。<br><code>Thread</code>有一个静态方法可以获取当前在哪个线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title function_">currentThread</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>而每一个线程都有一个 id 和 name，可以使用下面的方法获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p><strong>Java 中会等所有的线程都执行结束然后整个程序结束，并不是 main 结束了，就不管其它线程了。</strong></p>
<h6 id="实现-Runnable"><a href="#实现-Runnable" class="headerlink" title="实现 Runnable"></a>实现 Runnable</h6><p>Java 只能单继承，所以有时候继承<code>Thread</code>就不方便了。此时我们可以实现<code>Runnable</code>接口，接口的定义很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面只有一个<code>run</code>方法，我们需要实现它，例如上面的例子可以改成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 展示一下当前在哪个线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello!&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们想要启动线程还是需要创建一个<code>Thread</code>对象，然后调用其<code>start</code>方法，不过此时创建对象的时候需要传递一个<code>Runnable</code>进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">HelloRunnable</span>());</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
<h5 id="线程基本属性和方法"><a href="#线程基本属性和方法" class="headerlink" title="线程基本属性和方法"></a>线程基本属性和方法</h5><p>线程有一些基本属性和方法，包含 id、name、优先级、状态、是否 daemon 线程、sleep 方法、yield 方法、join 方法以及一些过时的方法。</p>
<h6 id="id-name"><a href="#id-name" class="headerlink" title="id &amp; name"></a>id &amp; name</h6><p>正如上面所说，每个线程都有一个<code>id</code>和<code>name</code>。<code>id</code>是一个递增整数，每创建一个线程就<code>+1</code>。<br><code>name</code>的默认值是<code>Thread-</code>再跟上编号。<code>name</code>属性可以在<code>Thread</code>的构造方法里面指定，也可以调用<code>setName</code>方法进行设定。给线程起一个友好的名字可以方便我们的调试。</p>
<h6 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h6><p>线程有一个优先级的概念，Java 中优先级从 1 到 10，默认为 5，相关方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getPriority</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setPriority</span><span class="params">(<span class="type">int</span> newPriority)</span></span><br></pre></td></tr></table></figure>
<p>这个优先级会映射到操作系统的线程优先级，但是注意：优先级对操作系统只是一种建议，并非强制。因此我们不应过度依赖优先级。</p>
<h6 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h6><p>线程都有一个状态，我们可以使用下面的方法获取线程当前的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> State <span class="title function_">getState</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>返回值是<code>Thread.State</code>类型，是一种枚举类型，有以下取值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>NEW</code>，没调用过<code>start</code>的线程状态为<code>NEW</code></li>
<li><code>TERMINATED</code>，线程执行结束后的状态为<code>TERMINATED</code></li>
<li><code>RUNNABLE</code>，线程在执行<code>run</code>方法且没有阻塞的情况下状态为<code>RUNNABLE</code>；但这不等于线程正在执行，有可能线程在等待时间片。</li>
<li><code>BLOCKED</code>、<code>WAITING</code>、<code>TIMED_WAITING</code>都表示线程被阻塞，区别后面讲</li>
</ul>
<p><code>Thread</code>还有一个方法可以返回线程是否还活着：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>线程被启动后，直到<code>run</code>方法运行结束前返回值都是<code>true</code>。</p>
<h6 id="是否-daemon-线程"><a href="#是否-daemon-线程" class="headerlink" title="是否 daemon 线程"></a>是否 daemon 线程</h6><p><code>daemon</code>线程是辅助线程，一般为其它线程打辅助，相关方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isDaemon</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setDaemon</span><span class="params">(<span class="type">boolean</span> on)</span></span><br></pre></td></tr></table></figure>
<p>之前说 Java 会等所有线程运行结束才结束程序，但实际上 Java 不会等<code>daemon</code>线程。也就是说如果剩下的都是<code>daemon</code>线程，那么整个程序也是直接结束，毕竟主线程都运行结束了，这些辅助线程也就没有存在的必要了。<br>例如我们运行一个 Java 程序，除了主线程外，还会有一些诸如垃圾回收线程的辅助线程，主线程一结束，这些辅助线程也会直接退出。</p>
<h6 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h6><p><code>Thread</code>有一个静态的<code>sleep</code>方法，调用该方法能让线程睡眠指定时间，单位毫秒：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>
<p>睡眠期间线程会让出 CPU，且可以被中断，中断时会抛出<code>InterruptedException</code>异常。</p>
<h6 id="join"><a href="#join" class="headerlink" title="join"></a>join</h6><p>Java 中多个线程执行并不会互相等待，该执行完就执行完。此时就需要<code>join</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限定等待时长，设为 0 表示无限等待</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure>
<p>线程在等待过程中可以被中断，中断仍然会抛<code>InterruptedException</code>异常。<br>如果我们想让主线程在所有子线程执行完毕后再结束可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">thread.start();</span><br><span class="line">thread.join();</span><br><span class="line">System.out.println(<span class="string">&quot;主线程结束&quot;</span>);</span><br></pre></td></tr></table></figure>
<h6 id="过时方法"><a href="#过时方法" class="headerlink" title="过时方法"></a>过时方法</h6><p><code>Thread</code>中有一些看似可以控制线程生命周期的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">suspend</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resume</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>这些方法都被标记为过时，我们不应使用它们。</p>
<h5 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h5><p>对于不同线程来说，方法里面的参数及局部变量都是各有一份。但线程之间也是可以共享内存的，不同线程可以访问操作同一个对象。我们看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        counter++;</span><br><span class="line">        list.add(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">t1.list = t2.list = list;</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">System.out.println(MyThread.counter);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<p>2<br>[Thread-0, Thread-1]<br>大多数情况下程序输出如左所示，可以看出两个线程确实共享了内存。</p>
<h6 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h6><p>竞态条件指的是多个线程访问操作一个对象时，最终的执行结果与执行时序有关，可能正确有可能不正确，看例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">System.out.println(MyThread.counter);</span><br></pre></td></tr></table></figure>
<p>这个例子中，每个线程都会将某一个静态变量自增 1000，一共两个线程。预期结果应该是 2000，多测执行后发现结果可能是 2000，也有可能会出现小于 2000 的其它数字。出现这个问题的原因和<code>count++</code>的执行流程有关，流程如下：</p>
<ol>
<li>取变量<code>count</code>的值</li>
<li>在当前值的基础上<code>+1</code></li>
<li>将新值赋值给变量<code>count</code></li>
</ol>
<p>多线程运行的时候，可能在某一刻同时执行第一步，取到了相同的值，所以出现了漏加的问题。<br>解决这样问题的方式有很多 ，例如：</p>
<ol>
<li>使用<code>synchronized</code>关键字</li>
<li>使用显示锁</li>
<li>使用原子变量</li>
</ol>
<p>后面会对这些方法做详细介绍。</p>
<h6 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h6><p>多个线程可以访问操作同一个变量，但一个线程对共享变量的操作，另一个线程不一定能马上看到，甚至永远也看不到，看例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        MyThread.shutdown = <span class="literal">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Exit Main&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">shutdown</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!shutdown) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Exit Child!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据直觉，子线程会做死循环，直到 1 秒后主线程修改了变量<code>shutdown</code>，最终两个线程都会圆满结束。实际上，主线程会正常退出，但子线程会一直执行。下面阐述一下原因：<br>因为是死循环，所以一开始子线程会频繁访问变量<code>shutdown</code>，于是这个变量会缓存到寄存器里。接下来主线程修改了变量<code>shutdown</code>，但子线程压根不从内存读取这个变量，而是在寄存器缓存里面读取，所以这个修改子线程根本看不到，于是就会一直死循环。解决这个问题的方案可以：</p>
<ol>
<li>使用<code>volatile</code>关键字；</li>
<li>使用<code>synchronized</code>关键字或显示锁同步；</li>
</ol>
<p>这些方法在后面也会详细介绍。</p>
<h5 id="线程的优点及成本"><a href="#线程的优点及成本" class="headerlink" title="线程的优点及成本"></a>线程的优点及成本</h5><p>多线程的优点主要有：</p>
<ol>
<li>充分利用多 CPU 的计算能力；</li>
<li>充分利用硬件资源，CPU 与 IO 或磁盘操作完全是可以同时进行，此时就比较适合使用多线程来操作；</li>
<li>在存在用户界面的程序中，界面和后台任务通常使用不同的线程，否则在处理后台任务时，界面会一直不响应，体验很差；</li>
</ol>
<p>但我们需要知道，使用线程是有成本的。首先创建线程需要消耗操作系统的资源，操作系统会为每一个线程创建必要的数据结构、栈、程序计数器等，且创建线程本身也需要一定的时间。此外线程的调度和切换也是有成本的，当有大量线程的时候，操作系统会忙于调度，而每一次切换线程都需要保存当前线程的上下文状态，并恢复将要执行线程的上下文状态，整个过程称为上下文切换。<br>一般来说，对于 CPU 密集型的任务就不适合创建多于 CPU 数量的线程。</p>
<h4 id="理解-synchronized"><a href="#理解-synchronized" class="headerlink" title="理解 synchronized"></a>理解 synchronized</h4><h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><p><code>synchronized</code>关键字可以修饰实例方法、静态方法和代码块，我们依次介绍。</p>
<h6 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h6><p>上面介绍的计数器在多个线程并发执行<code>counter++</code>会出现问题，而原因就是这条语句不是原子操作，这个问题可以使用<code>synchronized</code>关键字解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Counter counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(Counter counter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.counter = counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">            counter.incr();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(counter);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(counter);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line"><span class="comment">// 这边一定会输出 2000</span></span><br><span class="line">System.out.println(counter.getCounter());</span><br></pre></td></tr></table></figure>
<p><code>Counter</code>是一个简单的计数器类，里面的<code>incr</code>和<code>getCounter</code>方法都被<code>synchronized</code>关键字修饰。事实上就是加锁，每个对象都有一个锁和等待队列，锁只能被一个线程持有，其它试图获取锁的线程需要等待。执行<code>synchronized</code>实例方法的过程大致如下：</p>
<ol>
<li>尝试获取锁，成功获取进行下一步，否则阻塞并加入等待队列；</li>
<li>执行实例方法体；</li>
<li>释放锁，如果等待队列里有线程，则从中选一个唤醒；若有多个等待的线程，唤醒哪一个是不一定的，不能保证公平性。</li>
</ol>
<p>当前线程不能获取锁而加入等待队列的时候状态会变为<code>BLOCKED</code>。<br>一个对象里所有的<code>synchronized</code>方法同一时刻只能被一个线程访问，这个例子里面如果一个线程正在访问<code>incr</code>方法，那么另一个线程即使想要访问的是<code>getCounter</code>方法也会被阻塞。注意，我们限制的是同一个对象中的加锁实例方法，具体的说<code>synchronized</code>实例方法保护的是当前对象即<code>this</code>。<strong>总结来说就是同一个对象的加锁方法之间不能并发访问，加锁方法与非加锁方法之间不限制。</strong>所以需要保护一个变量的时候，我们会给所有访问该变量的方法加上<code>synchronized</code>关键字。</p>
<h6 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h6><p><code>synchronized</code>关键字也可以用于静态方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前就介绍过，不同对象的实例方法都是独立的，但静态方法是共享的。因为静态方法属于类而不是对象，上面说的<code>synchronized</code>实例方法保护的是<code>this</code>，那么<code>synchronized</code>静态方法保护的是<code>StaticCounter.class</code>。<br>正是因为<code>synchronized</code>静态方法和实例方法保护的不是同一个对象，所以不同线程可以同时访问加锁静态方法与加锁实例方法。</p>
<h6 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h6><p><code>synchronized</code>关键字除了可以修饰方法，还可以修饰代码块。例如下面的写法就和<code>Counter</code>类等价：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> counter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>synchronized</code>关键字后面小括号中写需要保护的对象，我们这边写<code>this</code>就表示保护当前对象。我们也可以使用一样的方法改造静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (StaticCounter.class) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (StaticCounter.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> counter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上考虑一下本质，所谓的保护对象就是每次访问的时候获取这个对象的锁，能获取到才会执行方法体。而每一个对象都有一个锁，所以可以下出下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">return</span> counter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个代码里面可以看出，我们每次会获取对象<code>lock</code>的锁。这个和使用<code>this</code>相比更灵活，我们可以自己配置不同的锁来适应不同的运用场景。</p>
<h5 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h5><p>了解完<code>synchronized</code>关键字的基本用法之后，我们再从可重入性、内存可见性、死锁的角度进一步介绍。</p>
<h6 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h6><p>可重入性指线程获取锁之后，在方法中调用其它需要同一种锁的代码时可以直接调用。这是一种很自然的性质，之所以强调是因为有其它锁是不可重入的。<br>可重入性的实现是记录锁的持有线程及持有数量，在调用被<code>synchronized</code>保护的代码时首先检查对象是否已被锁，如果是再检查是否被当前线程锁定，如果是增加持有数量；如果不是被当前线程锁定则等待；释放锁时减少持有数量，数量变为 0 时才算是释放整个锁。</p>
<h6 id="内存可见性-1"><a href="#内存可见性-1" class="headerlink" title="内存可见性"></a>内存可见性</h6><p><code>synchronized</code>关键字的主要作用是保证操作的原子性，那如果一个操作本身就是原子操作，那么是否还需要使用<code>synchronized</code>关键字？例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Switcher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> on;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOn</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> on;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOn</span><span class="params">(<span class="type">boolean</span> on)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.on = on;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>long</code>和<code>double</code>在 32 位 JVM 上的读写不是原子性的，而在 64 位 JVM 上是原子性的；<br>引用的读写无论是 32 位还是 64 位都是原子性的，因为引用本质上就是指针，指针大小跟位数是一致的；<br>从原子性的角度讲确实不需要使用<code>synchronized</code>关键字，但还有一个内存可见性。子线程在频繁访问某变量的时候，不一定会从内存读取这个变量的值，也有可能从寄存器之类的缓存读写。使用<code>synchronized</code>关键字在获取或释放锁时一定会操作内存。<br>不过为了内存可见性而使用<code>synchronized</code>关键字成本就太高了。有更轻量级的实现是使用<code>volatile</code>关键字修饰变量如<code>private volatile boolean on;</code>也能保证读写的是最新的内存内容。</p>
<h6 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h6><p>死锁是类似这样的现象：a 线程持有锁 A 在等待锁 B，b 线程持有锁 B 在等待锁 A，a 与 b 互相等待，最终两者都无法执行。我们应该怎么解决死锁问题呢？<br>首先，我们应该避免在持有一个锁的同时去申请另一个锁；如果确实需要多个锁，所有代码应该按照相同的顺序去申请锁，例如上面的例子中线程 a 与 b 都先申请锁 A 再申请锁 B；不过在复杂的应用场景下这种约定很难实现，我们可以使用后续介绍的显式锁接口，它支持尝试获取锁和带时间限制的获取锁，使用这些方法可以在获取不到锁的时候释放已经持有的锁，然后再次尝试获取锁或干脆放弃以避免死锁。</p>
<h5 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h5><p> <code>Collections</code>类中有一些方法可以返回线程安全的容器，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">synchronizedCollection</span><span class="params">(Collection&lt;T&gt; c)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title function_">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span></span><br></pre></td></tr></table></figure>
<p>返回的这些容器都是给方法加上<code>synchronized</code>关键字实现的，其部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SynchronizedCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Collection&lt;E&gt; c; <span class="comment">//Backing Collection</span></span><br><span class="line">    <span class="keyword">final</span> Object mutex; <span class="comment">//Object on which to synchronize</span></span><br><span class="line">    SynchronizedCollection(Collection&lt;E&gt; c) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">        mutex = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.size();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.add(e);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.remove(o);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为全部加上了<code>synchronized</code>关键字，所以容器里的所有操作相当于原子操作。但是客户端在调用的时候还是有可能出现问题的，至少有复合操作、伪同步、迭代这几种情况需要注意。</p>
<h6 id="复合操作"><a href="#复合操作" class="headerlink" title="复合操作"></a>复合操作</h6><p>我们知道同步容器的单个操作都是原子操作，但多个操作组合在一起就不一定了。看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">EnhancedMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;K, V&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EnhancedMap</span><span class="params">(Map&lt;K, V&gt; map)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = Collections.synchronizedMap(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="literal">null</span>) <span class="keyword">return</span> old;</span><br><span class="line">        <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们实现了一个增强版的 Map，里面主要添加了一个<code>putIfAbsent</code>方法，这个方法只有在键不存在的时候才会执行插入。<br>多线程执行<code>putIfAbsent</code>方法时，可能在某一时刻有多个线程执行<code>map.get</code>方法且都返回<code>null</code>，于是这些线程又都执行了<code>map.put</code>，这很显然与我们的设计相悖。</p>
<h6 id="伪同步"><a href="#伪同步" class="headerlink" title="伪同步"></a>伪同步</h6><p>基于上面的案例，我们将<code>putIfAbsent</code>方法修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    <span class="keyword">if</span> (old != <span class="literal">null</span>) <span class="keyword">return</span> old;</span><br><span class="line">    <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们仅仅是给<code>putIfAbsent</code>加上<code>synchronized</code>关键字修饰，是否能够解决上面提出的问题？<br>答案是否定的，因为同步错了对象。<code>EnhancedMap</code>中<code>putIfAbsent</code>和<code>put</code>方法可以被多线程同时调用，这就可能出现一种情况：<code>putIfAbsent</code>方法中判定的时候发现键不存在，然后执行插入的时候发现这个键已经被<code>put</code>方法插入进去了，此时又与我们的设计相悖。<br>想要解决这个问题，所有方法必须使用相同的锁。即可以是<code>EnhancedMap</code>对象的锁，也可以是内部<code>map</code>对象的锁。</p>
<ul>
<li>如果使用<code>EnhancedMap</code>对象的锁，那么<code>EnhancedMap</code>里所有方法都需要加<code>synchronized</code>关键字修饰。</li>
<li>如果使用内部<code>map</code>对象的锁，<code>putIfAbsent</code>方法就可以改为：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(map)&#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(old != <span class="literal">null</span>) <span class="keyword">return</span> old;</span><br><span class="line">        <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h6><p>对于同步容器对象的单个操作是安全的，但是迭代并不安全，也就是说迭代和其它方法可以并发运行。<br>这种情况下，如果一个线程修改容器，另一个线程遍历容器，那么遍历的时候很可能抛异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure>
<p>解决方案可以在遍历的时候对容器加锁。</p>
<h5 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h5><p>同步容器使用<code>synchronized</code>关键字，效率较低。Java 还有许多专为并发设计的容器类：</p>
<ul>
<li>CopyOnWriteArrayList</li>
<li>ConcurrentHashMap</li>
<li>ConcurrentLinkedQueue</li>
<li>ConcurrentSkipListSet</li>
</ul>
<p>这些容器都没有使用<code>synchronized</code>关键字但线程安全，具体后续章节介绍。</p>
<h4 id="线程的基本协作机制"><a href="#线程的基本协作机制" class="headerlink" title="线程的基本协作机制"></a>线程的基本协作机制</h4><p>线程之间除了互相竞争资源外，还经常需要互相协作。线程间协作的基本机制是<code>wait/notify</code>，我们下面详细讨论。</p>
<h5 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait&#x2F;notify"></a>wait&#x2F;notify</h5><p>Java 在<code>Object</code>类而不是<code>Thread</code>类里面定义了一些线程协作方法，这使得每一个对象都可以调用这些方法。这些方法分为两类，一类是<code>wait</code>，一类是<code>notify</code>。<br>一共有两个<code>wait</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>
<p>带参数的表示最多等待时长，单位是毫秒，传入 0 表示无限期等待。不带参数的<code>wait</code>方法实际上是调用<code>wait(0)</code>表示无限期等待。线程在等待期间可以被中断，中断时会抛异常<code>InterruptedException</code>。<br>我们之前说每个对象都有锁和等待队列，如果线程获取锁失败会将线程加入到等待队列里面，这个等待队列称为<strong>锁的等待队列</strong>。除此之外，每个对象还有一个等待队列，表示条件队列，我们使用这个队列进行线程间的协作。调用<code>wait</code>方法会将线程加入到条件队列，表示它需要某些条件，这个条件往往由其它线程提供。所需条件满足后，其它线程可以调用阻塞线程的<code>notify</code>方法将其唤醒：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p><code>notify</code>方法会从条件队列里选一个线程，将其从队列里删除并唤醒。<code>notifyAll</code>则是从队列里删除并唤醒所有线程。看一个案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WaitThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;FINISH&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">wake</span><span class="params">()</span> &#123;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">WaitThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t.wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子有两个线程：主线程和子线程。子线程运行后会陷入等待，主线程 1 秒后会唤醒子线程。<br>这里面有个注意点，<code>wait</code>和<code>notify</code>的方法调用需要写在同步代码块里，即调用谁的<code>wait/notify</code>方法，就需要获取谁的锁。如果调用两者的时候没有获取到锁，会抛异常<code>java.lang.IllegalMonitorStateException</code>。<br>那么你可能会疑惑，调用<code>wait</code>方法的时候需要持有锁，然后线程陷入等待，此时其它线程还怎么获取锁调用<code>notify</code>？这我们就要详细了解一下<code>wait</code>方法，调用<code>wait</code>之后：</p>
<ol>
<li>将当前线程放入条件等待队列，<strong>释放对象锁</strong>，线程状态变为<code>WAITING</code>或<code>TIMED_WAITING</code>；</li>
<li>等待时间到或被其它线程调用<code>notify</code>唤醒后，需要重新竞争对象锁（代码写在同步代码块中当然需要锁）：<ul>
<li>获取到了对象锁，线程状态置为<code>RUNNABLE</code>，代码从<code>wait</code>里返回；</li>
<li>没获取到锁，将线程放入锁的等待队列，线程状态置为<code>BLOCKED</code>；直到获取到锁才会从<code>wait</code>里返回。</li>
</ul>
</li>
</ol>
<p>在多线程协作中，设线程 A 需要线程 B 与 C 先做完某些操作然后再执行 A 里的代码。在 B 与 C 结束前 A 应该陷入等待，若 B 提前完成任务调用<code>notify</code>通知了 A，我们知道此时 A 是不能唤醒的，因为 A 还需要等待 C。因此我们往往这么写代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;  <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">while</span>(等待条件不成立)  <span class="comment">// 每次从 wait 返回后继续进行判定</span></span><br><span class="line">        obj.wait();</span><br><span class="line">    <span class="comment">// 满足条件后的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>调用<code>wait</code>会释放锁，而调用<code>notify</code>并不会释放。而想要从<code>wait</code>方法返回需要获取到锁，因此只有等包含<code>notify</code>的同步块里代码全部执行完毕，等待的线程才会从<code>wait</code>调用里返回。</p>
<h5 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h5><p>生产者与消费者问题是典型的线程协作案例，生产者与消费共享一个队列，每次生产者往队列添加一个元素，消费者从队列获取一个元素，队列满时生产者进行等待，队列空时消费者等待。生产者和消费者的协作变量是一个队列，用于存放物品的队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyBlockQueue</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;E&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBlockQueue</span><span class="params">(<span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">        <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.size() == limit) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(e);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先设计一个阻塞队列，<code>limit</code>表示队列的最大长度。每次取或放东西时会根据队列状态令线程陷入等待，每次取或放东西成功之后使用<code>notifyAll</code>方法通知所有等待的线程。这个地方使用<code>notify</code>行不行？答案是不行，因为生产者和消费者共用一个条件队列，唤醒时没法指定唤醒谁，所以需要调用<code>notifyAll</code>来唤醒全部。<br>生产者和消费者线程定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyBlockQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(MyBlockQueue&lt;String&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">task</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">                queue.put(task);</span><br><span class="line">                System.out.println(<span class="string">&quot;Produce: &quot;</span> + task);</span><br><span class="line">                Thread.sleep((<span class="type">int</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyBlockQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(MyBlockQueue&lt;String&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">task</span> <span class="operator">=</span> queue.take();</span><br><span class="line">                System.out.println(<span class="string">&quot;Consume: &quot;</span> + task);</span><br><span class="line">                Thread.sleep((<span class="type">int</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主程序代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    MyBlockQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">MyBlockQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Producer</span>(queue).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Consumer</span>(queue).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们实现的阻塞队列只是为了演示，Java 提供了专门的阻塞队列实现，包括：</p>
<ol>
<li>接口<code>BlockingQueue</code>和<code>BlockingDeque</code></li>
<li>基于数组的实现类<code>ArrayBlockingQueue</code></li>
<li>基于链表的实现类<code>LinkedBlockingQueue</code>和<code>LinkedBlockingDeque</code></li>
<li>基于堆的实现类<code>PriorityBlockingQueue</code></li>
</ol>
<p>我们应该优先选择这些类而不是自己实现。</p>
<h5 id="同时开始"><a href="#同时开始" class="headerlink" title="同时开始"></a>同时开始</h5><p>类似于运动员比赛，所有运动员在听到枪响之后统一开始行动。下面我们模拟这个过程，我们将会有一个主线程和 N 个子线程，每个子线程表示一个运动员，主线程表示裁判。它们的协作变量是一个开始信号，所以我们先定义一个类<code>FireFlag</code>表示协作变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FireFlag</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">fire</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">waitForFire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (!fire) wait();  <span class="comment">// 为防止误唤醒，我们一般套个循环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span> &#123;</span><br><span class="line">        fire = <span class="literal">true</span>;</span><br><span class="line">        notifyAll();  <span class="comment">// 通知所有线程开始</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们下面将设计运动员类，所有运动员都将持有同一个<code>FireFlag</code>对象并调用<code>waitForFire</code>方法等待比赛开始，等所有运动员线程就绪后，我们调用<code>FireFlag</code>对象的<code>fire</code>方法通知比赛开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Racer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> FireFlag flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Racer</span><span class="params">(FireFlag flag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            flag.waitForFire();</span><br><span class="line">            <span class="comment">// 下面是线程要做的工作</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; fire!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主程序代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    Thread[] racers = <span class="keyword">new</span> <span class="title class_">Thread</span>[num];</span><br><span class="line">    <span class="type">FireFlag</span> <span class="variable">fireFlag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FireFlag</span>();  <span class="comment">// 信号枪</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        racers[i] = <span class="keyword">new</span> <span class="title class_">Racer</span>(fireFlag);</span><br><span class="line">        racers[i].start();  <span class="comment">// 线程一创建完成就直接启动，反正会陷入等待</span></span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    fireFlag.fire();  <span class="comment">// 通知所有线程开始工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="等待结束"><a href="#等待结束" class="headerlink" title="等待结束"></a>等待结束</h5><p>之前我们想让主线程等所有子线程结束再结束，我们会在主线程调用所有子线程的<code>join</code>方法。而<code>join</code>的主要实现是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，只要子线程还活着，就将主线程阻塞。当线程运行结束的时候，Java 系统会调用<code>notifyAll</code>来通知等待的线程。<br><strong>总结：</strong>哪个线程调用<code>wait</code>就是哪个线程阻塞，调用的是谁的<code>wait</code>就使用谁的条件队列。<br>线程多的时候需要逐一调用<code>join</code>方法，比较麻烦。我们介绍一种新的实现，主线程与子线程的协作变量是一个数，这个数初始表示子线程的个数，主线程一直等待直到这个数为 0，而每一个子线程结束运行的时候将这个数<code>-1</code>。我们设计一个类<code>MyLatch</code>表示协作对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLatch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;  <span class="comment">// 初始化为子线程个数</span></span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;  <span class="comment">// 只要子线程还存在就让主线程等待</span></span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">cutDown</span><span class="params">()</span> &#123;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;  <span class="comment">// 没有子线程了就通知主线程</span></span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是子线程类实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyLatch myLatch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(MyLatch myLatch)</span> &#123;  <span class="comment">// 所有子线程共享一个 MyLatch</span></span><br><span class="line">        <span class="built_in">this</span>.myLatch = myLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            Thread.sleep((<span class="type">int</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">            myLatch.cutDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">MyLatch</span> <span class="variable">myLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLatch</span>(num);</span><br><span class="line">    Thread[] children = <span class="keyword">new</span> <span class="title class_">Thread</span>[num];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        children[i] = <span class="keyword">new</span> <span class="title class_">Worker</span>(myLatch);</span><br><span class="line">        children[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">    myLatch.await();</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MyLatch</code>只是一种演示，Java 里面有专门的同步协作工具类<code>CountDownLatch</code>后面介绍。<br><code>MyLatch</code>是一种比较通用的工具类，我们可以借助它实现上面“同时开始”的功能。首先将<code>count</code>设为 1，所有子线程创建出来时调用<code>await</code>进行阻塞，当所有子线程都创建完毕，主线程调用<code>cutDown</code>方法通知所有子线程开始。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Racer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyLatch myLatch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Racer</span><span class="params">(MyLatch myLatch)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myLatch = myLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            myLatch.await();</span><br><span class="line">            <span class="comment">// 子线程的工作</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 工作&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">MyLatch</span> <span class="variable">myLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLatch</span>(<span class="number">1</span>);</span><br><span class="line">    Thread[] children = <span class="keyword">new</span> <span class="title class_">Thread</span>[num];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        children[i] = <span class="keyword">new</span> <span class="title class_">Racer</span>(myLatch);</span><br><span class="line">        children[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    myLatch.cutDown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="异步结果"><a href="#异步结果" class="headerlink" title="异步结果"></a>异步结果</h5><p>在主从模式中，子线程做耗时任务，主线程获取计算结果。手动维护子线程的创建及其与主线程的协作是很麻烦的事情，于是我们可以设计一套框架来自动做这些事情。<br>Java 中表示任务的接口是<code>Callable</code>，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了表示异步调用的结果，我们定义一个接口<code>MyFuture</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFuture</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口中<code>get</code>方法会返回真正的计算结果，若还没计算结束就阻塞直到结束。<br>为了避免手动创建并维护子线程，我们定义一个<code>MyExecutor</code>类，里面定义一个<code>execute</code>方法。方法会执行操作并返回异步结果，之所以不直接返回同步结果是因为我们不想调用<code>execute</code>会立刻陷入阻塞，方法声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;V&gt; MyFuture&lt;V&gt; <span class="title function_">execute</span><span class="params">(<span class="keyword">final</span> Callable&lt;V&gt; task)</span></span><br></pre></td></tr></table></figure>
<p>这样在主线程我们就可以写下面的代码进行异步调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">MyExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyExecutor</span>();</span><br><span class="line">    <span class="comment">// 需要子线程做的任务</span></span><br><span class="line">    Callable&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mills</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * <span class="number">1000</span>);</span><br><span class="line">            <span class="comment">// 模拟耗时任务</span></span><br><span class="line">            Thread.sleep(mills);</span><br><span class="line">            <span class="keyword">return</span> mills;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 调用 MyExecutor 的 execute 方法返回异步结果</span></span><br><span class="line">    MyFuture&lt;Integer&gt; future = executor.execute(task);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 get 方法时才会实际阻塞主线程</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封装好的子线程定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExecuteThread</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">V</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Exception</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">done</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; task;</span><br><span class="line">    <span class="keyword">private</span> Object lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExecuteThread</span><span class="params">(Callable&lt;V&gt; task, Object lock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.task = task;</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = task.call();  <span class="comment">// 执行任务</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            exception = e;  <span class="comment">// 保存异常信息</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                done = <span class="literal">true</span>;  <span class="comment">// 子线程成功执行完毕</span></span><br><span class="line">                lock.notifyAll();  <span class="comment">// 通知所有等待的线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Exception <span class="title function_">getException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MyExecutor</code>定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyExecutor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;V&gt; MyFuture&lt;V&gt; <span class="title function_">execute</span><span class="params">(<span class="keyword">final</span> Callable&lt;V&gt; task)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        ExecuteThread&lt;V&gt; thread = <span class="keyword">new</span> <span class="title class_">ExecuteThread</span>&lt;&gt;(task, lock);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyFuture</span>&lt;V&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!thread.isDone()) &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (thread.getException() != <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">throw</span> thread.getException();</span><br><span class="line">                    <span class="keyword">return</span> thread.getResult();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义的<code>MyExecutor</code>和<code>MyFuture</code>都是为了演示原理，实际上 Java 包含一套完整的框架：</p>
<ol>
<li>表示异步结果的接口<code>Future</code>和<code>FutureTask</code></li>
<li>执行异步任务的接口<code>Executor</code>以及包含更多功能的子接口<code>ExecutorService</code></li>
<li>用于创建<code>Executor</code>和<code>ExecutorService</code>的工厂类<code>Executors</code></li>
</ol>
<p>我们会在后续介绍这套框架。</p>
<h5 id="集合点"><a href="#集合点" class="headerlink" title="集合点"></a>集合点</h5><p>这类似于旅游，所有游客先自由活动，然后所有人在一个点集合。这些线程的协作变量就是这个集合点，我们定义<code>AssemblePoint</code>类描述这个点，类中定义变量<code>count</code>表示未到线程的个数，初始等于总线程数，每到一个线程就<code>count--</code>，当<code>count</code>变为 0 时表示所有线程到齐了，最后一个到的线程发通知。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AssemblePoint</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AssemblePoint</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;  <span class="comment">// 所有线程到齐了就通知大家</span></span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 否则陷入等待</span></span><br><span class="line">            <span class="keyword">while</span> (count != <span class="number">0</span>) wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tourist</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AssemblePoint ap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tourist</span><span class="params">(AssemblePoint ap)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ap = ap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="type">int</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 到场&quot;</span>);</span><br><span class="line">            ap.await();  <span class="comment">// 任务做完就去集合</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[num];</span><br><span class="line">    <span class="type">AssemblePoint</span> <span class="variable">ap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AssemblePoint</span>(num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        threads[i] = <span class="keyword">new</span> <span class="title class_">Tourist</span>(ap);</span><br><span class="line">        threads[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h4><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>线程开始运行后会执行<code>run</code>方法，<code>run</code>运行结束后线程就会退出。一般来说结束线程有以下场景：</p>
<ol>
<li>很多线程的执行任务是死循环，因此我们需要一种方式来关闭这种线程；</li>
<li>在图形界面程序中，许多线程是用户开启的，例如点击按钮开始下载，在下载过程中用户可能想要取消这个任务；</li>
<li>在一些场景下，程序会向服务器请求数据，但是超过指定时间就会自动取消这个任务；</li>
<li>有时我们会使用多个线程做同一件事，例如抢火车票，其中任一线程抢到票都需要通知其它线程取消。</li>
</ol>
<h5 id="关闭线程"><a href="#关闭线程" class="headerlink" title="关闭线程"></a>关闭线程</h5><p><code>Thread</code>类定义了<code>stop</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>这个方法看上去可以停止线程，但被标记为过时，我们<strong>不应该使用它</strong>。<br>Java 里停止线程的主要机制是中断，<strong>中断并不是强迫终止一个线程，它是一种协作机制，是给线程传递一个取消信号，由线程决定如何及何时退出</strong>。<code>Thread</code>定义了如下关于中断的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>每个线程都有一个标志位表示该线程是否被中断了，这三个方法分别：</p>
<ol>
<li><code>isInterrupted</code>是实例方法，返回中断标记位是否为<code>true</code>；</li>
<li><code>interrupt</code>是实例方法，表示中断对应的线程；</li>
<li><code>interrupted</code>是静态方法，它实际上会调用<code>Thread.currentThread()</code>操作当前线程。返回当前中断标记位是否为<code>true</code>，同时它还能清空中断标记位。即线程本来被中断了，调用这个方法会返回<code>true</code>，然后将这个标记位置为<code>false</code>。</li>
</ol>
<h5 id="线程对中断的反应"><a href="#线程对中断的反应" class="headerlink" title="线程对中断的反应"></a>线程对中断的反应</h5><p><code>interrupt()</code>对线程的影响与线程的状态及线程正在进行的 IO 操作有关，我们主要考虑线程状态。</p>
<h6 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h6><p>如果线程正在运行态且没有进行 IO 操作，<code>interrupt()</code><strong>只会</strong>设置线程的中断标记位。因此我们设计线程的时候应该在合适的位置检查标记位，看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterruptRunnableDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 检查线程的中断标记位</span></span><br><span class="line">        <span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="comment">// 操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="WAITING-TIMED-WAITING"><a href="#WAITING-TIMED-WAITING" class="headerlink" title="WAITING&#x2F;TIMED_WAITING"></a>WAITING&#x2F;TIMED_WAITING</h6><p>线程调用<code>join/wait/sleep</code>方法后会进入<code>WAITING/TIMED_WAITING</code>状态，在这些状态时，对线程对象调用<code>interrupt()</code>会使该线程抛出<code>InterruptedException</code>异常并将状态变为<code>RUNNABLE</code>。注意抛出异常后，<strong>中断标记位会被清空</strong>而不会设置为<code>true</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> ()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(isInterrupted());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">t.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">t.interrupt();</span><br></pre></td></tr></table></figure>
<p>程序的输出为<code>false</code>，因为出现中断异常会清空标记位。<br>我们一般捕获到<code>InterruptedException</code>表示要结束该线程，大致有两种处理方式：</p>
<ol>
<li>向上传递异常，由调用者处理；</li>
<li>某些情况下不能向上传递异常，例如<code>Thread</code>的<code>run</code>方法，它的声明是固定的，不能抛出受检异常。此时应该做合适的清理操作，清理后一般调用线程的<code>interrupt()</code>方法将标记位置为<code>true</code>，使得其它代码能够知道该线程是否发生了中断。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterruptWaitingDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟任务</span></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 清理操作并重设标记位</span></span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h6><p>如果线程在等待锁，对线程对象调用<code>interrupt()</code>方法只会设置中断标记位，并不会改变<code>BLOCKED</code>的状态。也就是说<code>interrupt()</code>并不能使等待锁的线程真正中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptSynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">            a.start();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            a.interrupt();</span><br><span class="line">            a.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先主线程调用<code>test</code>方法获取了锁<code>lock</code>，然后启动子线程<code>a</code>；<br>而子线程<code>a</code>因为等待锁<code>lock</code>陷入阻塞，此时主线程调用<code>a.interrupt()</code>中断子线程<code>a</code>，但这并不能改变<code>a</code>的阻塞状态；<br>接着主线程调用<code>a.join()</code>进入<code>a</code>的条件队列进行等待，本质上是调用<code>a.wait()</code>，过程中会释放对象<code>a</code>的锁而不是<code>lock</code>；<br>最终，主线程持有锁<code>lock</code>陷入等待，而子线程因为得不到<code>lock</code>也陷入等待，因此这个程序结束不了。</p>
<h6 id="NEW-TERMINATE"><a href="#NEW-TERMINATE" class="headerlink" title="NEW&#x2F;TERMINATE"></a>NEW&#x2F;TERMINATE</h6><p>如果线程还没有启动（NEW）或线程已经运行结束（TERMINATE），此时调用<code>interrupt()</code>对线程没有任何效果，中断标记位也不会进行设置。</p>
<h5 id="正确方式"><a href="#正确方式" class="headerlink" title="正确方式"></a>正确方式</h5><p><code>interrupt</code>不一定能真正中断线程，如果我们不知道线程正在做什么，我们不应该贸然调用<code>interrupt</code>中断它，从而误认为这样可以取消线程。<br>对于以线程提供服务的程序来说，它应该封装取消操作暴露给调用者，调用者应该调用这些封装的方法而不是直接使用<code>interrupt</code>。Java 并发库就提供了单独的取消方法，例如<code>Future</code>提供了如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br></pre></td></tr></table></figure>
<p>再如<code>ExecutorService</code>提供了下面两个关闭的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>这些我们后面再详细探讨。</p>
<h3 id="并发包的基石"><a href="#并发包的基石" class="headerlink" title="并发包的基石"></a>并发包的基石</h3><h4 id="原子变量与CAS"><a href="#原子变量与CAS" class="headerlink" title="原子变量与CAS"></a>原子变量与CAS</h4><p>之前为了保证某些操作的原子性，我们会使用关键字<code>synchronized</code>。但使用关键字<code>synchronized</code>成本太高，在这背景下原子变量就出现了，Java 并发包的基本原子变量类型主要有：</p>
<ul>
<li><code>AtomicBoolean</code>原子<code>Boolean</code>类型，常用来表示一个标志位；</li>
<li><code>AtomicInteger</code>原子<code>Integer</code>类型；</li>
<li><code>AtomicLong</code>原子<code>Long</code>类型，常用来在程序中生成唯一序列号；</li>
<li><code>AtomicReference</code>原子引用类型，以原子方式更新复杂类型。</li>
</ul>
<p>这些类大同小异，我们主要介绍<code>AtomicInteger</code>。<br><code>AtomicInteger</code>有两个构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">(<span class="type">int</span> initialValue)</span></span><br></pre></td></tr></table></figure>
<p>其中无参构造默认使用 0 作为初值。<br>此外我们可以调用下面的方法获取或设置<code>AtomicInteger</code>里面的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> newValue)</span></span><br></pre></td></tr></table></figure>
<p>之所以把<code>AtomicInteger</code>称作原子变量，是因为它里面包含一些以原子方式进行操作的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以原子方式获取旧值并设置新值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span></span><br><span class="line"><span class="comment">// 以原子方式获取旧值并给当前值 +1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 以原子方式获取旧值并给当前值 -1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 以原子方式获取旧值并给当前值 +delta</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span></span><br><span class="line"><span class="comment">// 以原子方式给当前值 +1 并获取新值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 以原子方式给当前值 -1 并获取新值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">decrementAndGet</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 以原子方式给当前值 +delta 并获取新值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">addAndGet</span><span class="params">(<span class="type">int</span> delta)</span></span><br></pre></td></tr></table></figure>
<p>这些方法的实现都依赖于另一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span></span><br></pre></td></tr></table></figure>
<p>这是一个非常重要的方法，比较并设置，我们将其简称为 <strong>CAS</strong>。它有两个参数<code>expect</code>和<code>update</code>，它的功能是：如果当前值是<code>expect</code>那么就将其改为<code>update</code>，否则不做修改，这个方法会返回是否修改成功。多线程操作同一个原子变量总能保证正确性。<br>上面的原子操作实现基本类似，我们看一下<code>incrementAndGet</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路很简单，每次记录当前值，然后设置新值的时候比较当前值是否发生了修改，若没修改自己就修改它，否则若是当前值被其它线程修改了就重复上述操作。<br><code>synchronized</code>是悲观锁，它假定更新很可能出现冲突，于是所有的更新都需要获取到锁才能继续下去。而这边的原子变量是乐观锁，它假定冲突较少，如果检测到冲突就再试一次。<br>我们可以利用原子变量实现类似<code>synchronized</code>的悲观锁效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">status</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!status.compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            Thread.<span class="keyword">yield</span>();  <span class="comment">// 将线程从执行态改为就绪态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        status.compareAndSet(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程访问互斥内容时，先调用<code>lock</code>方法进行锁定。若有多个线程想要访问同一块内容，后来者会陷入<code>lock</code>的循环中直到先来者调用<code>unlock</code>解除锁定。</p>
<h4 id="显式锁"><a href="#显式锁" class="headerlink" title="显式锁"></a>显式锁</h4><p>显式锁主要为了解决<code>synchronized</code>的局限性，相关的接口与类主要有：</p>
<ol>
<li>锁接口<code>Lock</code>，其主要的实现类<code>ReentrantLock</code>；</li>
<li>读写锁接口<code>ReadWriteLock</code>，其主要的实现类<code>ReentrantReadWriteLock</code>。</li>
</ol>
<h5 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h5><p>显式锁接口<code>Lock</code>定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">    Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lock()/unlock()</code>就是普通的申请和释放锁方法，<code>lock</code>会阻塞直到获取到锁；</li>
<li><code>lockInterruptibly() </code>是可以响应中断的申请锁方法，若被其它线程中断会抛出<code>InterruptedException</code>；</li>
<li><code>tryLock()</code>尝试获取锁，获取到锁返回<code>true</code>，获取不到也不会阻塞直接返回<code>false</code>；</li>
<li><code>boolean tryLock(long time, TimeUnit unit)</code>与上面一样也是尝试获取锁，但是未获取到会阻塞一段时间，期间可以被中断，中断会抛出<code>InterruptedException</code>；</li>
<li><code>newCondition()</code>新建一个条件，关于条件后面说。</li>
</ul>
<h5 id="ReentrantLock-类"><a href="#ReentrantLock-类" class="headerlink" title="ReentrantLock 类"></a>ReentrantLock 类</h5><h6 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h6><p><code>ReentrantLock</code>有两个构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span></span><br></pre></td></tr></table></figure>
<p>参数<code>fair</code>表示是否保证公平，公平指的是等待时间最长的线程优先获取锁。因为保证公平会影响效率，所以默认是不保证的，<code>synchronized</code>也是不保证公平的。<br>一般而言一个线程获取到锁之后，即使后面发生异常也应该把锁释放。于是调用<code>lock</code>之后会使用<code>try</code>将后面的代码包裹起来，然后在<code>finally</code>里面释放锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;  <span class="comment">// lock 后面的代码放到 try 里</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  <span class="comment">// finally 里面释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="tryLock-避免死锁"><a href="#tryLock-避免死锁" class="headerlink" title="tryLock 避免死锁"></a>tryLock 避免死锁</h6><p>在持有一个锁去获取另一个锁而不得的时候，放弃已经得到的锁，给其它线程获取锁的机会，然后再尝试获取所有锁。假设有银行账户类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">double</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.money += money;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        add(-money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lock.tryLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Account</code>类里的<code>money</code>表示余额，<code>add</code>与<code>reduce</code>用来操作余额。我们对两个账户进行转账的时候应该将两个账户都锁定，下面我们使用<code>lock</code>进行锁定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccountMgr</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NotEnoughMoneyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account from, Account to, <span class="type">double</span> money)</span> </span><br><span class="line">      <span class="keyword">throws</span> NotEnoughMoneyException &#123;</span><br><span class="line">        from.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            to.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (from.getMoney() &lt; money) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotEnoughMoneyException</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    from.reduce(money);   </span><br><span class="line">                    to.add(money);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                to.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            from.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码看似没有问题，考虑这样的场景：A 与 B 两个账户在同一时刻向对象转账，此时两人都持有自己的锁，且都在等待对方的锁，那么就陷入了死锁。我们不妨模拟死锁场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">accountNum</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    Account[] accounts = <span class="keyword">new</span> <span class="title class_">Account</span>[accountNum];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; accountNum; ++i) &#123;</span><br><span class="line">        accounts[i] = <span class="keyword">new</span> <span class="title class_">Account</span>(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[threadNum];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadNum; ++i) &#123;</span><br><span class="line">        threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">loopNum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; loopNum; ++k) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> random.nextInt(accountNum);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> random.nextInt(accountNum);</span><br><span class="line">                    <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> random.nextInt(<span class="number">10</span>);</span><br><span class="line">                    <span class="keyword">if</span> (m != n) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            AccountMgr.transfer(accounts[m], accounts[n], money);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (AccountMgr.NotEnoughMoneyException e) &#123;&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        threads[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 10 个账户，100 个线程。每个线程随机挑两个账户进行转账，挑 100 次，这个程序大概率能复现死锁。因此我们直到直接使用<code>lock</code>是不行的，我需要使用<code>tryLock</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">tryTransfer</span><span class="params">(Account from, Account to, <span class="type">double</span> money)</span> </span><br><span class="line">  <span class="keyword">throws</span> NotEnoughMoneyException &#123;</span><br><span class="line">    <span class="keyword">if</span> (!from.tryLock()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!to.tryLock()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (from.getMoney() &lt; money) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotEnoughMoneyException</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                from.reduce(money);</span><br><span class="line">                to.add(money);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            to.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        from.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们每次都先尝试获取锁，获取不到就退出函数（同时也会释放获得的锁）。那我们转账的时候可以循环调用<code>tryTransfer</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account from, Account to, <span class="type">double</span> money)</span> </span><br><span class="line">  <span class="keyword">throws</span> NotEnoughMoneyException &#123;</span><br><span class="line">    <span class="keyword">while</span> (!tryTransfer(from, to, money)) Thread.<span class="keyword">yield</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h6><p><code>ReentrantLock</code>的实现需要借助类<code>LockSupport</code>，因此我们先看看这个类。<br><strong>1、LockSupport</strong><br><code>LockSupport</code>类有如下基本方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parkNanos</span><span class="params">(<span class="type">long</span> nanos)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parkUntil</span><span class="params">(<span class="type">long</span> deadline)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Thread thread)</span></span><br></pre></td></tr></table></figure>
<p><code>park</code>方法会使当前线程放弃 CPU，进入等待状态（WAITING）。这种状态下，操作系统不会对它进行调度，直到其它线程对它调用了<code>unpark</code>，此时它会恢复到可运行态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> ()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            LockSupport.park();  <span class="comment">// 主动让出 CPU</span></span><br><span class="line">            System.out.println(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);  <span class="comment">// 主线程延迟 1 秒</span></span><br><span class="line">    LockSupport.unpark(t);  <span class="comment">// 唤醒子线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意区分<code>LockSupport.park()</code>与<code>Thread.yield()</code>，前者会让线程陷入等待态，而后者是让线程进入就绪态。<br>需要说明的是<code>park</code>是响应中断的，有中断发生时<code>park</code>方法会返回并设置线程的中断状态。另外值得一提的是<code>park</code>会无缘无故的返回，因此我们需要循环检查<code>park</code>等待的条件是否满足。<br><code>park</code>方法还有两个变体：</p>
<ul>
<li><code>parkNanos</code>可以指定等待的最长时间，单位是纳秒。</li>
<li><code>parkUntil</code>可以指定最长等待到什么时候，参数是相对纪元时的毫秒数。</li>
</ul>
<p><strong>2、AQS</strong><br>其实有了 CAS 与<code>LockSupport</code>已经可以实现<code>ReentrantLock</code>了，但为了代码的重用性，Java 提供了一个抽象类<code>AbstractQueuedSynchronizer</code>简称 AQS。AQS 整体比较复杂，我们以<code>ReentrantLock</code>为脉络进行梳理。<br>AQS 封装了一个状态，给子类提供了查询和设置状态的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span></span><br></pre></td></tr></table></figure>
<p>使用 AQS 实现锁时，它可以保存锁的当前持有线程，提供如下方法进行查询和设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setExclusiveOwnerThread</span><span class="params">(Thread t)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Thread <span class="title function_">getExclusiveOwnerThread</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p><strong>3、ReentrantLock</strong><br><code>ReentrantLock</code>内部有三个内部类使用了 AQS：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span></span><br></pre></td></tr></table></figure>
<p>见名知义，<code>FairSync</code>与<code>NonfairSync</code>分别是公平与不公平<code>ReentrantLock</code>需要的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();  <span class="comment">// 默认是不公平的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们主要看看<code>ReentrantLock</code>的<code>lock</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();  <span class="comment">// 主要就是调用 sync 的 lock 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sync</code>默认是<code>NonfairSync</code>类型，其<code>lock</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NonfairSync 实现的 lock</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))  <span class="comment">// 没人用锁直接锁定且设置锁定的线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// acquire 是 AQS 实现的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NonfairSync 实现的 tryAcquire</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span>(p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>;  <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync 实现的 nonfairTryAcquire</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">0</span>) &#123;  <span class="comment">// 没锁定直接锁定</span></span><br><span class="line">        <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(current == getExclusiveOwnerThread()) &#123;  <span class="comment">// 可重入性</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span>(nextc &lt; <span class="number">0</span>)  <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些方法里主要<code>acquireQueued</code>方法需要理一下，这个方法主体就是一个死循环。循环里如果发现传入的线程是等待队列里的第一个并且当前能获取锁则将传入的线程从等待队列移除并返回，否则调用<code>shouldParkAfterFailedAcquire</code>（最终会调用<code>park</code>）令线程陷入等待。待线程被唤醒之后使用<code>parkAndCheckInterrupt</code>检查线程是否发生了中断。<br>接下来我们看看<code>ReentrantLock</code>的<code>unlock</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS 定义的 release 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span>(h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>tryRelease</code>方法会释放锁，<code>unparkSuccessor</code>方法会调用<code>LockSupport.unpark</code>方法唤醒第一个等待的线程。</p>
<h5 id="显式条件"><a href="#显式条件" class="headerlink" title="显式条件"></a>显式条件</h5><h6 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h6><p>显式锁与<code>synchronized</code>对应，显式条件则与<code>wait/notify</code>相对应。<code>synchronized</code>与<code>wait/notify</code>配合使用，显式锁与显式条件配合使用。条件与锁相关联，创建条件变量需要通过锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p><code>Condition</code>是一个接口，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的<code>awaitXXX</code>都与 Object 的<code>wait</code>相对应，<code>signal/signalAll</code>则与 Object 的<code>notify/notifyAll</code>相对应，它们的语义也是相同的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置最长等待时长，单位是纳秒。返回 nanosTimeout - 实际等待时长</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 设置最长等待时长，单位自定。等待超时了返回 false，否则返回 true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 设置最多等到什么时候</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>
<p>这些等待方法都是响应中断的，发生中断会抛<code>InterruptedException</code>，但中断标记位会清空。<br>此外还有一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>这个方法是不响应中断的，这个方法返回时如果过程中有中断发生会记录在中断标记位里。<br>在调用<code>await</code>方法之前需要先获取锁，如果没有锁会抛<code>IllegalMonitorStateException</code>，因<code>await</code>进入等待队列之后线程会释放锁。从<code>await</code>返回后不一定满足了条件，所以一般是将<code>await</code>的调用放到一个循环里面。<br><code>signal</code>与<code>notify</code>类似，会挑选一个线程唤醒，<code>signalAll</code>会唤醒所有线程。线程被唤醒后要重新竞争锁，获得锁之后才会从<code>await</code>里面返回。<br>我们使用一个例子看条件的具体用法。我们想让子线程开启后等待主线程命令再执行下去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">fire</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!fire) &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;fired&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.interrupted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.fire = <span class="literal">true</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">WaitThread</span> <span class="variable">waitThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitThread</span>();</span><br><span class="line">        waitThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;fire&quot;</span>);</span><br><span class="line">        waitThread.fire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="生产者与消费者-1"><a href="#生产者与消费者-1" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h6><p>生产者与消费者问题我们在上面已经看过，但是上面使用<code>wait</code>进行线程阻塞有一个问题，就是生产者与消费者阻塞在一条等待队列里，唤醒时无法指定唤醒谁只能使用<code>notifyAll</code>唤醒全部。本节我们使用显式条件创建两个队列分别用来阻塞生产者与消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyBlockingQueue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;T&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBlockingQueue</span><span class="params">(<span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">        <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == limit) &#123;</span><br><span class="line">                notFull.await();  <span class="comment">// 所有生产者都阻塞在 notFull 里</span></span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(t);</span><br><span class="line">            notEmpty.signal();  <span class="comment">// 每生产一次都会唤醒一个消费者</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                notEmpty.await();  <span class="comment">// 所有消费者都阻塞在 notEmpty 里</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            notFull.signal();  <span class="comment">// 每消费一次都会唤醒一个生产者</span></span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将生产者与消费者分队列阻塞，可以避免很多无谓的唤醒，提升效率。</p>
<h6 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h6><p>接下来我们看看<code>ReentrantLock</code>是怎么实现的显式条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock 的 newCondition 方法</span></span><br><span class="line"><span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sync 的 newCondition 方法</span></span><br><span class="line"><span class="keyword">final</span> ConditionObject <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ConditionObject</code>是定义在 AQS 里的内部类，它内部维护一个条件等待队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队首节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"><span class="comment">// 队尾节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br></pre></td></tr></table></figure>
<p>因为<code>ConditionObject</code>是 AQS 的内部类，因此它可以访问 AQS 内部的锁队列。我们先看<code>ConditionObject.await</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 如果等待前中断标记位被设置直接抛出中断异常</span></span><br><span class="line">    <span class="keyword">if</span>(Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 1. 为当前线程创建节点并加入条件等待队列</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="comment">// 2. 释放持有的锁</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 3. 调用 park 陷入等待，循环有两个退出条件：</span></span><br><span class="line">    <span class="comment">//  3.1 等待过程中遇到中断会直接 break</span></span><br><span class="line">    <span class="comment">//  3.2 当前线程节点从等待队列移到了外层的锁列队，即等待的条件已满足</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span>((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 重新获取锁</span></span><br><span class="line">    <span class="keyword">if</span>(acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span>(node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">    unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">//5. 处理中断，抛出异常或设置中断标记位</span></span><br><span class="line">    <span class="keyword">if</span>(interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再看<code>signal</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果未持有锁直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span>(!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="comment">// 唤醒第一个等待的线程</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span>(first != <span class="literal">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>doSignal</code>做的事情主要有：</p>
<ul>
<li>将节点从等待队列移到外层的锁等待队列；</li>
<li>调用<code>LockSupport.unpark</code>将线程唤醒。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/08/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8808%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/06/08/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8808%EF%BC%89/" itemprop="url">Java 基础系列（08）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-06-08T12:09:51+08:00">
                2023-06-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="文件高级技术"><a href="#文件高级技术" class="headerlink" title="文件高级技术"></a>文件高级技术</h3><h4 id="常见文件类型"><a href="#常见文件类型" class="headerlink" title="常见文件类型"></a>常见文件类型</h4><p>日常使用中有一些常用的文件类型，例如：属性文件、CSV、Excel、HTML和压缩包。本节主要介绍一些 API 或三方库来操作这些常用文件。</p>
<h5 id="属性文件"><a href="#属性文件" class="headerlink" title="属性文件"></a>属性文件</h5><p>属性文件一般比较简单，一行表示一个属性。属性就是键值对，使用<code>=</code>或<code>:</code>将键与值分开，一般用于配置程序的一些信息。例如和数据库相关的配置文件<code>db_cfg.properties</code>就可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.host = <span class="number">192.168</span><span class="number">.10</span><span class="number">.100</span></span><br><span class="line">db.port : <span class="number">3306</span></span><br><span class="line">db.username = zhangsan</span><br><span class="line">db.password = mima1234</span><br></pre></td></tr></table></figure>
<p>我们可以使用字符流解析字符串，但是比较麻烦。Java 有专门的类<code>java.util.Properties</code>做这个事，它有如下主要方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(InputStream inStream)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getProperty</span><span class="params">(String key)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getProperty</span><span class="params">(String key, String defaultValue)</span></span><br></pre></td></tr></table></figure>
<p><code>load</code>方法用于加载属性文件，<code>getProperty</code>方法可以根据键获取对应的值，还可以传递<code>defaultValue</code>作为找不到键时的默认值。<br>例如读取上面定义的数据库配置文件可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">prop.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;config.properties&quot;</span>));  <span class="comment">// 加载配置文件</span></span><br><span class="line"><span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> prop.getProperty(<span class="string">&quot;db.host&quot;</span>);  <span class="comment">// 读到的都是字符串</span></span><br><span class="line"><span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> Integer.valueOf(prop.getProperty(<span class="string">&quot;db.port&quot;</span>, <span class="string">&quot;3306&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>使用<code>Properties</code>类处理配置文件有以下好处：</p>
<ol>
<li>它可以自动处理分隔符前后的空格</li>
<li>它可以自动忽略空行</li>
<li>它可以添加注释，以字符<code>#</code>或<code>!</code>开头的行会被忽略</li>
</ol>
<p>当然<code>Properties</code>也有限制，它不能直接处理中文，如果配置文件里面需要使用非 ASCII 字符，我们需要使用 Unicode 编码。我们可以使用 JDK 提供的命令来转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">native2ascii -encoding UTF-<span class="number">8</span> <span class="keyword">native</span>.properties ascii.properties</span><br></pre></td></tr></table></figure>
<p><code>native.properties</code>是输入文件，里面包含中文；<code>ascii.properties</code>表示输出文件，里面的中文会变成 ASCII 字符；<code>encoding</code>表示输入文件的编码，这边是<code>UTF-8</code>。<br>在 IDEA 里面可以按照下面的图进行设置，编译器会自己做转换，很舒适：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1705738834311-eeaa2fcc-d758-40c3-8e95-efcdd8e262cf.png#averageHue=%233f4347&clientId=u69870eb3-2627-4&from=paste&height=708&id=u012bf14e&originHeight=708&originWidth=982&originalType=binary&ratio=1&rotation=0&showTitle=false&size=98956&status=done&style=none&taskId=u89d1617e-0aba-448c-8882-9a99c528b40&title=&width=982" alt="image.png"></p>
<h5 id="压缩包"><a href="#压缩包" class="headerlink" title="压缩包"></a>压缩包</h5><p>压缩文件有很多格式，Java 支持 gzip 和 zip 两种格式。gzip 格式只支持压缩单个文件，目录不允许压缩；而 zip 不限制文件数目和类型，即目录也可以压缩。</p>
<h6 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h6><p>gzip 主要有两个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.zip.GZIPOutputStream</span><br><span class="line">java.util.zip.GZIPInputStream</span><br></pre></td></tr></table></figure>
<p>它们分别是<code>OutputStream</code>和<code>InputStream</code>的子类，都是装饰类。将<code>GZIPOutputStream</code>和<code>GZIPInputStream</code>对已有的流进行装饰就可以实现压缩和解压缩。<br>例如下面的用法，使用 gzip 创建的压缩文件后缀名是<code>.gz</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">gzip</span><span class="params">(String filePath, String zipFilePath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">    <span class="keyword">if</span> (!f.exists()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f));</span><br><span class="line">    <span class="comment">// 用 GZIPOutputStream 装饰已有的流输出的就是压缩文件</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GZIPOutputStream</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(zipFilePath)));</span><br><span class="line">    <span class="keyword">try</span> (in; out) &#123;</span><br><span class="line">        in.transferTo(out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">gunzip</span><span class="params">(String zipFilePath, String unzipFilePath)</span> </span><br><span class="line">		<span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">zipFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(zipFilePath);</span><br><span class="line">    <span class="keyword">if</span> (!zipFile.exists()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>(zipFilePath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用 GZIPInputStream 装饰已有的流可以读取压缩文件</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GZIPInputStream</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(zipFile)));</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(unzipFilePath));</span><br><span class="line">    <span class="keyword">try</span> (in; out) &#123;</span><br><span class="line">        in.transferTo(out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意，使用 gzip 不支持压缩目录。</strong></p>
<h6 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h6><p>zip 格式支持压缩多个文件，包括目录。Java 提供的主要的类是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.zip.ZipOutputStream</span><br><span class="line">java.util.zip.ZipInputStream</span><br></pre></td></tr></table></figure>
<p>它们也分别是<code>OutputStream</code>和<code>InputStream</code>的子类，也都是装饰类。不过区别于上面的 gzip，使用起来会稍微复杂点。<br><code>ZipOutputStream</code>可以写多个文件，它有一个重要方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putNextEntry</span><span class="params">(ZipEntry e)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<p>在写每一个文件之前需要调用这个方法，表示将要写一个压缩条目<code>ZipEntry</code>。这个压缩条目需要文件的相对最上层的路径，如果是目录需要以路径分隔符结尾，构造如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ZipEntry</span><span class="params">(String name)</span></span><br></pre></td></tr></table></figure>
<p>压缩一个文件或目录的方法可以包装如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">zip</span><span class="params">(File inFile, File zipFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ZipOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipOutputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(zipFile)))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!inFile.exists()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>(inFile.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">        inFile = inFile.getCanonicalFile();</span><br><span class="line">        <span class="type">String</span> <span class="variable">rootPath</span> <span class="operator">=</span> inFile.getParent();</span><br><span class="line">        <span class="keyword">if</span> (!rootPath.endsWith(File.separator)) &#123;</span><br><span class="line">            rootPath += File.separator;</span><br><span class="line">        &#125;</span><br><span class="line">        addFileToZipOut(inFile, out, rootPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addFileToZipOut</span><span class="params">(File file, ZipOutputStream out, </span></span><br><span class="line"><span class="params">                                    String rootPath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">relativePath</span> <span class="operator">=</span> file.getCanonicalPath().substring(</span><br><span class="line">            rootPath.length());</span><br><span class="line">    <span class="keyword">if</span>(file.isFile()) &#123;</span><br><span class="line">        out.putNextEntry(<span class="keyword">new</span> <span class="title class_">ZipEntry</span>(relativePath));</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">            	<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file))) &#123;</span><br><span class="line">            in.transferTo(out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        out.putNextEntry(<span class="keyword">new</span> <span class="title class_">ZipEntry</span>(relativePath + File.separator));</span><br><span class="line">        <span class="keyword">for</span>(File f : file.listFiles()) &#123;</span><br><span class="line">            addFileToZipOut(f, out, rootPath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ZipInputStream</code>用于解压<code>zip</code>文件，它有一个方法用于获取下一个条目：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ZipEntry <span class="title function_">getNextEntry</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<p>解压缩的代码就可以写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unzip</span><span class="params">(File zipFile, String destDir)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ZipInputStream</span> <span class="variable">zin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(zipFile)))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!destDir.endsWith(File.separator)) &#123;</span><br><span class="line">            destDir += File.separator;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ZipEntry</span> <span class="variable">entry</span> <span class="operator">=</span> zin.getNextEntry();</span><br><span class="line">        <span class="keyword">while</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">            extractZipEntry(entry, zin, destDir);</span><br><span class="line">            entry = zin.getNextEntry();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">extractZipEntry</span><span class="params">(ZipEntry entry, ZipInputStream zin,</span></span><br><span class="line"><span class="params">                                    String destDir)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span>(!entry.isDirectory()) &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destDir + entry.getName()).getParentFile();</span><br><span class="line">        <span class="keyword">if</span>(!parent.exists()) &#123;</span><br><span class="line">            parent.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">entryOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destDir + entry.getName()))) &#123;</span><br><span class="line">            zin.transferTo(entryOut);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">File</span>(destDir + entry.getName()).mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="其它文件"><a href="#其它文件" class="headerlink" title="其它文件"></a>其它文件</h5><p>其它包括 CSV、Excel 等文件的处理可以参考下面的笔记。<br><a target="_blank" rel="noopener" href="https://space-jiangsu.yuque.com/bcsfg9/ia5lzr/isn6ix9dwqfpsw31?view=doc_embed">4. 常用三方库</a></p>
<h4 id="随机读写文件"><a href="#随机读写文件" class="headerlink" title="随机读写文件"></a>随机读写文件</h4><p>Java 使用<code>RandomAccessFile</code>类实现随机读写文件，本节先探讨类的使用，再使用它实现一个简单的键值对数据库。</p>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><p><code>RandomAccessFile</code>的构造有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RandomAccessFile</span><span class="params">(String name, String mode)</span> <span class="keyword">throws</span> FileNotFoundException</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RandomAccessFile</span><span class="params">(File file, String mode)</span> <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure>
<p>参数<code>name</code>和<code>file</code>都表示文件，参数<code>mode</code>表示文件的打开方式，主要有以下取值：</p>
<ul>
<li><code>r</code>只用于读</li>
<li><code>rw</code>用于读和写</li>
<li><code>rwd</code>用于读和写，且文件内容的更新同步到设备上</li>
<li><code>rws</code>用于读和写，且文件内容或元数据的更新同步到设备上</li>
</ul>
<p><code>RandomAccessFile</code>虽然不是<code>InputStream/OutputStream</code>的子类，但它也有类似的读写字节流的方法。此外，它还实现了<code>DataInput/DataOutput</code>接口，我们列举部分方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">readInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeInt</span><span class="params">(<span class="type">int</span> v)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="comment">// 其它诸如 readLong、writeBoolean 等等都是存在的</span></span><br></pre></td></tr></table></figure>
<p><code>RandomAccessFile</code>还有另外两个读方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">readFully</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">readFully</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<p>这两个方法与对应的<code>read</code>方法是一样的，不过它们可以保证能够读取的期望长度，若文件到结尾了还没读够会抛<code>EOFException</code>异常。<br><code>RandomAccessFile</code>内部有一个文件指针，我们可以调用方法获取或设置文件指针当前位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文件指针当前位置，位置就是当前距离文件开头的偏移字节数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">getFilePointer</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="comment">// 设置文件指针的位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">seek</span><span class="params">(<span class="type">long</span> pos)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="comment">// 跳过 n 个字节，内部使用移动文件指针实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">skipBytes</span><span class="params">(<span class="type">int</span> n)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<p>关于方法<code>skipBytes</code>有以下注意点：</p>
<ul>
<li>只能向后跳，不能向前跳。传入一个负数将什么都不做，直接返回 0</li>
<li>如果跳跃目的地大于文件长度，会直接跳到末尾并返回实际跳过的字节数</li>
</ul>
<p><code>RandomAccessFile</code>还可以操作文件长度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文件长度，单位是字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">length</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="comment">// 设置文件长度，单位也是字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setLength</span><span class="params">(<span class="type">long</span> newLength)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<p>对于方法<code>setLength</code>有以下注意点：</p>
<ul>
<li>若当前文件长度小于<code>newLength</code>，则文件会扩展，扩展部分内容未定义。</li>
<li>若当前文件长度大于<code>newLength</code>，则文件多出的部分会被截取；这种情况下，若文件指针比<code>newLength</code>大，则将文件指针更新为<code>newLength</code>。</li>
</ul>
<p>最后有两个方法需要着重注意：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeBytes</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">readLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<p>这两个方法看上去是写入一个字符串或读取一行字符串，但实际有坑。因为这两个方法没有编码的概念，即它们都认为一个字节代表一个字符，对于汉字来说显然是错误的。因此我们应该<strong>避免</strong>使用这两个方法。</p>
<h5 id="实现键值对数据库"><a href="#实现键值对数据库" class="headerlink" title="实现键值对数据库"></a>实现键值对数据库</h5><p>本节我们将会实现一个简单的键值对数据库<code>BasicDB</code>，它可以保存、查找、删除键值对。和<code>Map</code>不同，我们是将键值对存在文件里而不是内存，因此可以大大节省内存。此外，处于效率考虑，我们将采用<code>RandomAccessFile</code>来随机读取。</p>
<h6 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h6><p>我们将创建两个文件：<code>.data</code>文件和<code>.meta</code>文件。</p>
<ul>
<li><code>.data</code>文件用来存储所有的值<ul>
<li>每个值占据的字节数固定为 1024 字节</li>
<li>前 4 个字节存储值的实际长度，后 1020 个字节存储值本身</li>
</ul>
</li>
<li><code>.meta</code>文件主要有两个作用：<ol>
<li>用来维护键与值的映射关系</li>
<li>存储所有空白空间的文件指针，所谓空白空间是指本来有值但目前已经被删除掉的空间</li>
</ol>
</li>
</ul>
<p>我们在存储值的时候优先使用空白空间，不存在空白空间才会写到文件结尾。</p>
<h6 id="关于键值对"><a href="#关于键值对" class="headerlink" title="关于键值对"></a>关于键值对</h6><p>出于简单考虑，键只能是字符串类型，值只能是字节数组。不论是基本数据类型转还是自定义类都可以使用下面的方法转成字节数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将学生类转换成字节数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] toBytes(Student s) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(bos);</span><br><span class="line">    ds.writeUTF(s.name);</span><br><span class="line">    ds.writeInt(s.age);</span><br><span class="line">    ds.writeDouble(s.score);</span><br><span class="line">    <span class="keyword">return</span> bos.toByteArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字节数组恢复学生对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title function_">fromBytes</span><span class="params">(<span class="type">byte</span>[] b)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b);</span><br><span class="line">    <span class="type">DataInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(bis);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> in.readUTF();</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">    <span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> in.readDouble();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>(name, age, score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们初步可以这样实现，后面介绍了序列化会简单很多。</p>
<h6 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h6><p><code>BasicDB</code>的构造设计如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BasicDB</span><span class="params">(String path, String name)</span></span><br></pre></td></tr></table></figure>
<p>参数<code>path</code>表示文件的存储目录，<code>name</code>表示数据库文件名。<br><code>BasicDB</code>提供的公开方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, <span class="type">byte</span>[] value)</span>  <span class="comment">// 添加键值对</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] get(String key)  <span class="comment">// 根据键获取值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String key)</span>  <span class="comment">// 删除键值对</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>  <span class="comment">// 将数据保存到文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>  <span class="comment">// 关闭数据库</span></span><br></pre></td></tr></table></figure>
<h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BasicDB</span> &#123;</span><br><span class="line">    <span class="comment">// value 占据的最大字节数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_DATA_SIZE</span> <span class="operator">=</span> <span class="number">1020</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DATA_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;.data&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">META_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;.meta&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Long&gt; gaps;  <span class="comment">// 保存所有空白空间的文件指针</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Long&gt; indexMap;  <span class="comment">// 保存键与值地址的映射</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> File metaFile;</span><br><span class="line">    <span class="keyword">private</span> RandomAccessFile dataFile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BasicDB</span><span class="params">(String path, String name)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        metaFile = <span class="keyword">new</span> <span class="title class_">File</span>(path + name + META_SUFFIX);</span><br><span class="line">        dataFile = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(path + name + DATA_SUFFIX, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        gaps = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        indexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (metaFile.exists()) &#123;  <span class="comment">// 加载文件保存的映射关系</span></span><br><span class="line">            loadMeta();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadMeta</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">DataInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(metaFile)))) &#123;</span><br><span class="line">            loadIndex(in);</span><br><span class="line">            loadGaps(in);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadGaps</span><span class="params">(DataInputStream in)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            gaps.offer(in.readLong());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadIndex</span><span class="params">(DataInputStream in)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> in.readUTF();</span><br><span class="line">            <span class="type">Long</span> <span class="variable">value</span> <span class="operator">=</span> in.readLong();</span><br><span class="line">            indexMap.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveMeta</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">DataOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(metaFile)))) &#123;</span><br><span class="line">            saveIndex(out);</span><br><span class="line">            saveGaps(out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveGaps</span><span class="params">(DataOutputStream out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        out.writeInt(gaps.size());</span><br><span class="line">        <span class="keyword">for</span> (Long l : gaps) &#123;</span><br><span class="line">            out.writeLong(l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveIndex</span><span class="params">(DataOutputStream out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        out.writeInt(indexMap.size());</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Long&gt; entry : indexMap.entrySet()) &#123;</span><br><span class="line">            out.writeUTF(entry.getKey());</span><br><span class="line">            out.writeLong(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取指定位置的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] readDB(<span class="type">long</span> idx) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        dataFile.seek(idx);</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dataFile.readInt();</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">        dataFile.readFully(buffer);</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往指定位置写值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeDB</span><span class="params">(<span class="type">long</span> idx, <span class="type">byte</span>[] value)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        dataFile.seek(idx);</span><br><span class="line">        dataFile.writeInt(value.length);</span><br><span class="line">        dataFile.write(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取空白位置地址，gaps 里有就使用，没有就写在文件最后</span></span><br><span class="line">    <span class="keyword">private</span> Long <span class="title function_">getAvailableIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!gaps.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> gaps.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dataFile.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, <span class="type">byte</span>[] value)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.length &gt; MAX_DATA_SIZE) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                <span class="string">&quot;The length of data is greater than &quot;</span> + MAX_DATA_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">idx</span> <span class="operator">=</span> indexMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="literal">null</span>) &#123;</span><br><span class="line">            idx = getAvailableIndex();</span><br><span class="line">            indexMap.put(key, idx);</span><br><span class="line">        &#125;</span><br><span class="line">        writeDB(idx, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] get(String key) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">idx</span> <span class="operator">=</span> indexMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> readDB(idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] remove(String key) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">idx</span> <span class="operator">=</span> indexMap.remove(key);</span><br><span class="line">        <span class="keyword">if</span> (idx == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        gaps.offer(idx);</span><br><span class="line">        <span class="keyword">return</span> readDB(idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        saveMeta();</span><br><span class="line">        dataFile.getFD().sync();  <span class="comment">// 确保文件被写到磁盘</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        flush();</span><br><span class="line">        dataFile.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鉴于我们值的类型被固定为字节数组，使用的时候可能有些不方便。我们可以实现一个<code>BasicDB</code>的包装类，包装类可以提供一些类似<code>readInt/WriteInt</code>方法，我们在这些方法里面进行对象与字节数组的转换。</p>
<h4 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>内存映射文件是操作系统提供的一种功能，大部分操作系统都支持。简单说就是将文件映射到内存里的一个字节数组中，将对文件的操作转变为对字节数组的操作。而对字节数组的操作也能映射到文件中，这种映射可以映射文件的全部，也可以是部分。<br>正常操作系统实现的时候都会采用懒加载，文件不会立刻加载到内存，而是等实际发生读写的时候再按需加载。加载的时候以页为单位，一般一页是<code>4k/8k</code>字节。正是懒加载机制，<strong>内存映射文件能高效处理大文件</strong>。<br>内存映射文件的一个重要特点是：<strong>它可以被多个不同的应用程序共享</strong>，多个程序可以映射同一个文件到同一块内存中，一个程序对内存的修改，其它应用程序也能看到。这就使得内存映射文件<strong>很适合用于多个应用程序之间的通信</strong>。<br>内存映射文件也有局限性：</p>
<ul>
<li>它不适合处理小文件，因为它内部是按页分配内存，文件太小会浪费内存。</li>
<li>内存映射会消耗一定的操作系统资源，初始化比较慢。</li>
</ul>
<p>总结下来，对于一般的文件操作不需要使用内存映射文件，当我们处理的文件很大或需要多个程序共享的时候可以使用。</p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><h6 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h6><p><code>FileInputStream/FileOutputStream/RandomAccessFile</code>类里有以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> FileChannel <span class="title function_">getChannel</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>这个方法会返回<code>FileChannel</code>对象，<code>FileChannel</code>有如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MappedByteBuffer <span class="title function_">map</span><span class="params">(MapMode mode, <span class="type">long</span> position, <span class="type">long</span> size)</span> </span><br><span class="line">	<span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<p>这个<code>map</code>方法能将当前文件映射到内存，返回的<code>MappedByteBuffer</code>对象就是内存里的字节数组。我们先看看<code>map</code>方法的三个参数：</p>
<ul>
<li><code>mode</code>表示映射模式，主要有三种取值<ul>
<li><code>MapMode.READ_ONLY</code>表示只读映射</li>
<li><code>MapMode.READ_WRITE</code>表示读写映射</li>
<li><code>MapMode.PRIVATE</code>私有模式，更改不反应到文件，对其它程序也不可见</li>
</ul>
</li>
<li><code>position</code>表示映射的起始位置</li>
<li><code>size</code>表示映射的长度</li>
</ul>
<p>注意，映射模式受限于流的打开方式。例如使用模式<code>&quot;r&quot;</code>打开一个<code>RandomAccessFile</code>，映射的时候就不能使用读写映射，强行使用会抛异常。<br>此外，如果映射的区域超出了现有文件的范围，文件将会被自动扩展，扩展部分总结内容为 0。映射完成后，文件可以关闭，这不影响使用<code>MappedByteBuffer</code>操作文件。</p>
<h6 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h6><p>至于<code>MappedByteBuffer</code>怎么使用，我们先来介绍<code>MappedByteBuffer</code>的父类<code>ByteBuffer</code>。<br><code>ByteBuffer</code>可以简单理解为封装了一个字节数组，这个字节数组长度<strong>不可变</strong>，在内存映射文件里，这个长度由参数<code>size</code>指定。此外<code>ByteBuffer</code>还有一个属性<code>position</code>表示当前的读写位置，我们可以使用下面的方法操作<code>position</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">position</span><span class="params">()</span>  <span class="comment">//឴ 获取当前的操作位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">position</span><span class="params">(<span class="type">int</span> newPosition)</span>  <span class="comment">// 设置新位置</span></span><br></pre></td></tr></table></figure>
<p><code>ByteBuffer</code>里面有许多基于当前位置的读写方法，部分如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">byte</span> <span class="title function_">get</span><span class="params">()</span>  <span class="comment">// 获取一个字节的内容</span></span><br><span class="line"><span class="keyword">public</span> ByteBuffer <span class="title function_">get</span><span class="params">(<span class="type">byte</span>[] dst)</span>  <span class="comment">// 获取内容填满 dst</span></span><br><span class="line"><span class="keyword">public</span> ByteBuffer <span class="title function_">get</span><span class="params">(<span class="type">byte</span>[] dst, <span class="type">int</span> offset, <span class="type">int</span> length)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">put</span><span class="params">(<span class="type">byte</span> b)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title function_">put</span><span class="params">(<span class="type">byte</span>[] src)</span></span><br><span class="line"><span class="keyword">public</span> ByteBuffer <span class="title function_">put</span><span class="params">(<span class="type">byte</span>[] src, <span class="type">int</span> offset, <span class="type">int</span> length)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">getInt</span><span class="params">()</span>  <span class="comment">// 从当前位置读取一个 int</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">putLong</span><span class="params">(<span class="type">long</span> value)</span>;  <span class="comment">// 往当前位置写入一个 long</span></span><br></pre></td></tr></table></figure>
<p>注意，因为读写的都是字节，所以没有<code>getString/putString</code>方法。<br>除此之外，还有操作指定位置的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">byte</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">put</span><span class="params">(<span class="type">int</span> index, <span class="type">byte</span> b)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">getDouble</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">putDouble</span><span class="params">(<span class="type">int</span> index, <span class="type">double</span> value)</span></span><br></pre></td></tr></table></figure>
<p>这些方法相比上面的方法都是多了一个参数<code>index</code>表示操作的内容位置。</p>
<h6 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h6><p>除了上面的那些方法，<code>MappedByteBuffer</code>还有一些特有的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isLoaded</span><span class="params">()</span>  <span class="comment">// 返回文件内容是否真的加载到了内存，结果不一定准确</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> MappedByteBuffer <span class="title function_">load</span><span class="params">()</span>  <span class="comment">// 尽力将文件内容加载到内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> MappedByteBuffer <span class="title function_">force</span><span class="params">()</span>  <span class="comment">// 将内存的修改强制同步到磁盘</span></span><br></pre></td></tr></table></figure>
<h5 id="实现消息队列"><a href="#实现消息队列" class="headerlink" title="实现消息队列"></a>实现消息队列</h5><p>本节我们将会实现一个简单的消息队列<code>BasicQueue</code>，这是一个先进先出、长度固定的循环队列。它的特色是：</p>
<ol>
<li>能将消息持久化，不仅仅存在于内存</li>
<li>支持多个应用程序的共享消息队列</li>
</ol>
<p>我们使用循环队列的思想，尾指针指向新元素的下标。为了区分满队和空队，我们规定：</p>
<ul>
<li>尾指针后面是头指针的时候为满队</li>
<li>尾指针和头指针重合的时候是空队</li>
</ul>
<p>这将会浪费一个空间。</p>
<h6 id="设计-1"><a href="#设计-1" class="headerlink" title="设计"></a>设计</h6><p>我们将创建两个文件：<code>.data</code>文件和<code>.meta</code>文件。</p>
<ul>
<li><code>.data</code>文件用来存储所有的消息<ul>
<li>每个消息占据的字节数固定为 1024 字节</li>
<li>前 4 个字节存储消息的实际长度，后 1020 个字节存储消息本身</li>
</ul>
</li>
<li><code>.meta</code>文件存储队头和队尾元素的下标</li>
</ul>
<h6 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h6><p><code>BasicQueue</code>的构造方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BasicQueue</span><span class="params">(String path, String name)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<p>参数<code>path</code>表示文件的存储目录，<code>name</code>表示文件名。<br><code>BasicQueue</code>提供的公开接口方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> IOException  <span class="comment">// 入队</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] dequeue() <span class="keyword">throws</span> IOException  <span class="comment">// 出队</span></span><br></pre></td></tr></table></figure>
<h6 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicQueue</span> &#123;</span><br><span class="line">    <span class="comment">// 实际上消息最多 99 个，因为循环队列会浪费一个空间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_MSG_NUM</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_MSG_SIZE</span> <span class="operator">=</span> <span class="number">1020</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BLOCK_SIZE</span> <span class="operator">=</span> MAX_MSG_SIZE + <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">META_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;.meta&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DATA_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;.data&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_META_SIZE</span> <span class="operator">=</span> <span class="number">8</span>;  <span class="comment">// 存两个 int 表示头尾指针</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_DATA_SIZE</span> <span class="operator">=</span> BLOCK_SIZE * MAX_MSG_NUM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MappedByteBuffer metaBuffer;</span><br><span class="line">    <span class="keyword">private</span> MappedByteBuffer dataBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BasicQueue</span><span class="params">(String path, String name)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">meta</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(</span><br><span class="line">            path + name + META_SUFFIX, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(</span><br><span class="line">            path + name + DATA_SUFFIX, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (meta; data) &#123;</span><br><span class="line">            metaBuffer = meta.getChannel().map(</span><br><span class="line">                FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, MAX_META_SIZE);</span><br><span class="line">            dataBuffer = data.getChannel().map(</span><br><span class="line">                FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, MAX_DATA_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">head</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> metaBuffer.getInt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">head</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">        metaBuffer.putInt(<span class="number">0</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">tail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> metaBuffer.getInt(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">tail</span><span class="params">(<span class="type">int</span> t)</span> &#123;</span><br><span class="line">        metaBuffer.putInt(<span class="number">4</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head() == tail();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (tail() + <span class="number">1</span>) % MAX_MSG_NUM == head();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.length &gt; MAX_MSG_SIZE) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                <span class="string">&quot;The length of data is greater than &quot;</span> + MAX_MSG_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue is full!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> tail() * BLOCK_SIZE;</span><br><span class="line">        dataBuffer.position(idx);</span><br><span class="line">        dataBuffer.putInt(data.length);</span><br><span class="line">        dataBuffer.put(data);</span><br><span class="line">        tail((tail() + <span class="number">1</span>) % MAX_MSG_NUM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] dequeue() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> head() * BLOCK_SIZE;</span><br><span class="line">        dataBuffer.position(idx);</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dataBuffer.getInt();</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">        dataBuffer.get(data);</span><br><span class="line">        head((head() + <span class="number">1</span>) % MAX_MSG_NUM);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码不是很难，我们在测试的时候可以测一下多个程序共享内存的情况，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    		<span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;demo&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/Users/luyan/Documents/idea/JavaDemo/out/queue/&quot;</span>;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">BasicQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicQueue</span>(path, name);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; ; ++i) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Task&quot;</span> + i;</span><br><span class="line">            queue.enqueue(msg.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;produce &quot;</span> + msg);</span><br><span class="line">            Thread.sleep(rnd.nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    		<span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;demo&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/Users/luyan/Documents/idea/JavaDemo/out/queue/&quot;</span>;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">BasicQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicQueue</span>(path, name);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">byte</span>[] data = queue.dequeue();</span><br><span class="line">            <span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</span><br><span class="line">                Thread.sleep(rnd.nextInt(<span class="number">1000</span>));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;consume &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="标准序列化"><a href="#标准序列化" class="headerlink" title="标准序列化"></a>标准序列化</h4><p>之前我们想将对象保存在文件里，会使用<code>DataOutputStream</code>按个字段存储。这比较麻烦，Java 里面还有更简单的机制，就是序列化。所谓序列化就是将对象转换成字节流，反序列化就是从字节流恢复对象。</p>
<h5 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h5><p>要让一个类支持序列化，这个类必须实现<code>java.io.Serializable</code>接口。这个接口里面没有定义方法，只是为了描述一种能力。类实现了<code>Serializable</code>接口之后就可以使用<code>ObjectOutputStream/ObjectInputStream</code>进行序列化和反序列化了。<br><code>**ObjectOutputStream**</code>是<code>OutputStream</code>的子类，同时实现了<code>ObjectOutput</code>接口。因为<code>ObjectOutput</code>接口是<code>DataOutput</code>的子接口，所以诸如<code>writeInt/writeDouble/writeUTF</code>之类的方法都是支持的。此外，<code>ObjectOutput</code>接口新增了一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<p>这个方法能将对象转换成字节写到流中。<br><code>**ObjectInputStream**</code>是<code>InputStream</code>的子类，同时实现了<code>ObjectInput</code>接口。因为<code>ObjectInput</code>是<code>DataInput</code>的子接口，所以诸如<code>readInt/readDouble/readUTF</code>之类方法也是支持的。此外，<code>ObjectInput</code>接口还新增了一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">readObject</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IOException</span><br></pre></td></tr></table></figure>
<p>这个方法能从流中读取字节转换成对象。</p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>有了<code>ObjectOutputStream/ObjectInputStream</code>，我们想要在学生对象与字节数组之间进行相互转换就没有必要挨个字段进行了，我们就可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] writeStudent(Student s) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">    out.writeObject(s);</span><br><span class="line">    <span class="keyword">return</span> bos.toByteArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title function_">readStudent</span><span class="params">(<span class="type">byte</span>[] data)</span> </span><br><span class="line">		<span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(data);</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">    <span class="keyword">return</span> (Student) in.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不仅如此，如果<code>List</code>对象实现了<code>Serializable</code>接口，里面<code>item</code>也实现了<code>Serializable</code>接口。那么整个列表就可以直接序列化或反序列化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; list = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">99</span>)</span><br><span class="line">);</span><br><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/Users/luyan/Documents/idea/JavaDemo/out/stu.dat&quot;</span>;</span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path));</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">out.writeObject(list);  <span class="comment">// 可以直接把整个列表写进去</span></span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path));</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">List&lt;Student&gt; s = (List&lt;Student&gt;) in.readObject();  <span class="comment">// 读也可以直接读整个列表</span></span><br><span class="line">System.out.println(s);</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>
<p>我们之前介绍的所有类，如<code>String/Date/Double/ArrayList/LinkedList/HashMap/TreeMap</code>都实现了<code>Serializable</code>接口。</p>
<h5 id="复杂对象"><a href="#复杂对象" class="headerlink" title="复杂对象"></a>复杂对象</h5><p>对于复杂对象，Java 的序列化做的也很牛。所谓复杂：</p>
<ol>
<li>假设对象<code>a</code>和<code>b</code>同时引用了对象<code>c</code>，那么：<ul>
<li>对象<code>c</code>只会被序列化 1 次，不会被重复序列化</li>
<li>反序列化的时候，<code>a</code>与<code>b</code>里的<code>c</code>也会是同一个对象</li>
</ul>
</li>
<li>如果对象<code>a</code>与对象<code>b</code>存在循环引用的情况，Java 也会处理的很好。反序列化之后的两个对象也会循环引用，就很强！</li>
</ol>
<h5 id="定制序列化"><a href="#定制序列化" class="headerlink" title="定制序列化"></a>定制序列化</h5><p>默认的序列化机制已经很强大了，但正是因为太强了，所以可能引发一些问题。<br>例如有些类里定义了属性用来存储对象的哈希值，而我们知道哈希值是和对象的存储位置相关联的，反序列化生成的对象内存地址发生了变化，再使用原来的哈希值就不合适了。<br>一般序列化我们会存储对象的逻辑信息而不是实现细节，比如<code>LinkedList</code>类表示双向链表，逻辑信息就是链表里的所有节点。但类里的变量诸如头指针、尾指针等都是实现细节，这些变量我们不应保存。为此，Java 为我们提供了定制序列化机制，主要有：<code>transient</code>关键字和<code>writeObject/readObject</code>方法。<br>将字段声明为<code>transient</code>，默认序列化机制就会忽略这个字段，不会对其进行保存和恢复。之前提到的<code>LinkedList</code>类里下面的变量就是<code>transient</code>的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>
<p>而我们知道，这些变量还是很重要的。如果不保存的话会出问题，此时我们可以自定义<code>writeObject/readObject</code>方法来自己手动保存。<br><code>**writeObject**</code>方法表示对象的序列化过程，其声明必须是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<p>在这个方法里我们可以调用<code>ObjectOutputStream</code>的方法向流中写数据，例如<code>LinkedList</code>的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">    	<span class="keyword">throws</span> java.io.IOException &#123;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    <span class="keyword">for</span>(Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next)</span><br><span class="line">    	s.writeObject(x.item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码里第一行是<code>s.defaultWriteObject()</code>，这是必需的。这是在调用默认的序列化机制，用来保存所有未被<code>transient</code>修饰的字段和元数据描述信息，因此即使类里所有字段都被<code>transient</code>修饰了也应该调用它。<br><code>**readObject**</code>方法表示反序列化过程，其声明必须是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream s)</span></span><br><span class="line">	<span class="keyword">throws</span> IOException, ClassNotFoundException</span><br></pre></td></tr></table></figure>
<p>在这个方法中，我们可以调用<code>ObjectInputStream</code>里的方法从流中读数据，然后初始化类的成员变量。例如<code>LinkedList</code>的反序列化方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">		<span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> s.readInt();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    	linkLast((E)s.readObject());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不用多说<code>s.defaultReadObject()</code>也是必须的。</p>
<h5 id="序列化基本原理"><a href="#序列化基本原理" class="headerlink" title="序列化基本原理"></a>序列化基本原理</h5><h6 id="序列化基本逻辑"><a href="#序列化基本逻辑" class="headerlink" title="序列化基本逻辑"></a>序列化基本逻辑</h6><ol>
<li>若对象没有实现<code>Serializable</code>接口，抛<code>NotSerializableException</code>异常</li>
<li>每个对象都有一个编号，如果之前写过该对象，则本次只会写它的引用。这就可以解决对象引用和循环引用的问题。</li>
<li>如果对象定义了<code>writeObject</code>方法，则调用它自己的序列化方法</li>
<li>默认利用反射机制遍历对象的结构图，对每个没有标记为<code>transient</code>的字段保存其完整类名、字段名、字段值等信息</li>
</ol>
<h6 id="反序列化基本逻辑"><a href="#反序列化基本逻辑" class="headerlink" title="反序列化基本逻辑"></a>反序列化基本逻辑</h6><ol>
<li>生成对象的时候不会调用任何一个构造</li>
<li>利用反射机制生成对象，然后从流中获取各字段的值</li>
<li>解析每个字段的时候要是找不到类，会抛<code>ClassNotFoundException</code>异常</li>
</ol>
<h5 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h5><p>假设我们已经将某对象序列化了，现在我们修改了类定义，还能成功反序列化吗？<br>默认情况下，Java 会给类生成一个版本号，这个版本号是根据类中的一系列信息自动生成的。在反序列化时如果类的定义发生变化，这个版本号也会随之变化，那么就会与存储的版本号不同，此时会抛出<code>java.io.InvalidClassException</code>异常。<br>一般情况下，我们会希望自定义这个版本号，而不是让 Java 自动生成。这样一些细小的、不影响序列化的改动就不会报错了。我们可以在类中定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br></pre></td></tr></table></figure>
<p>这个<code>serialVersionUID</code>就是自定义的版本号，值可以任意。<br>可以自定义版本号就必然会出现一个问题：如果类经过改动，但没改这个版本号，而字段又有不同，此时反序列化会怎么处理？Java 会尽可能保持兼容性，可以分成三种情况：</p>
<ol>
<li>字段被删除，即流里有但类里没有该字段，则该字段将会被忽略</li>
<li>新增字段，即流里没有但类里有该字段，则该字段被设为默认值</li>
<li>同名字段类型改变，这种情况会抛<code>InvalidClassException</code>异常</li>
</ol>
<h5 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h5><p>尽管 Java 序列化很强，但局限性也很明显，主要有：</p>
<ol>
<li>Java 的序列化格式是特有的，无法跨语言交互</li>
<li>因为序列化会保存很多元数据，所以序列化文件较大</li>
<li>Java 使用反射遍历对象结构，效率较低</li>
<li>Java 序列化格式是二进制的，不便于修改和查看</li>
</ol>
<h4 id="Jackson-序列化"><a href="#Jackson-序列化" class="headerlink" title="Jackson 序列化"></a>Jackson 序列化</h4><p>由于 Java 序列化机制的诸多限制，实践中总是有一些替代，例如 JSON、XML、MessagePack 等。其中 JSON 和 XML 都是文本格式，MessagePack 是二进制格式的 JSON，编码更为精简高效。Jackson 对上面三种格式有很好的支持。</p>
<h5 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h5><p>使用前先导包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Jackson 序列化的主要类是<code>ObjectMapper </code>，它线程安全，所以一个实例可以被多个线程调用。我们使用学生类举例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">99</span>);</span><br><span class="line"><span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="comment">// 生成的 JSON 有缩进，更美观</span></span><br><span class="line">mapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> mapper.writeValueAsString(s);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span> <span class="punctuation">:</span> <span class="number">18</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;score&quot;</span> <span class="punctuation">:</span> <span class="number">99.0</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>整体使用还是非常简单的，Jackson 使用反射机制获取参与生成的字段。但是<strong>注意：</strong>类中参与生成的字段需要被<code>public</code>修饰或有公开的<code>getter</code>，如果没有字段参与生成会报错。<br><code>ObjectMapper</code>还有其它方法可以将 JSON 数据写进字节数组、文件、流中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] writeValueAsBytes(Object value)  <span class="comment">// 对象写进字节数组中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeValue</span><span class="params">(OutputStream out, Object value)</span>  <span class="comment">// 对象写进输出流中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeValue</span><span class="params">(Writer w, Object value)</span>  <span class="comment">// 对象写进 Writer 中</span></span><br><span class="line"><span class="comment">// 对象写进文件之中，文件不存在会创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeValue</span><span class="params">(File resultFile, Object value)</span></span><br></pre></td></tr></table></figure>
<p>例如我们可以使用<code>mapper.writeValue(new File(&quot;student.json&quot;), student);</code>将 JSON 串写进<code>.json</code>文件中。<br>反序列化也非常简单，调用<code>ObjectMapper</code>的<code>readValue</code>方法。只需要给这个方法传递两个参数，一个是输入源，一个是要解析的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> mapper.readValue(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;student.json&quot;</span>), Student.class);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>
<p>和序列化对应，输入源可以是字节数组、字符串等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">readValue</span><span class="params">(InputStream src, Class&lt;T&gt; valueType)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">readValue</span><span class="params">(Reader src, Class&lt;T&gt; valueType)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">readValue</span><span class="params">(String content, Class&lt;T&gt; valueType)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">readValue</span><span class="params">(<span class="type">byte</span>[] src, Class&lt;T&gt; valueType)</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>反序列化的时候会调用类的无参构造来创建对象，所如果类没有无参构造会报错。</p>
<h5 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h5><p>使用前先导包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意这个包会和上面 JSON 的包有共同依赖，如果版本不同可能会出现错误。幸运的是，这个包完全包含上面 JSON 需要的包，所以需要同时解析 XML 和 JSON 只需要导这个包即可。<br>XML 格式的序列化和反序列化与 JSON 相似，只不过将<code>ObjectMapper</code>替换成<code>XmlMapper</code>，使用代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">99</span>);</span><br><span class="line"><span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlMapper</span>();</span><br><span class="line">mapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> mapper.writeValueAsString(s);</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">ss</span> <span class="operator">=</span> mapper.readValue(str, Student.class);</span><br><span class="line">System.out.println(ss);</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Student</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">score</span>&gt;</span>99.0<span class="tag">&lt;/<span class="name">score</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Student</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>代码和上面完全一致，就是实例化对象变为了<code>XmlMapper</code>。<br>因为<code>XmlMapper</code>是<code>ObjectMapper</code>的子类，所以在 JSON 介绍的读写方法都是存在的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] writeValueAsBytes(Object value)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeValue</span><span class="params">(OutputStream out, Object value)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeValue</span><span class="params">(Writer w, Object value)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeValue</span><span class="params">(File resultFile, Object value)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">readValue</span><span class="params">(InputStream src, Class&lt;T&gt; valueType)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">readValue</span><span class="params">(Reader src, Class&lt;T&gt; valueType)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">readValue</span><span class="params">(String content, Class&lt;T&gt; valueType)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">readValue</span><span class="params">(<span class="type">byte</span>[] src, Class&lt;T&gt; valueType)</span></span><br></pre></td></tr></table></figure>
<h5 id="MessagePack"><a href="#MessagePack" class="headerlink" title="MessagePack"></a>MessagePack</h5><p>使用前先导包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.msgpack<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-msgpack<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.8.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个包里面也是包含 JSON 的包，如果版本冲突只添加这个包即可。<br>它的使用也非常简单，和 JSON 的使用几乎一样，只需要在创建<code>ObjectMapper</code>的时候传一个<code>MessagePackFactory</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">99</span>);</span><br><span class="line"><span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>(<span class="keyword">new</span> <span class="title class_">MessagePackFactory</span>());</span><br><span class="line">mapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line"><span class="type">byte</span>[] bs = mapper.writeValueAsBytes(s);</span><br><span class="line">System.out.println(Arrays.toString(bs));</span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">ss</span> <span class="operator">=</span> mapper.readValue(bs, Student.class);</span><br><span class="line">System.out.println(ss);</span><br></pre></td></tr></table></figure>
<p>因为创建的还是<code>ObjectMapper</code>，所以一些重载方法都是存在的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] writeValueAsBytes(Object value)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeValue</span><span class="params">(OutputStream out, Object value)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeValue</span><span class="params">(File resultFile, Object value)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">readValue</span><span class="params">(InputStream src, Class&lt;T&gt; valueType)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">readValue</span><span class="params">(<span class="type">byte</span>[] src, Class&lt;T&gt; valueType)</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>MessagePack 本身就是二进制格式，所以不支持序列化成字符串和 Writer，相应的从字符串和 Reader 中反序列化也是不支持的。</p>
<h5 id="容器对象"><a href="#容器对象" class="headerlink" title="容器对象"></a>容器对象</h5><p>容器对象主要包含数组、<code>List</code>和<code>Map</code>，这三种对象序列化的时候和普通对象没有区别，Jackson 会自动处理。反序列化的时候，需要传递类信息，这个需要注意一下：</p>
<ol>
<li>数组对象。我们使用学生数组举例子，反序列化的时候往<code>readValue</code>方法里面传递的类信息应该是<code>Student[].class</code>。</li>
<li><code>List</code>对象。反序列化的时候传递的类信息是<code>new TypeReference&lt;List&lt;Student&gt;&gt;()&#123;&#125; </code>，最后要加一对空的大括号，因为<code>TypeReference</code>是抽象类不能直接实例化。</li>
<li><code>Map</code>对象。传递<code>new TypeReference&lt;Map&lt;String, Student&gt;&gt;()&#123;&#125; </code>作为类型参数。</li>
</ol>
<h5 id="定制序列化-1"><a href="#定制序列化-1" class="headerlink" title="定制序列化"></a>定制序列化</h5><p>注意下面的这些操作我们会用 JOSN 格式的序列化&#x2F;反序列化举例子，实际上不论 XML 还是 MessagePack 都是一样的。</p>
<h6 id="忽略字段"><a href="#忽略字段" class="headerlink" title="忽略字段"></a>忽略字段</h6><p>在标准序列化里面，一个字段被标记为<code>transient</code>，这个字段在序列化的时候会被忽略。Jackson 想要实现这样的功能需要借助两个注解之一：</p>
<ul>
<li><code>@JsonIgnore</code>这个注解用于字段、<code>getter</code>、<code>setter</code>上面用于忽略一个字段。</li>
<li><code>@JsonIgnoreProperties</code>这个注解用于类的声明，可指定忽略的字段。</li>
</ul>
<p>例如我们想忽略学生成绩字段的两种做法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一，在对应字段头上加上注解 @JsonIgnore</span></span><br><span class="line"><span class="meta">@JsonIgnore</span></span><br><span class="line"><span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二，在类定义上加上注解 @JsonIgnoreProperties</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties(&quot;score&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要忽略多个字段，可以：</p>
<ul>
<li>在需要忽略的字段上都加上<code>@JsonIgnore</code>注解。</li>
<li>使用类似于<code>@JsonIgnoreProperties(&#123;&quot;score&quot;, &quot;age&quot;&#125;) </code>的形式。</li>
</ul>
<p><strong>注意：</strong><code>@JsonIgnore</code>可以加在字段上，还可以加在对应的<code>getter</code>或<code>setter</code>上，效果是等价的。忽略字段表示序列化和反序列化的时候都会忽略，即使 JSON 串里存在，反序列化的时候也会忽略。</p>
<h6 id="同一引用"><a href="#同一引用" class="headerlink" title="同一引用"></a>同一引用</h6><p>同一引用是指类里有多个变量指向同一个对象，看下面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> B b1;</span><br><span class="line">    <span class="keyword">public</span> B b2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">b.name = <span class="string">&quot;BName&quot;</span>;</span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">a.b1 = a.b2 = b;</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>a</code>中有两个变量指向同一个对象。<br>我们正常对<code>a</code>序列化，得到的输出如右所示。<br>此时再反序列化，可以发现<code>a</code>的字段<code>b1</code>和<code>b2</code>被解析成了两个对象，原来的同一个引用没有体现出来。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;b1&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;BName&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;b2&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;BName&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>想要保证反序列化后仍然是同一引用，可以使用<code>@JsonIdentityInfo</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonIdentityInfo(</span></span><br><span class="line"><span class="meta">    property = &quot;id&quot;,</span></span><br><span class="line"><span class="meta">    generator = ObjectIdGenerators.IntSequenceGenerator.class</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个注解有两个参数，<code>property=&quot;id&quot;</code>表示序列化这个类对象的时候添加一个<code>id</code>属性，<code>generator</code>参数表示新添加属性使用什么方式生成，这边使用整数顺序数生成器。<br>加上这个注解之后，序列化生成的 JSON 串如右。<br>我们发现<code>b2</code>变成了<code>b1</code>的 id，此时再反序列化<code>b1</code>和<code>b2</code>就会指向同一个对象了。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;b1&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span> <span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;BName&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;b2&quot;</span> <span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h6 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h6><p>循环引用就是 A 中有 B，B 中有 A。我们看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Child child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Parent parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">c.name = <span class="string">&quot;son&quot;</span>;</span><br><span class="line"><span class="type">Parent</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line">p.name = <span class="string">&quot;father&quot;</span>;</span><br><span class="line">p.child = c;</span><br><span class="line">c.parent = p;</span><br></pre></td></tr></table></figure>
<p>这种情况下，要是直接对<code>p</code>或<code>c</code>序列化，会陷入无限循环最终栈溢出报错。解决这个问题的方式是对两个互相引用的变量做标记，一个使用<code>@JsonManagedReference</code>标记为主引用，一个使用<code>@JsonBackReference</code>标记为反向引用。修改如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@JsonManagedReference</span></span><br><span class="line">    <span class="keyword">public</span> Child child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@JsonBackReference</span></span><br><span class="line">    <span class="keyword">public</span> Parent parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对变量<code>p</code>序列化的结果：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;father&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;child&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;son&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以发现<code>child</code>里面的<code>parent</code>字段没有出现，因为我们解决了循环引用的问题。<br>这样就可以处理循环引用的情况，反序列化之后循环引用也会被设置好，不需要我们操心。</p>
<h6 id="忽略未知字段"><a href="#忽略未知字段" class="headerlink" title="忽略未知字段"></a>忽略未知字段</h6><p>如果 JSON 串里存在一个字段但类中没有定义，这种情况在标准序列化里面会自动忽略，但在 Jackson 中会抛<code>UnrecognizedPropertyException</code>异常。如果我们也想忽略它怎么办呢？</p>
<ul>
<li>如果我们想对所有缺失的字段都进行忽略，可以配置<code>ObjectMapper</code>。</li>
<li>如果我们只想对某个类里面的缺失字段进行忽略，其它类的缺失仍然抛异常，可以使用<code>@JsonIgnoreProperties</code>注解。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一，对 ObjectMapper 进行配置</span></span><br><span class="line">mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二，添加 @JsonIgnoreProperties 注解</span></span><br><span class="line"><span class="comment">// 这种方式只会忽略 Student 类的缺失字段，其它类还是抛异常</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties(ignoreUnknown = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意，我们这边说的是 JSON 串里有多的字段，如果是 JSON 串少字段是不会报错的。</li>
</ul>
<h6 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h6><p>我们直接看一个案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> r)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Square</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Square</span><span class="params">(<span class="type">double</span> l)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.l = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Shape&gt; shapes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ShapeManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapeManager</span>();</span><br><span class="line">manager.shapes = List.of(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">6</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Square</span>(<span class="number">8</span>)</span><br><span class="line">);</span><br><span class="line"><span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">mapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> mapper.writeValueAsString(manager);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;shapes&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;r&quot;</span> <span class="punctuation">:</span> <span class="number">6.0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;l&quot;</span> <span class="punctuation">:</span> <span class="number">8.0</span></span><br><span class="line">  <span class="punctuation">&#125;</span> <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>主要有一个<code>Shape</code>类型的列表，里面实际装的可能是<code>Circle</code>，也可能是<code>Square</code>。序列化没有问题，使用<code>mapper.readValue(str, ShapeManager.class)</code>反序列化的时候出现了一个问题：<br>它会将<code>shapes</code>里面的元素全部看成<code>Shape</code>，但显然<code>Shape</code>类没有字段<code>r</code>和<code>l</code>，于是报错（当然你可以选择忽略缺失的字段，但这显然不合理）。我们现在想要反序列化的时候能自动识别<code>Circle</code>和<code>Square</code>，我们可以给<code>Shape</code>类加注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = &quot;type&quot;)</span></span><br><span class="line"><span class="meta">@JsonSubTypes(&#123;</span></span><br><span class="line"><span class="meta">    @JsonSubTypes.Type(value = Circle.class, name = &quot;Circle&quot;),</span></span><br><span class="line"><span class="meta">    @JsonSubTypes.Type(value = Square.class, name = &quot;Square&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>加完注解之后，生成的 JSON 串如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;shapes&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Circle&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;r&quot;</span> <span class="punctuation">:</span> <span class="number">6.0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Square&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;l&quot;</span> <span class="punctuation">:</span> <span class="number">8.0</span></span><br><span class="line">  <span class="punctuation">&#125;</span> <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看到每个<code>Shape</code>类对象都多了一个属性<code>type</code>，反序列化的时候会根据这个<code>type</code>寻找对应的类进行构造。</p>
<h6 id="修改字段名称"><a href="#修改字段名称" class="headerlink" title="修改字段名称"></a>修改字段名称</h6><p>目前为止序列化生成的字段名默认都是我们定义的变量名，我们想要修改生成的字段名。例如对于学生类来说，想要将生成的 JSON 字段名改成中文可以对相应的字段添加<code>@JsonProperty</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="meta">@JsonProperty(&quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@JsonProperty(&quot;年龄&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="meta">@JsonProperty(&quot;分数&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> score;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;姓名&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;年龄&quot;</span> <span class="punctuation">:</span> <span class="number">18</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;分数&quot;</span> <span class="punctuation">:</span> <span class="number">99.0</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面是序列化后对应的输出，字段名被我们修改成功，反序列化也没有问题。</p>
<h6 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h6><p>默认情况下，会将日期格式化成一个长整数，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyDate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;date&quot;</span> <span class="punctuation">:</span> <span class="number">1707188874700</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，日期对象被格式化成一个长整数。可读性比较差，我们想格式化成美观的格式可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyDate</span> &#123;</span><br><span class="line">    <span class="meta">@JsonFormat(pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;, timezone=&quot;GMT+8&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>右边就是格式化后的输出，注意时区是需要加上的，不然会有偏差。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;date&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2024-02-06 11:11:25&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h6 id="配置构造"><a href="#配置构造" class="headerlink" title="配置构造"></a>配置构造</h6><p>Jackson 反序列化默认会走类的无参构造，不存在无参构造会报错。如果我们想指定某个有参构造，可以借助<code>@JsonCreator</code>和<code>@JsonProperty </code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonCreator</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@JsonProperty(&quot;name&quot;)</span> String name,</span></span><br><span class="line"><span class="params">        <span class="meta">@JsonProperty(&quot;age&quot;)</span> <span class="type">int</span> age,</span></span><br><span class="line"><span class="params">        <span class="meta">@JsonProperty(&quot;score&quot;)</span> <span class="type">double</span> score)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以使用指定的构造而非默认无参构造。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/21/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8807%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/05/21/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8807%EF%BC%89/" itemprop="url">Java 基础系列（07）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-05-21T12:09:47+08:00">
                2023-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="文件基本技术"><a href="#文件基本技术" class="headerlink" title="文件基本技术"></a>文件基本技术</h3><h4 id="文件概述"><a href="#文件概述" class="headerlink" title="文件概述"></a>文件概述</h4><p>Java 处理文件有一些基本的概念，包括流、装饰器、Reader&#x2F;Writer、随机读写、File、NIO、序列化和反序列化。</p>
<h5 id="流"><a href="#流" class="headerlink" title="流"></a>流</h5><p>在 Java 中，文件被视为输入输出（IO）设备的一种。Java 使用基本统一的概念处理所有的 IO，包括键盘、文件、终端、网络等。<br>这种统一的概念就是<strong>流</strong>，流有<strong>输入流</strong>和<strong>输出流</strong>之分。我们可以从输入流中获取数据，输入流的提供者可以是键盘、文件、网络等；我们可以向输出流写入数据，输出流的目的地可以是终端、文件、网络等。<br>Java IO 的基本类大多位于包<code>java.io</code>中。类<code>InputStream</code>表示输入流，<code>outputStream</code>表示输出流；<code>FileInputStream</code>表示文件输入流，<code>FileOutputStream</code>表示文件输出流。</p>
<h5 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h5><p>基本流以字节为单位进行读写，没有缓冲区。而我们知道和硬盘打交道是很慢的，所以基本流操作很慢。Java 的解决方案是引入装饰器增强基本流的功能，以方便使用。<br>Java 有很多装饰器类，它们有两个基类<code>FilterInputStream</code>和<code>FilterOutputStream</code>。一些常见的装饰器有：</p>
<ol>
<li>提供缓冲区功能的装饰器<code>BufferedInputStream</code>和<code>BufferedOutputStream</code></li>
<li>可以对流按照基本数据类型读写的装饰器<code>DataInputStream</code>和<code>DataOutputStream</code></li>
<li>可以对流压缩和解压缩的装饰器<code>ZipInputStream</code>、<code>ZipOutputStream</code>、<code>GZIPInputStream</code>和<code>GZIPOutputStream</code></li>
<li>可以将对象输出为字符串表示的装饰器<code>PrintStream</code></li>
</ol>
<h5 id="Reader-Writer"><a href="#Reader-Writer" class="headerlink" title="Reader&#x2F;Writer"></a>Reader&#x2F;Writer</h5><p>以<code>InputStream</code>和<code>OutputStream</code>为基类的流基本都是以二进制处理数据，这就不能很好的处理文本文件。方便处理文本文件的基类是<code>Reader</code>和<code>Writer</code>，它们主要有以下子类：</p>
<ol>
<li>读写文件的子类是<code>FileReader</code>和<code>FileWriter</code></li>
<li>提供缓冲区装饰器的子类是<code>BufferedReader</code>和<code>BufferedWriter</code></li>
<li>将字符数组包装成<code>Reader/Writer</code>的子类是<code>CharArrayReader</code>和<code>CharArrayWriter</code></li>
<li>将字符串包装成<code>Reader/Writer</code>的子类是<code>StringReader</code>和<code>StringWriter</code></li>
<li>将<code>InputStream/OutputStream</code>转换成<code>Reader/Writer</code>的子类是<code>InputStreamReader</code>和<code>InputStreamWriter</code></li>
<li>可以将对象输出为字符串表示的子类<code>PrintWriter</code></li>
</ol>
<h5 id="随机读写"><a href="#随机读写" class="headerlink" title="随机读写"></a>随机读写</h5><p>除了上面的类，Java 还提供了能随机读写文件的类<code>RandomAccessFile</code>。</p>
<h5 id="File"><a href="#File" class="headerlink" title="File"></a>File</h5><p>上面说的都是操作文件的类，文件的描述信息（比如文件名、所在目录、权限等）由类<code>File</code>保存。</p>
<h5 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h5><p>NIO 即 New IO，对应的包是<code>java.nio</code>，它里面包含了很多其它的操作文件方法。后面我们将会主要介绍其中的内存映射文件。</p>
<h5 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h5><p>简单说，序列化就是把对象保存到流之中，反序列化就是从流中恢复对象到内存里。<br>Java 主要通过<code>Serializable</code>接口和<code>ObjectInputStream/ObjectOutputStream</code>类提供对序列化和反序列化的支持。不过这有些缺点：</p>
<ul>
<li>这样的序列化方式是 Java 特有的技术，没法跨语言交互</li>
<li>这样序列化后的形式浪费空间且效率也较低</li>
</ul>
<p>除了默认的方式，还有支持 XML 或 JSON 的序列化方式。</p>
<h4 id="二进制文件和字节流"><a href="#二进制文件和字节流" class="headerlink" title="二进制文件和字节流"></a>二进制文件和字节流</h4><h5 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h5><p><code>InputStream</code>是抽象类，是其它输入流的基类，它主要的方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>
<p><code>read</code>方法能从流中读取一个字节的内容并返回，虽然返回值类型是<code>int</code>，但实际取值是<code>0~255</code>，当读取到流结尾的时候会返回 -1。<br>如果流中没有数据（没数据不代表到结尾），<code>read</code>方法会阻塞直到数据到来、流被关闭或出现异常。出现异常<code>read</code>方法会抛出<code>IOException</code>，这是受检异常，调用者必须处理。<br><code>InputStream</code>还有如下读取多个字节内容的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个方法会读取多个字节内容存到字节数组<code>b</code>中，具体会根据实际情况最多读取<code>b.length</code>个字节的内容，方法会返回实际读取的字节数。若读取的时候直接遇到结束标记，方法会返回 -1。这个方法实现上是调用<code>read(b, 0, b.length)</code>，也就是第二个方法。</li>
<li>第二个方法会根据实际情况最多读取<code>len</code>个字节的内容存到<code>b[off, off+len)</code>中，这个方法返回的也是实际读取的字节数，读的时候一开始就遇到结束标记也是返回 -1。</li>
</ul>
<p>这两个方法在读取的时候若流中没有数据，这些方法也会阻塞，出现异常也会抛出<code>IOException</code>；批量读取的默认实现是循环调用单字节读取方法，但子类往往有更高效的实现。<br>流读取结束之后应该及时关闭流，关闭的方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<p>不管<code>read</code>是否抛出异常我们都应该调用<code>close</code>方法关闭流，因此<code>close</code>方法通常放在<code>finally</code>代码块里。<br><code>InputStream</code>的一些高级用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">mark</span><span class="params">(<span class="type">int</span> readlimit)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">markSupported</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<ul>
<li><code>skip</code>方法会跳过输入流中<code>n</code>个字节，因为输入流中剩余的字节数可能不满<code>n</code>，所以<code>skip</code>方法会返回实际跳过的字节数。</li>
<li><code>available</code>方法返回下一次不需要阻塞就能获取到的大概的字节数，一般用于网络数据的判定，<code>InputStream</code>的默认实现是返回 0。</li>
<li>一般流的读取是单向的，但有时我们需要先看一下后面的内容再根据情况重新读取，即我们希望能从读过的流中重复读取。我们可以在流某个位置使用<code>mark</code>方法做个标记，往后读的过程中可以调用<code>reset</code>方法回到做标记的地方开始读。<code>mark</code>方法里面有个参数<code>readlimit</code>，表示你回头的点不能超过这个范围，超过范围标记就无效了。之所以做这个限制，是因为内部会将标记点后面的内容存起来，要是内容太多可就浪费内存了。</li>
</ul>
<p><strong>注意，并不是所有流都支持</strong><code>**mark**</code><strong>和</strong><code>**reset**</code><strong>方法</strong>，是否支持可以使用方法<code>markSupported</code>查看。<code>InputStream</code>默认是不支持的。</p>
<h5 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h5><p><code>OutputStream</code>也是抽象类，是其它输出流的基类，方法的主要方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>
<p>这个方法会向流中写入一个字节的内容，虽然参数是<code>int</code>类型，但实际数据只会存储在参数的低 8 位。<br>除此之外，还有批量写入的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个方法实现上会调用<code>write(b, 0, b.length)</code></li>
<li>第二个方法是将<code>b[off, off+len)</code>的内容写到文件中，内部默认是循环调用单字节写入方法。一样的，子类往往有更高效的实现。</li>
</ul>
<p><code>OutputStream</code>还有两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<p><code>flush</code>方法能将缓冲区的内容真正写入到流中，而<code>OutputStream</code>是没有缓冲区的，所以这个方法默认实现就是空的。有缓冲区的输出流调用<code>flush</code>方法会将数据传给操作系统，至于操作系统什么时候写进磁盘是不能保证的，因此调用<code>flush</code>方法并不能百分百确保数据被保存到磁盘。<br><code>close</code>方法会先调用<code>flush</code>方法，再释放流占用的系统资源。同<code>InputStream</code>一样，输出流的<code>close</code>方法也应该写在<code>finally</code>块里。</p>
<h5 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h5><p><code>FileOutputStream</code>的输出目标是文件，它有多个构造方法，我们列举两个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileOutputStream</span><span class="params">(File file, <span class="type">boolean</span> append)</span> <span class="keyword">throws</span> FileNotFoundException</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileOutputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure>
<p>参数<code>file</code>和<code>name</code>都是为了指定打开的文件；<code>append</code>指定是否追加写入，<code>true</code>为追加，<code>false</code>为覆盖；第二个方法没有<code>append</code>参数，所以表示覆盖。<br>当我们<code>new FileOutputStream(...)</code>的时候会实际打开一个文件，操作系统也会分配相关的资源，若要打开的文件不存在会尝试创建文件。关于异常：</p>
<ol>
<li>若文件存在但当前用户没有写权限，会抛<code>SecurityException</code>异常，这个是一种<code>RuntimeException</code>。</li>
<li>指定的文件是目录或文件不存在且无法完成创建，会抛<code>FileNotFoundException</code>异常，这是<code>IOException</code>的子类。</li>
</ol>
<p>我们看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;hello.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;hello, 123&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] bytes = data.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    output.write(bytes);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子就是把一个字符串写到文件中，因为<code>write</code>方法只能写字节或字节数组，所以我们调用<code>String</code>的<code>getBytes</code>方法获取字符串的字节数组。按理说，我们应该把<code>close</code>方法放到<code>finally</code>块里，但因为我们这边使用<code>try-with-resources</code>语法，所以系统会帮我们调用<code>close</code>方法。<br>除此之外，<code>FileOutputStream</code>还有额外的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> FileChannel <span class="title function_">getChannel</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> FileDescriptor <span class="title function_">getFD</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>getChannel</code>方法会返回<code>FileChannel</code>对象。<code>FileChannel</code>定义在<code>java.nio</code>里面，表示文件通道，后面将要介绍的内存映射文件方法就定义在<code>FileChannel</code>里面。</li>
<li><code>getFD</code>方法返回<code>FileDescriptor</code>对象。<code>FileDescriptor</code>表示文件描述符，大部分情况我们用不到它，但它里面有个<code>sync</code>方法能确保数据写到磁盘。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> SyncFailedException;</span><br></pre></td></tr></table></figure>
<strong>需要注意，与</strong><code>**sync**</code><strong>方法对比的是</strong><code>**FileOutputStream**</code><strong>的</strong><code>**flush**</code><strong>方法，</strong><code>**flush**</code><strong>只是把数据给到操作系统，并不能确保数据会写到磁盘。</strong></li>
</ol>
<h5 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h5><p><code>FileInputStream</code>的输入源也是文件，主要构造有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure>
<p>参数<code>name</code>和<code>file</code>也用于指定需要打开的文件。<br>我们在<code>new FileInputStream(...)</code>的时候实际也会打开文件，操作系统也会分配相应的资源。如果文件不存在会抛<code>FileNotFoundException</code>异常；如果当前用户没有读权限则会抛<code>SecurityException</code>异常。我们看一个案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;hello.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> input.read(buff);</span><br><span class="line">    <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buff, <span class="number">0</span>, size, StandardCharsets.UTF_8);</span><br><span class="line">    System.out.println(data);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，就是读取文件内容并构造成字符串输出。这个代码假设文件内容不超过 1024 字节，对于一般情况，我们可以逐个字节读取直到文件结束：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;hello.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">int</span> b, size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> ((b = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        buff[size++] = (<span class="type">byte</span>)b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buff, <span class="number">0</span>, size, StandardCharsets.UTF_8);</span><br><span class="line">    System.out.println(data);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但请注意，在没有缓冲区的时候挨个字节读取效率是很低下的。除此之外，因为这种方法也是预先定义字节数组，所以能读取的最大字节数是固定的。</p>
<h5 id="ByteArrayOutputStream"><a href="#ByteArrayOutputStream" class="headerlink" title="ByteArrayOutputStream"></a>ByteArrayOutputStream</h5><p><code>ByteArrayOutputStream</code>的输出目标是字节数组，这个数组的大小是根据内容动态扩展的。它有两个构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ByteArrayOutputStream</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ByteArrayOutputStream</span><span class="params">(<span class="type">int</span> size)</span></span><br></pre></td></tr></table></figure>
<p><code>size</code>表示初始数组的大小，不传默认是 32。在输出过程中，数组不够用也是使用指数扩展的方法，每次增加一倍。<br><code>ByteArrayOutputStream</code>还有下面几种将流转换成字节数组或字符串的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">byte</span>[] toByteArray()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">toString</span><span class="params">()</span>  <span class="comment">// 使用默认编码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">toString</span><span class="params">(String charsetName)</span></span><br></pre></td></tr></table></figure>
<p><code>ByteArrayOutputStream</code>中的数据还能方便的写到另一个<code>OutputStream</code>中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">writeTo</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<p>除此之外，<code>ByteArrayOutputStream</code>还有下面两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p><code>size</code>方法返回当前写入的字节个数；<code>reset</code>方法将流中的字节个数重置为 0，注意已经分配的空间是不会变的。<br>了解这些，对于未知大小的文件，我们想要读取所有内容就可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;hello.txt&quot;</span>); output) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> ((size = input.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        output.write(buff, <span class="number">0</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(output.toString(StandardCharsets.UTF_8));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码思路就是每次最多读取 1024 字节存到<code>ByteArrayOutputStream</code>中，文件读取结束之后再将<code>ByteArrayOutputStream</code>转换成字符串输出。</p>
<h5 id="ByteArrayInputStream"><a href="#ByteArrayInputStream" class="headerlink" title="ByteArrayInputStream"></a>ByteArrayInputStream</h5><p><code>ByteArrayInputStream</code>能将字节数组包装成一个输入流，是一种适配器模式，构造有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ByteArrayInputStream</span><span class="params">(<span class="type">byte</span> buf[])</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ByteArrayInputStream</span><span class="params">(<span class="type">byte</span> buf[], <span class="type">int</span> offset, <span class="type">int</span> length)</span></span><br></pre></td></tr></table></figure>
<p>第二个构造是将<code>buf[offset, offset+length)</code>包装成输入流。<br><code>ByteArrayInputStream</code>所有数据都在内存里面（数组），且支持<code>mark/reset</code>操作。<br>之所以有这样的包装，就是为了能够像操作流一样操作字节数组，在某些情况下能保证代码的一致性。</p>
<h5 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a>DataOutputStream</h5><p><code>DataOutputStream</code>是<code>FilterOutputStream</code>的子类，<code>FilterOutputStream</code>是<code>OutputStream</code>的子类。上面介绍的输出流都是以字节为单位进行写，而<code>DataOutputStream</code>实现了以基本数据类型和字符串为单位写，构造是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DataOutputStream</span><span class="params">(OutputStream out)</span></span><br></pre></td></tr></table></figure>
<p><code>DataOutputStream</code>接受一个已存在的输出流，<code>DataOutputStream</code>所有的流操作基本都代理给了它。除此之外，<code>DataOutputStream</code>实现了<code>DataOutput</code>接口，接口内部分方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">writeBoolean</span><span class="params">(<span class="type">boolean</span> v)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">writeInt</span><span class="params">(<span class="type">int</span> v)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">writeUTF</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="comment">// 其它的 writeDouble、writeLong 等都有</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>writeBoolean</code>写入一个字节，值为<code>true</code>写入 1，否则写入 0。</li>
<li><code>writeInt</code>写入一个<code>int</code>，一共是 4 个字节，高位在前，低位在后。</li>
<li><code>writeUTF</code>将字符串按照<code>UTF8</code>编码写入。</li>
</ol>
<p>看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; list = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">99</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">19</span>, <span class="number">89</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">try</span>(<span class="type">DataOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;students.dat&quot;</span>))) &#123;</span><br><span class="line">    out.writeInt(list.size());</span><br><span class="line">    <span class="keyword">for</span> (Student s : list) &#123;</span><br><span class="line">        out.writeUTF(s.name);</span><br><span class="line">        out.writeInt(s.age);</span><br><span class="line">        out.writeDouble(s.score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个案例就是把列表里每一个学生按照某种格式写进文件。</p>
<h5 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a>DataInputStream</h5><p><code>DataInputStream</code>是<code>FilterInputStream</code>的子类，<code>FilterInputStream</code>是<code>InputStream</code>的子类。<code>DataInputStream</code>实现了以基本数据类型和字符串为单位读，构造是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DataInputStream</span><span class="params">(InputStream in)</span></span><br></pre></td></tr></table></figure>
<p>它接受一个已存在的输入流，读取时他会先按照字节读取内容并自己转换成对应的类型。除此之外，<code>DataInputStream</code>实现了<code>DataInput</code>接口，接口部分方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">readBoolean</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="type">int</span> <span class="title function_">readInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">String <span class="title function_">readUTF</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="comment">// 其它的 readDouble、readLong 等都有</span></span><br></pre></td></tr></table></figure>
<p>我们还是以上面的学生为例，现在要把文件的内容再按照格式读出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="type">DataInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;students.dat&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> in.readUTF();</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> in.readDouble();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Student</span>(name, age, score));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然使用这样的方式存储对象还是比较麻烦的，我们更多的是使用序列化的方式。</p>
<h5 id="BufferedIn-Out-putStream"><a href="#BufferedIn-Out-putStream" class="headerlink" title="BufferedIn(Out)putStream"></a>BufferedIn(Out)putStream</h5><p><code>FileInputStream/FileOutputStream</code>是没有缓冲区的，所以按照字节读取时效率是很低的。此时带缓冲区的装饰器类<code>BufferedInputStream/BufferedOutputStream</code>就出现了，它内部有一个字节数组作为缓冲区。每次读文件的时候会读一批数据到缓冲区，我们代码调用读会先读缓冲区，没数据再去文件读；写数据也是一样的操作。它的构造有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in, <span class="type">int</span> size)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedOutputStream</span><span class="params">(InputStream in)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedOutputStream</span><span class="params">(InputStream in, <span class="type">int</span> size)</span></span><br></pre></td></tr></table></figure>
<p>既然是装饰类，所以需要传一个已存在的流进去进行装饰。<code>size</code>表示缓冲区的大小，默认是 8192。</p>
<ul>
<li><code>BufferedInputStream</code>支持<code>mark/reset</code>操作，能够重复读取。</li>
<li><code>BufferedOutputStream</code>的<code>flush</code>方法会先将缓冲区内容写进包装的流里，在调用被包装流的<code>flush</code>方法写磁盘。</li>
</ul>
<p>我们在使用<code>FileInputStream/FileOutputStream</code>时应该总是将它们包装成<code>BufferedInputStream/BufferedOutputStream</code>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;hello.txt&quot;</span>));</span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;hello.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">DataOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;students.dat&quot;</span>)));</span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;students.dat&quot;</span>)));</span><br></pre></td></tr></table></figure>
<h5 id="实用方法"><a href="#实用方法" class="headerlink" title="实用方法"></a>实用方法</h5><p>这个小结主要封装一些实用的文件操作。</p>
<h6 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h6><p>我们常用的一个方法是将输入流的内容复制到输出流里面，我们可以实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(InputStream input, </span></span><br><span class="line"><span class="params">                        OutputStream output)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8192</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((bytesRead = input.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    	output.write(buf, <span class="number">0</span>, bytesRead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java9 中，<code>InputStream</code>类增加了一个方法<code>transferTo</code>，实现了类似的功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">transferTo</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    Objects.requireNonNull(out, <span class="string">&quot;out&quot;</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">transferred</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[DEFAULT_BUFFER_SIZE]; <span class="comment">// 默认大小 8192</span></span><br><span class="line">    <span class="type">int</span> read;</span><br><span class="line">    <span class="keyword">while</span>((read = <span class="built_in">this</span>.read(buffer, <span class="number">0</span>, DEFAULT_BUFFER_SIZE)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        out.write(buffer, <span class="number">0</span>, read);</span><br><span class="line">        transferred += read;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> transferred;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="写数组"><a href="#写数组" class="headerlink" title="写数组"></a>写数组</h6><p>将文件内容写进一个字节数组也是一个实用功能，我们将依赖上面的<code>transferTo</code>方法实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] readFileToByteArray(String fileName) <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName)) &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        input.transferTo(output);</span><br><span class="line">        <span class="keyword">return</span> output.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h6><p>将字节数组内容写到文件也是实用功能，实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeByteArrayToFile</span><span class="params">(String fileName,</span></span><br><span class="line"><span class="params">                                        <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(fileName)) &#123;</span><br><span class="line">        output.write(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="文本文件和字符流"><a href="#文本文件和字符流" class="headerlink" title="文本文件和字符流"></a>文本文件和字符流</h4><p>上面介绍的字节流以字节为单位处理文件，这没有编码的概念，也不能按行处理。而字符流能以字符为单位处理文件，比较适合处理文本文件。例如我们想把整数 123 存到文件里，则两个文件的内容：<br>二进制文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 7B</span><br></pre></td></tr></table></figure>
<p>文本文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">31</span> <span class="number">32</span> <span class="number">33</span></span><br></pre></td></tr></table></figure>
<p>上面两种是文件里二进制数据的十六进制形式，可以看到二进制文件就是直接存储数据的二进制，而文本文件是将数据看成字符串按字符编码存储（存的也是二进制）。</p>
<h5 id="Reader-Writer-1"><a href="#Reader-Writer-1" class="headerlink" title="Reader&#x2F;Writer"></a>Reader&#x2F;Writer</h5><p><code>Reader</code>和<code>Writer</code>是字符流的基类，它们是抽象类。<br><code>Reader</code>的主要方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span> cbuf[])</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">ready</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<p>这些方法的含义与<code>InputStream</code>里面的同名方法基本一样，不过处理的单位是<code>char</code>而不是字节。需要额外说明的是：</p>
<ul>
<li><code>read</code>方法虽然会返回一个<code>int</code>，但实际上只会使用<code>int</code>的低 16 位，用来存储一个<code>char</code>，范围是<code>0~65535</code>。</li>
<li><code>ready</code>方法和<code>InputStream</code>的<code>available</code>功能相似，它会返回该<code>Reader</code>是否准备好被读。</li>
</ul>
<p><code>Writer</code>的主要方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span> cbuf[])</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>
<p>这些方法没有好说的。</p>
<h5 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h5><p><code>OutputStreamWriter</code>是适配器类，能将<code>OutputStream</code>转换成<code>Writer</code>。它主要的构造是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">OutputStreamWriter</span><span class="params">(OutputStream out)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">OutputStreamWriter</span><span class="params">(OutputStream out, String charsetName)</span></span><br></pre></td></tr></table></figure>
<p>一个重要参数是字符编码，这个字符编码可以使用字符串或<code>Charset</code>对象表示。如果不传会使用默认编码，默认编码可以使用<code>Charset.defaultCharset()</code>获取。<code>OutputStreamWriter</code>里有一个类型为<code>StreamEncoder</code>的编码器用于将<code>char</code>转换成对应编码的字节。<br>我们看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;hello.txt&quot;</span>), StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    writer.write(<span class="string">&quot;你好，世界&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子就是使用<code>OutputStreamWriter</code>输出一个字符串到文件里。</p>
<h5 id="InputStreamWriter"><a href="#InputStreamWriter" class="headerlink" title="InputStreamWriter"></a>InputStreamWriter</h5><p><code>InputStreamReader</code>是适配器类，能将<code>InputStream</code>转换成<code>Reader</code>。它主要的构造是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream in)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream in, String charsetName)</span></span><br></pre></td></tr></table></figure>
<p>和上面类似，里面有一个表示编码的参数。<code>InputStreamReader</code>里面有一个类型是<code>StreamDecoder</code>的解码器，能将字节根据编码解析成<code>char</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;hello.txt&quot;</span>), StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> reader.read(buf);</span><br><span class="line">    <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, size);</span><br><span class="line">    System.out.println(data);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子就是将上面的文件里的内容读取出来并输出，不过有一个缺陷就是我们假定文件内容不超过 1024 个<code>char</code>。</p>
<h5 id="FileReader-FileWriter"><a href="#FileReader-FileWriter" class="headerlink" title="FileReader&#x2F;FileWriter"></a>FileReader&#x2F;FileWriter</h5><p><code>FileReader</code>的输入源是文件，它是<code>InputStreamReader</code>的子类，它主要的构造有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileReader</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileReader</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure>
<p><code>FileWriter</code>的目的地也是文件，他是<code>OutputStreamWriter</code>的子类，他主要的构造有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(String fileName, <span class="type">boolean</span> append)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<p><code>append</code>参数表示是否追加写入，<code>true</code>表示追加，<code>false</code>表示覆盖。<br>需要注意的是<code>FileReader</code>和<code>FileWriter</code>是不能指定编码的，只能使用默认编码。</p>
<h5 id="CharArrayReader-Writer"><a href="#CharArrayReader-Writer" class="headerlink" title="CharArrayReader(Writer)"></a>CharArrayReader(Writer)</h5><p><code>CharArrayReader</code>与<code>ByteArrayInputStream</code>类似，它能将一个<code>char</code>数组包装<code>Reader</code>，是一种适配器类。它的构造主要有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CharArrayReader</span><span class="params">(<span class="type">char</span> buf[])</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CharArrayReader</span><span class="params">(<span class="type">char</span> buf[], <span class="type">int</span> offset, <span class="type">int</span> length)</span></span><br></pre></td></tr></table></figure>
<p>这里第二个构造是使用<code>buf[offset, offset+length)</code>作为输入源。<br><code>CharArrayWriter</code>与<code>ByteArrayOutputStream</code>类似，它的输出目标是<code>char</code>数组，数组的长度可以根据内容动态扩展。它的构造主要有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CharArrayWriter</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CharArrayWriter</span><span class="params">(<span class="type">int</span> initialSize)</span></span><br></pre></td></tr></table></figure>
<p><code>initialSize</code>用来指定数组初始大小，不传默认是 32。<br><code>CharArrayWriter</code>有以下方法能将数据转换成字符数组或字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">char</span>[] toCharArray()</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>仍然是上面的例子，如果文件大小未知且我们想读取所有内容可以这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;hello.txt&quot;</span>), StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">CharArrayWriter</span> <span class="variable">caw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharArrayWriter</span>();</span><br><span class="line">    <span class="keyword">while</span> ((size = reader.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        caw.write(buf, <span class="number">0</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(caw.toString());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们每次从文件里读取内容并写进<code>CharArrayWriter</code>里面，最后直接调用<code>CharArrayWriter</code>的<code>toString</code>方法获取所有内容。</p>
<h5 id="StringReader-Writer"><a href="#StringReader-Writer" class="headerlink" title="StringReader(Writer)"></a>StringReader(Writer)</h5><p><code>StringReader</code>与<code>CharArrayReader</code>类似，只不过操作对象从<code>char</code>数组变成了字符串。<br><code>StringWriter</code>与<code>CharArrayWriter</code>也是类似，操作对象变成了<code>StringBuffer</code>。</p>
<h5 id="BufferedReader-Writer"><a href="#BufferedReader-Writer" class="headerlink" title="BufferedReader(Writer)"></a>BufferedReader(Writer)</h5><p><code>BufferedReader</code>是装饰类，它提供缓冲区及按行读的功能。它的主要构造有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedReader</span><span class="params">(Reader in)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedReader</span><span class="params">(Reader in, <span class="type">int</span> sz)</span></span><br></pre></td></tr></table></figure>
<p>它需要一个被包装的<code>Reader</code>，以及参数<code>sz</code>表示缓冲区的大小，不传默认是 8192。<br>它有一个方法如下每次可以读取一行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">readLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<p>字符<code>&#39;\r&#39;、&#39;\n&#39;、&#39;\r\n&#39;</code>都被视为换行符。<code>readLine</code>会返回一行内容但不包含结尾的换行符，读到流结尾是返回<code>null</code>。<br><code>BufferedWriter</code>也是装饰类，它提供缓冲区及按行写的功能。它的主要构造有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedWriter</span><span class="params">(Writer out)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedWriter</span><span class="params">(Writer out, <span class="type">int</span> sz)</span></span><br></pre></td></tr></table></figure>
<p>它有一个方法如下可以输出平台特定的换行符（不同平台换行符往往是不一样的）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<p>因为<code>FileReader/FileWriter</code>没有缓冲区，所以使用的时候一般会在外面包上这两个缓冲类。我们下面看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将学生列表写进文件，一个学生占一行，字段之间使用逗号隔开</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeStus</span><span class="params">(List&lt;Student&gt; list, String fileName)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(fileName))) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Student s : list) &#123;</span><br><span class="line">            bw.write(<span class="string">&quot;%s,%d,%f&quot;</span>.formatted(s.name, s.age, s.score));</span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照指定格式读取文件并构造学生列表返回</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">readStus</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">    List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(fileName))) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        <span class="keyword">while</span> (line != <span class="literal">null</span>) &#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> fields[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(fields[<span class="number">1</span>]);</span><br><span class="line">            <span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> Double.parseDouble(fields[<span class="number">2</span>]);</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(name, age, score));</span><br><span class="line">            line = br.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h5><p><code>PrintWriter</code>是字符打印流，它能将对象的字符串形式输出到文件里。它有以下构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWriter</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWriter</span><span class="params">(String fileName, String csn)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWriter</span><span class="params">(OutputStream out, <span class="type">boolean</span> autoFlush)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWriter</span><span class="params">(Writer out)</span></span><br></pre></td></tr></table></figure>
<p>参数<code>csn</code>表示编码类型；<code>autoFlush</code>表示同步缓冲区，设为<code>true</code>则会在调用<code>println、printf、format</code>等方法时自动调用<code>flush</code>方法而不需要手动调用，不传递默认是<code>false</code>。<br>对于不传递<code>Writer</code>的构造，内部都会构造一个<code>BufferedWriter</code>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWriter</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(fileName))), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWriter</span><span class="params">(OutputStream out, <span class="type">boolean</span> autoFlush)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(out)), autoFlush);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而对于传递<code>Writer</code>的构造就不会包装成<code>BufferedWriter</code>了。<br><code>PrintWriter</code>有很多重载的<code>print</code>方法，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Object obj)</span></span><br></pre></td></tr></table></figure>
<p>它会将这些参数转换成对应的字符串形式并调用内部流的<code>write</code>方法写，转换字符串使用的是<code>String.valueOf()</code>方法。<br>除此之外，还有<code>println</code>方法以及格式化的<code>format</code>方法。<code>println</code>方法会在输出的最后添加一个换行，而<code>format</code>方法会使用格式化字符串进行输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(Object x)</span></span><br><span class="line"><span class="keyword">public</span> PrintWriter <span class="title function_">format</span><span class="params">(String format, Object ... args)</span></span><br></pre></td></tr></table></figure>
<p>将学生列表按照格式写进文件可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeStus</span><span class="params">(List&lt;Student&gt; list, String fileName)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(fileName)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Student s : list) &#123;</span><br><span class="line">            pw.format(<span class="string">&quot;%s,%d,%f&quot;</span>, s.name, s.age, s.score);</span><br><span class="line">            pw.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h5><p><code>Scanner</code>是文本扫描器，能够解析基本数据类型和字符串。它需要一个分隔符将不同的数据区分开来，默认使用空白符，我们也可以使用<code>useDelimiter(String)</code>方法来指定分隔符。<br><code>Scanner</code>有很多形式的<code>next</code>方法，用于读取下一个基本数据类型、字符串或一整行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span>  <span class="comment">// 获取下一个字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span>  <span class="comment">// 获取下一个整数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">float</span> <span class="title function_">nextFloat</span><span class="params">()</span>  <span class="comment">// 获取下一个浮点数</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">nextLine</span><span class="params">()</span>  <span class="comment">// 获取一行，当前行没读完就返回当前行剩余部分</span></span><br></pre></td></tr></table></figure>
<p><code>Scanner</code>有很多构造，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Scanner</span><span class="params">(File source)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Scanner</span><span class="params">(InputStream source)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Scanner</span><span class="params">(String source)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">StringReader</span>(source), WHITESPACE_PATTERN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当传进去一个字符串时会构造一个<code>StringReader</code>，我们还是以前面解析学生记录为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">readStus</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">    List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(fileName))) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        <span class="keyword">while</span> (line != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(line).useDelimiter(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(name, age, score));</span><br><span class="line">            line = br.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="标准流"><a href="#标准流" class="headerlink" title="标准流"></a>标准流</h5><p>我们经常使用的<code>System.out</code>就是标准流，它是<code>PrintStream</code>对象，<code>PrintStream</code>用法与<code>PrintWriter</code>基本一致，这些标准流的目标默认都是屏幕或键盘。除了<code>System.out</code>，Java 还有两个标准流：<code>System.in</code>和<code>System.err</code>。<br><code>System.err</code>是标准错误流，一般异常和错误信息会输出到这个流，默认目标也是屏幕。<br>例如我们想从键盘获取数据，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">System.out.println(num);</span><br></pre></td></tr></table></figure>
<p>标准流的重要特点就是可以重定向，比如可以重定向到文件，从文件读取输入或将信息输出到文件。我们可以使用<code>System</code>类的<code>setIn、setOut、setErr</code>方法进行重定向：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    System.setIn(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(</span><br><span class="line">        <span class="string">&quot;hello&quot;</span>.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">    System.setOut(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;out.txt&quot;</span>));</span><br><span class="line">    System.setErr(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;err.txt&quot;</span>));</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(in.nextLine());</span><br><span class="line">    System.out.println(in.nextLine());</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    System.err.println(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个案例将标准输入流重定向到自定义的<code>ByteArrayInputStream</code>中，再分别将标准输出流与标准错误流重定向到文件中。因为输入只有一行，第二次调用<code>nextLine()</code>方法抛异常。</p>
<h5 id="实用方法-1"><a href="#实用方法-1" class="headerlink" title="实用方法"></a>实用方法</h5><h6 id="复制-1"><a href="#复制-1" class="headerlink" title="复制"></a>复制</h6><p>复制<code>Reader</code>的内容到<code>Writer</code>中，可以封装如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(<span class="keyword">final</span> Reader input,</span></span><br><span class="line"><span class="params">		<span class="keyword">final</span> Writer output)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">4096</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">charsRead</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((charsRead = input.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    	output.write(buf, <span class="number">0</span>, charsRead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="读到字符串"><a href="#读到字符串" class="headerlink" title="读到字符串"></a>读到字符串</h6><p>读取文件内容写到字符串中，可以封装如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readFileToString</span><span class="params">(<span class="keyword">final</span> String fileName,</span></span><br><span class="line"><span class="params">		<span class="keyword">final</span> String encoding)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName), encoding))) &#123;</span><br><span class="line">        <span class="type">StringWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">        copy(reader, writer);</span><br><span class="line">        <span class="keyword">return</span> writer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="写文件-1"><a href="#写文件-1" class="headerlink" title="写文件"></a>写文件</h6><p>将字符串内容写到文件中，封装如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeStringToFile</span><span class="params">(<span class="keyword">final</span> String fileName,</span></span><br><span class="line"><span class="params">		<span class="keyword">final</span> String data, <span class="keyword">final</span> String encoding)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(fileName), encoding)) &#123;</span><br><span class="line">        writer.write(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="按行写文件"><a href="#按行写文件" class="headerlink" title="按行写文件"></a>按行写文件</h6><p>按行将多行数据写到文件中，可以封装如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeLines</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> String encoding,</span></span><br><span class="line"><span class="params">		<span class="keyword">final</span> Collection&lt;?&gt; lines)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(fileName, encoding)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object line : lines) &#123;</span><br><span class="line">            writer.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="按行读文件"><a href="#按行读文件" class="headerlink" title="按行读文件"></a>按行读文件</h6><p>按行将文件内容读到一个列表中，可以封装如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">readLines</span><span class="params">(<span class="keyword">final</span> String fileName,</span></span><br><span class="line"><span class="params">		<span class="keyword">final</span> String encoding)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName), encoding))) &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">        <span class="keyword">while</span> (line != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.add(line);</span><br><span class="line">            line = reader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h4><p>尽管不同平台的文件操作是不一样的，但 Java 给我们提供了<code>java.io.File</code>类来统一操作。文件操作大概分为 3 类：文件元数据、文件操作、目录操作。</p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p><code>File</code>既可以表示文件，也可以表示目录，主要构造有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String pathname)</span>  <span class="comment">// 直接传递文件(目录)路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parent 表示父目录，child 表示最后的文件或目录</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String parent, String child)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">File</span><span class="params">(File parent, String child)</span></span><br></pre></td></tr></table></figure>
<p>给构造传递的路径可以指向存在的文件，也可以指向不存在的文件。就算路径所指文件不存在，创建<code>File</code>对象的时候也并不会去新建这个文件。注意，创建完成之后，<code>File</code>对象的所指的路径是不可变的。</p>
<h5 id="文件元数据"><a href="#文件元数据" class="headerlink" title="文件元数据"></a>文件元数据</h5><p>文件元数据主要包括：文件名、路径、文件基本信息、文件安全或权限相关信息等。相关的主要方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>  <span class="comment">// 返回最后一段文件或目录名</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAbsolute</span><span class="params">()</span>  <span class="comment">// 返回构造时传递的是否是绝对路径</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span>  <span class="comment">// 返回构造时传递的完整路径名，相当于把传递的各个部分拼接成一段</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getAbsolutePath</span><span class="params">()</span>  <span class="comment">// 返回完整的绝对路径名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回标准的绝对路径名，所谓标准就是会把路径里面的 ./、../ 之类的去掉</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getCanonicalPath</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getParent</span><span class="params">()</span>  <span class="comment">// 返回最后一段前面的目录部分即父目录</span></span><br><span class="line"><span class="keyword">public</span> File <span class="title function_">getParentFile</span><span class="params">()</span>  <span class="comment">// 返回父目录的文件对象</span></span><br><span class="line"><span class="keyword">public</span> File <span class="title function_">getAbsoluteFile</span><span class="params">()</span>  <span class="comment">// 返回使用 getAbsolutePath() 构造的文件对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回使用 getCanonicalPath() 构造的文件对象</span></span><br><span class="line"><span class="keyword">public</span> File <span class="title function_">getCanonicalFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<p>注意上面说的返回路径之类的方法，没有明确说返回绝对路径的，返回的时候是不会转成绝对路径的。<br><code>File</code>里还有四个表示分隔符的静态变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String separator</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span> separatorChar</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String pathSeparator</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span> pathSeparatorChar</span><br></pre></td></tr></table></figure>
<p><code>separator</code>和<code>separatorChar</code>表示文件路径分隔符，一般 Windows 里的文件分隔符是<code>\</code>，而 Linux 里的分隔符是<code>/</code>；<code>pathSeparator</code>和<code>pathSeparatorChar</code>表示路径分隔符，一般路径分隔符用于环境变量里面将多个路径分隔，Windows 的路径分隔符为<code>;</code>而 Linux 的路径分隔符是<code>:</code>。<br>除此之外，<code>File</code>还有一些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span>  <span class="comment">// 返回路径指向的文件是否存在</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDirectory</span><span class="params">()</span>  <span class="comment">// 返回路径指向的是否是目录</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFile</span><span class="params">()</span>  <span class="comment">// 返回路径指向的是否是文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">length</span><span class="params">()</span>  <span class="comment">// 返回路径所指文件的字节数，这个方法对目录没有意义</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lastModified</span><span class="params">()</span>  <span class="comment">// 返回文件的最后修改时间（距离纪元时的毫秒数）</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">setLastModified</span><span class="params">(<span class="type">long</span> time)</span>  <span class="comment">// 设置文件最后修改时间</span></span><br></pre></td></tr></table></figure>
<p>对于这些方法有一些注意点：</p>
<ol>
<li>调用<code>isFile</code>和<code>isDirectory</code>的前提是文件存在，若文件不存在这两个方法均返回<code>false</code>。</li>
<li><code>File</code>对象没有读取或修改文件创建时间的方法，因为创建时间不是公共概念，Linux 系统上的文件就没有创建时间的概念。</li>
<li>对于不存在的文件，调用<code>length</code>和<code>lastModified</code>都返回 0。</li>
</ol>
<p><code>File</code>类与安全和权限相关的主要方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHidden</span><span class="params">()</span>  <span class="comment">// 是否为隐藏文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canExecute</span><span class="params">()</span>  <span class="comment">// 是否可执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canRead</span><span class="params">()</span>  <span class="comment">// 是否可读</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canWrite</span><span class="params">()</span>  <span class="comment">// 是否可写</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">setReadOnly</span><span class="params">()</span>  <span class="comment">// 设置文件为只读文件</span></span><br><span class="line"><span class="comment">// 修改文件读权限</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">setReadable</span><span class="params">(<span class="type">boolean</span> readable, <span class="type">boolean</span> ownerOnly)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">setReadable</span><span class="params">(<span class="type">boolean</span> readable)</span></span><br><span class="line"><span class="comment">// 修改文件写权限</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">setWritable</span><span class="params">(<span class="type">boolean</span> writable, <span class="type">boolean</span> ownerOnly)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">setWritable</span><span class="params">(<span class="type">boolean</span> writable)</span></span><br><span class="line"><span class="comment">// 修改文件可执行权限</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">setExecutable</span><span class="params">(<span class="type">boolean</span> executable, <span class="type">boolean</span> ownerOnly)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">setExecutable</span><span class="params">(<span class="type">boolean</span> executable)</span></span><br></pre></td></tr></table></figure>
<p>所有<code>setXXX</code>方法都会返回是否修改成功；<code>ownerOnly</code>参数为<code>true</code>表示只针对文件所有者，为<code>false</code>表示针对所有用户，默认是<code>true</code>。</p>
<h5 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h5><h6 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h6><p>创建<code>File</code>对象并不会实际创建文件，想要创建对应的文件可以调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">createNewFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<p>这个方法在文件已经存在的情况下直接返回<code>false</code>表示创建失败，创建成功会返回<code>true</code>。<strong>注意，这个方法创建的一定是文件，即使文件名没有后缀也会被当做无后缀文件。</strong><br><code>File</code>类还有两个创建临时文件的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title function_">createTempFile</span><span class="params">(String prefix, </span></span><br><span class="line"><span class="params">                                  String suffix)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title function_">createTempFile</span><span class="params">(String prefix, String suffix, </span></span><br><span class="line"><span class="params">                                  File directory)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<p>这个方法会根据你提供的信息将临时文件创建出来并返回对应的<code>File</code>对象，主要有三个参数：</p>
<ul>
<li><code>prefix</code>表示文件名的前缀，文件名由前缀和随机数两部分构成且前缀的长度不能小于 3</li>
<li><code>suffix</code>表示文件的扩展名，传<code>null</code>默认会使用<code>.tmp</code></li>
<li><code>directory</code>表示临时文件所在目录，不指定会使用系统默认路径</li>
</ul>
<h6 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h6><p><code>File</code>类的删除方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteOnExit</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>这两个既可以删除文件也可以删除目录，<code>delete</code>会返回删除是否成功。<code>deleteOnExit</code>方法会将文件加入到待删列表，在虚拟机正常退出的时候进行实际删除。注意这两个方法不能删除有子文件或子目录的目录，因此想要使用这个方法删除目录，需要先将目录里面清空。</p>
<h6 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h6><p><code>File</code>重命名的方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">renameTo</span><span class="params">(File dest)</span></span><br></pre></td></tr></table></figure>
<p><code>dest</code>表示重命名后的文件，方法会返回是否重命名成功。</p>
<h5 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h5><p>当<code>File</code>表示目录的时候，可以进行目录操作如创建、遍历等。<br>目录的创建有如下两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mkdir</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mkdirs</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>它们都是创建目录且都会返回是否创建成功，区别在于若指定的路径中有中间目录不存在：</p>
<ul>
<li><code>mkdir</code>会创建失败，返回<code>false</code></li>
<li><code>mkdirs</code>会创建中间目录</li>
</ul>
<p>有如下方法可以遍历目录下的直接子文件或子目录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] list()</span><br><span class="line"><span class="keyword">public</span> String[] list(FilenameFilter filter)</span><br><span class="line"><span class="keyword">public</span> File[] listFiles()</span><br><span class="line"><span class="keyword">public</span> File[] listFiles(FileFilter filter)</span><br><span class="line"><span class="keyword">public</span> File[] listFiles(FilenameFilter filter)</span><br></pre></td></tr></table></figure>
<p><code>list</code>返回的是文件名数组，而<code>listFiles</code>返回的是<code>File</code>对象数组。<br>这些方法里主要有两个参数<code>FileFilter</code>和<code>FilenameFilter</code>表示过滤器，只有满足过滤器筛选的文件才会加入到返回结果中。过滤器的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FileFilter</span> &#123;</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File pathname)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FilenameFilter</span> &#123;</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传递了过滤器情况下，每一个文件或文件名都会使用过滤器的<code>accept</code>方法进行判定，只有返回<code>true</code>才会放行。我们看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">String[] children = f.list(<span class="keyword">new</span> <span class="title class_">FilenameFilter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name.endsWith(<span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(children));</span><br></pre></td></tr></table></figure>
<p>这个例子就是列出当前目录下所有以<code>.txt</code>结尾的文件名。</p>
<h5 id="实用方法-2"><a href="#实用方法-2" class="headerlink" title="实用方法"></a>实用方法</h5><h6 id="统计大小"><a href="#统计大小" class="headerlink" title="统计大小"></a>统计大小</h6><p>统计一个目录包含其所有子文件的大小可以使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sizeOfDirectory</span><span class="params">(<span class="keyword">final</span> File dir)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dir.isFile()) <span class="keyword">return</span> dir.length();</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (File f : dir.listFiles()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f.isFile()) size += f.length();</span><br><span class="line">        <span class="keyword">else</span> size += sizeOfDirectory(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h6><p>在一个目录及其子目录下查找所有指定文件名的文件可以使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;File&gt; <span class="title function_">findFile</span><span class="params">(<span class="keyword">final</span> File dir, <span class="keyword">final</span> String fileName)</span> &#123;</span><br><span class="line">    List&lt;File&gt; fs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (File f : dir.listFiles()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f.isDirectory()) fs.addAll(findFile(f, fileName));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (f.getName().equals(fileName)) fs.add(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h6><p>我们知道<code>delete</code>方法只能删除空目录，对于有文件的目录可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteDirectory</span><span class="params">(<span class="keyword">final</span> File dir)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">suc</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (dir.isFile()) &#123;</span><br><span class="line">        suc = dir.delete();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dir.isDirectory()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (File f : dir.listFiles()) &#123;</span><br><span class="line">            deleteDirectory(f);</span><br><span class="line">        &#125;</span><br><span class="line">        suc = dir.delete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!suc) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(</span><br><span class="line">            <span class="string">&quot;Failed to delete file \&quot;&quot;</span> + dir.getCanonicalPath() + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/03/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8806%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/05/03/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8806%EF%BC%89/" itemprop="url">Java 基础系列（06）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-05-03T12:09:44+08:00">
                2023-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="通用容器类及总结"><a href="#通用容器类及总结" class="headerlink" title="通用容器类及总结"></a>通用容器类及总结</h3><h4 id="抽象容器类"><a href="#抽象容器类" class="headerlink" title="抽象容器类"></a>抽象容器类</h4><p>抽象容器类与之前介绍的具体容器类和对应接口的关系如图：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1561375/1704095966939-5f131499-aa53-418d-8a77-876cf53a6dd9.png#averageHue=%23f1f1f1&clientId=u3228b221-dbf5-4&from=paste&height=503&id=u3a639394&originHeight=503&originWidth=966&originalType=binary&ratio=1&rotation=0&showTitle=false&size=192262&status=done&style=none&taskId=ub0627982-fb10-49f5-abb8-589170700de&title=&width=966" alt="image.png"><br>图中虚线框表示接口，主要有<code>Collection、List、Set、Queue、Deque、Map</code>。除此之外，有 6 个抽象容器类：</p>
<ol>
<li><code>AbstractCollection</code>实现了<code>Collection</code>接口，被抽象类<code>AbstractList、AbstractSet、AbstractQueue</code>继承。除此之外，<code>ArrayDeque</code>也继承于它，图中未画出。</li>
<li><code>AbstractList</code>父类是<code>AbstractCollection</code>，实现了<code>List</code>接口，被<code>ArrayList、AbstractSequentialList</code>继承。</li>
<li><code>AbstractSequentialList</code>父类是<code>AbstractList</code>，被<code>LinkedList</code>继承。</li>
<li><code>AbstractSet</code>父类是<code>AbstractCollection</code>，实现了<code>Set</code>接口，被<code>HashSet、TreeSet、EnumSet</code>继承。</li>
<li><code>AbstractQueue</code>父类是<code>AbstractCollection</code>，实现了<code>Queue</code>接口，被<code>PriorityQueue</code>继承。</li>
<li><code>AbstractMap</code>实现了<code>Map</code>接口，被<code>TreeMap、HashMap、EnumMap</code>继承。</li>
</ol>
<h5 id="AbstractCollection"><a href="#AbstractCollection" class="headerlink" title="AbstractCollection"></a>AbstractCollection</h5><p><code>AbstractCollection</code>提供了<code>Collection</code>的基本实现，具体来说实现了以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray()</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a)</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p><code>AbstractCollection</code>又不知道数据是怎么存储的，上面这些方法是怎么实现的呢？这主要依赖于以下三个更基础的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>add</code>方法的默认实现是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接抛出一个异常，若子类集合不允许添加元素，就可以使用这默认的实现，否则必须重写<code>add</code>方法。<code>addAll</code>方法就是循环调用<code>add</code>方法实现的。</p>
</li>
<li><p><code>size</code>方法是抽象方法，子类必须重写。<code>isEmpty</code>方法的返回值就是检查<code>size</code>方法返回的是否是 0，<code>toArray</code>方法依赖<code>size</code>方法的返回值分配数组大小。</p>
</li>
<li><p><code>iterator</code>方法也是一个抽象方法，它返回一个实现了迭代器接口的对象。我们知道，迭代器定义了三个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p><code>AbstractCollection</code>中大部分方法都是依赖于迭代器对象进行操作的，例如<code>contains</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">if</span>(o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        	<span class="keyword">if</span>(it.next() == <span class="literal">null</span>)</span><br><span class="line">        		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">            <span class="keyword">if</span>(o.equals(it.next()))</span><br><span class="line">            	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了接口中的方法，<code>Collection</code>接口文档建议，每个<code>Collection</code>接口的实现类都应该提供至少两个标准构造：</p>
</li>
</ul>
<ol>
<li>默认的无参构造；</li>
<li>接受一个<code>Collection</code>类型参数的构造。</li>
</ol>
<h5 id="AbstractList"><a href="#AbstractList" class="headerlink" title="AbstractList"></a>AbstractList</h5><p><code>AbstractList</code>提供了<code>List</code>接口的基本实现，具体说就是实现了下面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span></span><br><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span></span><br><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> index)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span></span><br></pre></td></tr></table></figure>
<p>这些方法依赖于更基础的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span></span><br></pre></td></tr></table></figure>
<p><code>size</code>是抽象方法，子类必须实现，用来获取元素个数；<code>get</code>也是抽象方法，用来获取指定下标的元素；<code>set、add、remove</code>方法分别是在指定位置设置元素、在指定位置添加元素、删除指定位置元素，它们的默认实现都是抛<code>UnsupportedOperationException</code>异常。<br>和<code>AbstractCollection</code>不同，继承<code>AbstractList</code>不需要实现迭代器相关方法，因为<code>AbstractList</code>内部实现了两个迭代器，一个继承<code>Iterator</code>，一个继承<code>ListIterator</code>。这两个迭代器都是基于上面的基础方法实现的。</p>
<h5 id="AbstractSequentialList"><a href="#AbstractSequentialList" class="headerlink" title="AbstractSequentialList"></a>AbstractSequentialList</h5><p><code>AbstractSequentialList</code>是<code>AbstractList</code>的子类，同时也实现了<code>List</code>接口。具体实现了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span></span><br></pre></td></tr></table></figure>
<p>上面这些方法的实现依赖于下面的迭代器方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span></span><br></pre></td></tr></table></figure>
<p><code>listIterator</code>方法是一个抽象方法，子类必须实现。它返回的<code>ListIterator</code>能够根据下标进行增删改查，所以基于此能够实现上面列出的一系列方法。<br>注意，虽然<code>AbstractSequentialList</code>是<code>AbstractList</code>的子类，但两者的实现逻辑和用法是截然相反的。<br><code>AbstractList</code>需要子类重写根据索引操作的<code>get、set、add、remove</code>方法，然后它会根据这些基础的方法实现一个迭代器。它假定子类可以根据索引高效操作，适用于内部可以随机访问的存储结构，例如<code>ArrayList</code>就是继承于<code>AbstractList</code>。<br><code>AbstractSequentialList</code>要求子类重写迭代器方法，然后它根据迭代器实现增删改查。</p>
<h5 id="AbstractSet"><a href="#AbstractSet" class="headerlink" title="AbstractSet"></a>AbstractSet</h5><p><code>AbstractSet</code>提供了<code>Set</code>接口的基础实现，它继承自<code>AbstractCollection</code>，增加了<code>equals</code>和<code>hashCode</code>方法的默认实现。<code>Set</code>接口要求容器内不能包含重复元素，<code>AbstractSet</code>并没有实现该约束，子类需要自己实现。<br>扩展<code>AbstractSet</code>与<code>AbstractCollection</code>是类似的，只是需要实现无重复元素的约束，比如，<code>add</code>方法内需要检查元素是否已经添加过了。</p>
<h5 id="AbstractQueue"><a href="#AbstractQueue" class="headerlink" title="AbstractQueue"></a>AbstractQueue</h5><p><code>AbstractQueue</code>提供<code>Queue</code>接口的基本实现，它继承自<code>AbstractCollection</code>，实现了如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">element</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>这些方法的实现依赖于下面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">peek</span><span class="params">()</span>;</span><br><span class="line">E <span class="title function_">poll</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>;</span><br></pre></td></tr></table></figure>
<p>想要扩展<code>AbstractQueue</code>就需要实现这些方法。</p>
<h5 id="AbstractMap"><a href="#AbstractMap" class="headerlink" title="AbstractMap"></a>AbstractMap</h5><p><code>AbstractMap</code>提供了<code>Map</code>接口的基础实现，具体说就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>实现这些方法依赖于更基础的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Set&lt;Entry&lt;K,V&gt;&gt; <span class="title function_">entrySet</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p><code>putAll</code>就是循环调用<code>put</code>方法，<code>put</code>方法的默认实现是抛<code>UnsupportedOperationException</code>异常。其余方法都是基于<code>entrySet</code>方法实现的，<code>entrySet</code>方法是抽象方法，子类必须重写。<br>除了提供基础的方法，<code>AbstractMap</code>内部还定义了两个公有的静态内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AbstractMap.SimpleEntry <span class="keyword">implements</span> <span class="title class_">Entry</span>&lt;K,V&gt;</span><br><span class="line">AbstractMap.SimpleImmutableEntry <span class="keyword">implements</span> <span class="title class_">Entry</span>&lt;K,V&gt;</span><br></pre></td></tr></table></figure>
<p><code>SimpleImmutableEntry</code>表示只读的键值对，<code>SimpleEntry</code>表示可写的键值对。<br><code>Map</code>接口文档建议：每个<code>Map</code>接口的实现类都应该提供至少两个标准的构造方法，一个是默认的构造，另一个是接受一个<code>Map</code>类型参数的构造。</p>
<h4 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h4><p><code>Collections</code>类以静态方法的形式提供了很多通用的算法与功能，如查找、替换、排序等。</p>
<h5 id="查找与替换"><a href="#查找与替换" class="headerlink" title="查找与替换"></a>查找与替换</h5><h6 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h6><p>上面讲过<code>Arrays</code>类里面也有二分查找，不过那是基于数组的。<code>Collections</code>提供的二分查找是基于<code>List</code>接口的，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(</span></span><br><span class="line"><span class="params">    List&lt;? extends Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; list, T key)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(</span></span><br><span class="line"><span class="params">    List&lt;? extends T&gt; list, T key, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>第一个方法要求<code>List</code>里面的元素实现<code>Comparable</code>接口，而第二个方法因为需要传递一个<code>Comparator</code>所以不需要实现接口。<br>二分查找的实现基于升序排列的列表，即将待查找的元素<code>key</code>与列表中间元素比较：</p>
<ul>
<li>若<code>key</code>等于中间元素，就返回中间元素的下标</li>
<li>若<code>key</code>小于中间元素，就在列表前半段查找</li>
<li>若<code>key</code>大于中间元素，就在列表后半段查找</li>
</ul>
<p>如果列表本身是降序存放的，想要使用二分查找那么就需要传一个逆序的比较器进去。<code>Collections</code>提供了返回逆序比较器的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Comparator&lt;T&gt; <span class="title function_">reverseOrder</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Comparator&lt;T&gt; <span class="title function_">reverseOrder</span><span class="params">(Comparator&lt;T&gt; cmp)</span></span><br></pre></td></tr></table></figure>
<p>二分查找的思路非常简单，不多说。对于能随机访问元素的列表，采用的方式和数组一样；对于不能随机访问的列表，会使用迭代器找到中间元素。</p>
<h6 id="最大最小值"><a href="#最大最小值" class="headerlink" title="最大最小值"></a>最大最小值</h6><p><code>Collections</code>提供如下查找最大最小值的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span> &amp; Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; T <span class="title function_">max</span><span class="params">(</span></span><br><span class="line"><span class="params">    Collection&lt;? extends T&gt; coll)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">max</span><span class="params">(</span></span><br><span class="line"><span class="params">    Collection&lt;? extends T&gt; coll, Comparator&lt;? <span class="built_in">super</span> T&gt; comp)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span> &amp; Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; T <span class="title function_">min</span><span class="params">(</span></span><br><span class="line"><span class="params">    Collection&lt;? extends T&gt; coll)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">min</span><span class="params">(</span></span><br><span class="line"><span class="params">    Collection&lt;? extends T&gt; coll, Comparator&lt;? <span class="built_in">super</span> T&gt; comp)</span></span><br></pre></td></tr></table></figure>
<p>用法和实现思路都很简单，就是使用迭代器依次遍历。下面是<code>max</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span> &amp; Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; T <span class="title function_">max</span><span class="params">(</span></span><br><span class="line"><span class="params">  Collection&lt;? extends T&gt; coll)</span> &#123;</span><br><span class="line">    Iterator&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; i = coll.iterator();</span><br><span class="line">    <span class="type">T</span> <span class="variable">candidate</span> <span class="operator">=</span> i.next();</span><br><span class="line">    <span class="keyword">while</span>(i.hasNext()) &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">next</span> <span class="operator">=</span> i.next();</span><br><span class="line">        <span class="keyword">if</span>(next.compareTo(candidate) &gt; <span class="number">0</span>)</span><br><span class="line">        	candidate = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="次数统计"><a href="#次数统计" class="headerlink" title="次数统计"></a>次数统计</h6><p><code>Collections</code>还提供统计元素出现次数的功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">frequency</span><span class="params">(Collection&lt;?&gt; c, Object o)</span></span><br></pre></td></tr></table></figure>
<p>这个函数可以统计元素<code>o</code>在集合<code>c</code>中出现的次数，实现就是使用迭代器依次使用<code>equals</code>进行比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">frequency</span><span class="params">(Collection&lt;?&gt; c, Object o)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object e : c)</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">                result++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object e : c)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(e))</span><br><span class="line">                result++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="子列表查询"><a href="#子列表查询" class="headerlink" title="子列表查询"></a>子列表查询</h6><p><code>Collections</code>还提供子列表查询功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexOfSubList</span><span class="params">(List&lt;?&gt; source, List&lt;?&gt; target)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lastIndexOfSubList</span><span class="params">(List&lt;?&gt; source, List&lt;?&gt; target)</span></span><br></pre></td></tr></table></figure>
<p>这两个函数就是从<code>source</code>里面查找<code>target</code>，一个是从前往后找，一个是从后往前找。找到返回起始元素的下标，否则返回 -1。<br>方法的实现就是暴力破解，先从<code>source</code>下标为 0 的位置判断是否存在<code>target</code>，然后是下标 1，以此类推。</p>
<h6 id="集合交集"><a href="#集合交集" class="headerlink" title="集合交集"></a>集合交集</h6><p><code>Collections</code>还提供方法查看两个集合是否<strong>没有</strong>交集：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">disjoint</span><span class="params">(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2)</span></span><br></pre></td></tr></table></figure>
<p>若集合<code>c1</code>和<code>c2</code>没有交集返回<code>true</code>，有交集返回<code>false</code>。<br>实现原理也是暴力，遍历一个集合里的每一个元素，并对另一个集合使用<code>contains</code>判断该元素是否存在。不过存在一些优化，我们假设<code>iterate </code>表示要遍历的集合，<code>contains</code>表示查找的集合：</p>
<ul>
<li>默认情况下<code>iterate = c1, contains = c2</code></li>
<li>若两个集合中存在<code>Set</code>，那么这个<code>Set</code>必然作为<code>contains</code>存在</li>
<li>都不是<code>Set</code>，那么长度较短的作为外循环（<code>iterate</code>），较长的作为内循环（<code>contains</code>）</li>
</ul>
<h6 id="替换全部"><a href="#替换全部" class="headerlink" title="替换全部"></a>替换全部</h6><p><code>Collections</code>提供的替换全部功能函数原型如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">replaceAll</span><span class="params">(List&lt;T&gt; list, T oldVal, T newVal)</span></span><br></pre></td></tr></table></figure>
<p>函数能够将<code>list</code>里面所有的<code>oldVal</code>替换成<code>newVal</code>，使用<code>equals</code>方法判断两个对象是否相等。这个函数有返回值，发生了替换就返回<code>true</code>，否则返回<code>false</code>。</p>
<h5 id="排序和调整顺序"><a href="#排序和调整顺序" class="headerlink" title="排序和调整顺序"></a>排序和调整顺序</h5><h6 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h6><p><code>Arrays</code>实现了对数组的排序，<code>Collections</code>实现了对<code>List</code>的排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>直接传递列表的时候，要求列表里的元素实现<code>Comparable</code>接口；否则需要传递一个比较器。<br>排序的实现很简单，先将列表转成数组并排序，然后将数组值复制回原来的列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list)</span> &#123;</span><br><span class="line">    Object[] a = list.toArray();</span><br><span class="line">    Arrays.sort(a);</span><br><span class="line">    ListIterator&lt;T&gt; i = list.listIterator();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;a.length; j++) &#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.set((T)a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h6><p>交换列表里两个元素的位置也是我们常用的操作，<code>Collections</code>提供的接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(List&lt;?&gt; list, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br></pre></td></tr></table></figure>
<p>这个方法表示交换列表下标<code>i</code>和<code>j</code>的元素，实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(List&lt;?&gt; list, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">List</span> <span class="variable">l</span> <span class="operator">=</span> list;</span><br><span class="line">    l.set(i, l.set(j, l.get(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面主要使用<code>List</code>对象的<code>set</code>方法，这个方法在设置指定位置元素的时候会将原来的元素作为返回值。</p>
<h6 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h6><p><code>Collections</code>提供的翻转列表元素的方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(List&lt;?&gt; list)</span></span><br></pre></td></tr></table></figure>
<p>翻转元素的一般思路是首尾交换，但当列表很长且不能随机访问时按下标获取元素就很困难，因此这种情况下使用正向迭代器和反向迭代器进行交换元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="keyword">if</span>(size &lt; REVERSE_THRESHOLD || list <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, mid=size&gt;&gt;<span class="number">1</span>, j=size-<span class="number">1</span>; i&lt;mid; i++, j--)</span><br><span class="line">        	swap(list, i, j);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">ListIterator</span> <span class="variable">fwd</span> <span class="operator">=</span> list.listIterator();</span><br><span class="line">        <span class="type">ListIterator</span> <span class="variable">rev</span> <span class="operator">=</span> list.listIterator(size);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, mid=list.size()&gt;&gt;<span class="number">1</span>; i&lt;mid; i++) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">tmp</span> <span class="operator">=</span> fwd.next();</span><br><span class="line">            fwd.set(rev.previous());</span><br><span class="line">            rev.set(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="随机化重排"><a href="#随机化重排" class="headerlink" title="随机化重排"></a>随机化重排</h6><p>之前我们介绍过洗牌算法，<code>Collections</code>提供了对<code>List</code>的洗牌算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List&lt;?&gt; list)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List&lt;?&gt; list, Random rnd)</span></span><br></pre></td></tr></table></figure>
<p>思路和之前介绍的洗牌算法类似，从后往前遍历列表，将当前位置元素与前面随机一个位置的元素做交换。当列表长度较短或实现了随机访问的时候，使用上面的<code>swap</code>方法实现交换；否则就将列表内容复制到数组里面做重排，排完后再复制到列表里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List&lt;?&gt; list, Random rnd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="keyword">if</span>(size &lt; SHUFFLE_THRESHOLD || list <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=size; i&gt;<span class="number">1</span>; i--)</span><br><span class="line">        	swap(list, i-<span class="number">1</span>, rnd.nextInt(i));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object arr[] = list.toArray();</span><br><span class="line">        <span class="comment">// 对数组随机重排</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=size; i&gt;<span class="number">1</span>; i--)</span><br><span class="line">        	swap(arr, i-<span class="number">1</span>, rnd.nextInt(i));</span><br><span class="line">        <span class="comment">// 将数组元素复制到列表里</span></span><br><span class="line">        <span class="type">ListIterator</span> <span class="variable">it</span> <span class="operator">=</span> list.listIterator();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">            it.next();</span><br><span class="line">            it.set(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h6><p>循环移位就是列表所有元素往一个方向移动指定距离，越界的元素放到列表的另一端。循环移位分为循环左移和循环右移，下面看个例子：</p>
<ul>
<li><code>[8, 5, 3, 6, 2]</code>循环右移两位后变为<code>[6, 2, 8, 5, 3]</code></li>
<li><code>[8, 5, 3, 6, 2]</code>循环左移两位后变为<code>[3, 6, 2, 8, 5]</code></li>
</ul>
<p>循环移位的方法原型是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(List&lt;?&gt; list, <span class="type">int</span> distance)</span></span><br></pre></td></tr></table></figure>
<p><code>distance</code>是正数表示右移，负数表示左移。使用案例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; l1 = Arrays.asList(<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>);</span><br><span class="line">Collections.rotate(l1, <span class="number">2</span>);</span><br><span class="line">System.out.println(l1);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; l2 = Arrays.asList(<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>);</span><br><span class="line">Collections.rotate(l2, -<span class="number">2</span>);</span><br><span class="line">System.out.println(l2);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">6</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>这个方法的一个重要应用是“剪切”某一个子列表“粘贴”到一个其它位置，例如想将列表<code>[8, 5, 3, 6, 2]</code>里的子列表<code>[6, 2]</code>粘贴到元素 8 的后面即列表变成<code>[8, 6, 2, 5, 3]</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; l = Arrays.asList(<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>);</span><br><span class="line">Collections.rotate(l.subList(<span class="number">1</span>, l.size()), <span class="number">2</span>);</span><br><span class="line">System.out.println(l);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>注意代码里面<code>l.subList</code>方法返回的子列表是原来列表的一个视图，因此修改子列表实际上也会作用到原来的列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(List&lt;?&gt; list, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size() &lt; ROTATE_THRESHOLD)</span><br><span class="line">        rotate1(list, distance);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rotate2(list, distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是循环移位的实现，当列表支持随机访问或列表较短的时候将调用<code>rotate1</code>方法，否则调用<code>rotate2</code>方法实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">rotate1</span><span class="params">(List&lt;T&gt; list, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    distance = distance % size;</span><br><span class="line">    <span class="keyword">if</span> (distance &lt; <span class="number">0</span>)</span><br><span class="line">        distance += size;</span><br><span class="line">    <span class="keyword">if</span> (distance == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">cycleStart</span> <span class="operator">=</span> <span class="number">0</span>, nMoved = <span class="number">0</span>; nMoved != size; cycleStart++) &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">displaced</span> <span class="operator">=</span> list.get(cycleStart);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cycleStart;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i += distance;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                i -= size;</span><br><span class="line">            displaced = list.set(i, displaced);</span><br><span class="line">            nMoved ++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i != cycleStart);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>rotate1</code>方法主体思路没啥问题，就是一圈一圈把每个元素放对位置。上面有一些对移动距离<code>distance</code>的处理，<code>distance</code>是正数没什么特别，当<code>distance</code>是负数的时候：</p>
<ul>
<li>我们知道向左循环移<code>k</code>位等价于向右循环移<code>size - k</code>位</li>
<li><code>distance = distance % size</code>可以计算出实际需要移动的位数，计算前后<code>distance</code>符号保持不变，因为取余结果的符号与分子一致。</li>
<li>当<code>distance &lt; 0</code>时表示向左移动<code>|distance|</code>位，此时使用<code>distance += size</code>计算出等价的向右移动的位数</li>
</ul>
<p>所以代码里对<code>distance</code>的操作是为了统一成向右移动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rotate2</span><span class="params">(List&lt;?&gt; list, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> -distance % size;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; <span class="number">0</span>)</span><br><span class="line">        mid += size;</span><br><span class="line">    <span class="keyword">if</span> (mid == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    reverse(list.subList(<span class="number">0</span>, mid));</span><br><span class="line">    reverse(list.subList(mid, size));</span><br><span class="line">    reverse(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们分析一下<code>rotate2</code>的实现，实际上循环移位可以看成两个子列表的交换。<br>假设我们想对一个列表<code>L</code>循环左移<code>m</code>位，不妨设$L&#x3D;[A_mB_n]&#x3D;[a_1a_2…a_mb_1b_2…b_n]$，显然移位后的结果应该是$[B_nA_m]&#x3D;[b_1b_2…b_na_1a_2…a_m]$。可以发现实际上就是交换子列表<code>A</code>与<code>B</code>，我们可以使用下面的步骤优雅的交换两者：</p>
<ol>
<li>翻转子列表<code>A</code>，$L&#x3D;[a_1a_2…a_mb_1b_2…b_n]\rightarrow[a_m…a_2a_1b_1b_2…b_n]$</li>
<li>翻转子列表<code>B</code>，$[a_m…a_2a_1b_1b_2…b_n]\rightarrow[a_m…a_2a_1b_n…b_2b_1]$</li>
<li>翻转整个列表，$[a_m…a_2a_1b_n…b_2b_1]\rightarrow[b_1b_2…b_na_1a_2…a_m]$</li>
</ol>
<p>了解了这些，不难看出代码就是实现我们说的步骤。代码前半段计算的<code>mid</code>就是两个子列表的分割点。</p>
<h5 id="添加和修改"><a href="#添加和修改" class="headerlink" title="添加和修改"></a>添加和修改</h5><h6 id="批量添加"><a href="#批量添加" class="headerlink" title="批量添加"></a>批量添加</h6><p><code>Collections</code>提供的批量添加元素的方法原型为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? <span class="built_in">super</span> T&gt; c, T... elements)</span></span><br></pre></td></tr></table></figure>
<p>这边主要使用可变长参数来简化代码，代码内部也只是简单的循环调用容器的<code>add</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>&#125;;</span><br><span class="line">Collections.addAll(list, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">Collections.addAll(list, arr);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[C, D, A, B]</span><br></pre></td></tr></table></figure>
<p>注意可变长参数本质上就是数组，所以可以直接传一个数组进去。</p>
<h6 id="批量填充"><a href="#批量填充" class="headerlink" title="批量填充"></a>批量填充</h6><p><code>Collections</code>提供的批量填充元素的方法原型为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; list, T obj)</span></span><br></pre></td></tr></table></figure>
<p>这个方法能将列表所有元素都填充成<code>obj</code>，它内部使用循环将每个值都替换成<code>obj</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; list, T obj)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="keyword">if</span> (size &lt; FILL_THRESHOLD || list <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">            list.set(i, obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ListIterator&lt;? <span class="built_in">super</span> T&gt; itr = list.listIterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            itr.next();</span><br><span class="line">            itr.set(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="批量复制"><a href="#批量复制" class="headerlink" title="批量复制"></a>批量复制</h6><p><code>Collections</code>提供的方法能将<code>src</code>里面所有元素复制到<code>dest</code>的开头，原来的元素会被覆盖，多余的元素不受影响。注意，复制之前需要保证<code>dest</code>的容量足够大，否则会抛异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">srcSize</span> <span class="operator">=</span> src.size();</span><br><span class="line">    <span class="keyword">if</span> (srcSize &gt; dest.size())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Source does not fit in dest&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (srcSize &lt; COPY_THRESHOLD ||</span><br><span class="line">        (src <span class="keyword">instanceof</span> RandomAccess &amp;&amp; dest <span class="keyword">instanceof</span> RandomAccess)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;srcSize; i++)</span><br><span class="line">            dest.set(i, src.get(i));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ListIterator&lt;? <span class="built_in">super</span> T&gt; di=dest.listIterator();</span><br><span class="line">        ListIterator&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; si=src.listIterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;srcSize; i++) &#123;</span><br><span class="line">            di.next();</span><br><span class="line">            di.set(si.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h5><p>适配器的作用是将一种接口转换成另一种接口，<code>Collections</code>提供以下几种适配器：</p>
<ul>
<li>空容器方法，将“空”转换成标准的容器接口对象。</li>
<li>单一对象方法，将一个单独的对象转换成标准的容器接口对象。</li>
<li>其它适配方法，例如将<code>Map</code>转换成<code>Set</code>等。</li>
</ul>
<h6 id="空容器方法"><a href="#空容器方法" class="headerlink" title="空容器方法"></a>空容器方法</h6><p><code>Collections</code>提供下面几个方法返回不包含任何元素的容器对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">emptyList</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;T&gt; Set&lt;T&gt; <span class="title function_">emptySet</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title function_">emptyMap</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Iterator&lt;T&gt; <span class="title function_">emptyIterator</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>这些方法见名知义，什么情况下会用到这些方法呢？<br>假设需要一个查询方法，这个方法需要返回数据的集合，当我们什么都没有查到的时候应该返回什么呢？有两种思路，一种返回<code>null</code>，一种是返回空集合。返回<code>null</code>的时候调用方需要做额外的检查，返回空集合可以和有数据时的处理情况统一起来。<br>如果自定义的方法需要返回一个<code>List</code>，没有数据的时候：</p>
<ul>
<li>可以返回<code>Collections.emptyList()</code></li>
<li>也可以返回<code>new ArrayList&lt;&gt;()</code>。</li>
</ul>
<p>两者的区别是什么？我们先看看<code>Collections.emptyList()</code>是什么？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">List</span> <span class="variable">EMPTY_LIST</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmptyList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">emptyList</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (List&lt;T&gt;) EMPTY_LIST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EmptyList</span>&lt;E&gt; </span><br><span class="line">  <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;<span class="keyword">implements</span> <span class="title class_">RandomAccess</span> &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> emptyIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> emptyListIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object obj)</span> &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123; <span class="keyword">return</span> c.isEmpty(); &#125;</span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]; &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.length &gt; <span class="number">0</span>)</span><br><span class="line">        	a[<span class="number">0</span>] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> (o <span class="keyword">instanceof</span> List) &amp;&amp; ((List&lt;?&gt;)o).isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>emptyList()</code>返回的是一个固定的列表对象，对象里面的<code>iterator</code>和<code>listIterator</code>方法返回也都是空的迭代器，<code>emptyIterator()</code>的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Iterator&lt;T&gt; <span class="title function_">emptyIterator</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (Iterator&lt;T&gt;) EmptyIterator.EMPTY_ITERATOR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EmptyIterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> EmptyIterator&lt;Object&gt; EMPTY_ITERATOR = <span class="keyword">new</span> <span class="title class_">EmptyIterator</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是<code>EmptyList</code>不支持修改操作，例如添加元素的时候会抛异常<code>UnsupportedOperationException</code>，因此只能用来读不能写。<br>总结下来，如果返回的集合只会用来读，建议返回<code>Collections.emptyList()</code>节省内存；如果需要修改，那么就返回<code>new ArrayList&lt;&gt;()</code>。<br>在 Java9 以后，我们可以使用<code>List、Set、Map</code>不带参数的<code>of</code>方法返回一个只读的空容器对象。也就是说下面的代码是等价的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Collections.emptyList();</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> List.of();</span><br></pre></td></tr></table></figure>
<h6 id="单一对象方法"><a href="#单一对象方法" class="headerlink" title="单一对象方法"></a>单一对象方法</h6><p><code>Conllections</code>里面还有一组方法可以将单一对象转换成一个标准的容器对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="title function_">singleton</span><span class="params">(T o)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">singletonList</span><span class="params">(T o)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title function_">singletonMap</span><span class="params">(K key, V value)</span></span><br></pre></td></tr></table></figure>
<p>例如可以像下面这样使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = Collections.singleton(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">List&lt;String&gt; list = Collections.singletonList(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">Map&lt;String, String&gt; map = Collections.singletonMap(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>当我们需要将一个对象转换成容器的时候，我们当然可以自己新建一个容器并将唯一的元素添加进去。很显然，使用人家封装好的更优雅，何况人家还做了优化。我们看看<code>Collections.singleton</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="title function_">singleton</span><span class="params">(T o)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SingletonSet</span>&lt;&gt;(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> E element;</span><br><span class="line">    SingletonSet(E e) &#123;element = e;&#125;</span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> singletonIterator(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;<span class="keyword">return</span> eq(o, element);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// eq 就是考虑到 null 的 equals</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">eq</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> o1==<span class="literal">null</span> ? o2==<span class="literal">null</span> : o1.equals(o2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; Iterator&lt;E&gt; <span class="title function_">singletonIterator</span><span class="params">(<span class="keyword">final</span> E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;E&gt;() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">hasNext</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        	<span class="keyword">return</span> hasNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(hasNext) &#123;</span><br><span class="line">            	hasNext = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意<code>singleton</code>方法返回的也是可读不可写的对象，写入时会抛异常<code>UnsupportedOperationException</code>。其它的<code>singletonXXX</code>也是一样的实现思路，返回的都是可读不可写的对象。<br>一个常见的应用场景就是从容器里面删除所有指定元素，<code>Collection</code>对象都有下面两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br></pre></td></tr></table></figure>
<p><code>remove(Object o)</code>方法只会删除容器里找到的第一个元素，<code>removeAll(Collection&lt;?&gt; c)</code>会将容器里所有存在于<code>c</code>中的元素删除。很显然，我想删除所有指定的元素只能使用<code>removeAll</code>方法，不过需要传进去只包含一个元素的<code>Collection</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(list, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">list.removeAll(Collections.singleton(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a, c, d]</span><br></pre></td></tr></table></figure>
<p>一样的，可以在 Java9 之后使用<code>List、Set、map</code>的<code>of</code>方法达到类似<code>singleton</code>的效果，下面两种写法等价：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; b = Collections.singleton(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">Set&lt;String&gt; b = Set.of(<span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure>
<h5 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h5><p>所谓装饰器就在传进去一个对象，返回一个同类型的对象，但返回的对象经过了加强或做了一些限制。<code>Collections</code>提供了三组装饰器，这三组装饰器不会给对象添加功能，但能让对象更安全。所谓的安全分别是写安全、类型安全和线程安全。</p>
<h6 id="写安全"><a href="#写安全" class="headerlink" title="写安全"></a>写安全</h6><p>写安全的方法主要有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">unmodifiableCollection</span><span class="params">(Collection&lt;? extends T&gt; c)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">unmodifiableList</span><span class="params">(List&lt;? extends T&gt; list)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title function_">unmodifiableMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="title function_">unmodifiableSet</span><span class="params">(Set&lt;? extends T&gt; s)</span></span><br></pre></td></tr></table></figure>
<p>这些方法见名知义，能够将对应类型的容器变为只读，写的时候会抛异常<code>UnsupportedOperationException</code>。<br>这些方法的实现其实也非常简单，就是返回一个受限制的对象，以<code>unmodifiableCollection</code>为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">unmodifiableCollection</span><span class="params">(</span></span><br><span class="line"><span class="params">  Collection&lt;? extends T&gt; c)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UnmodifiableCollection</span>&lt;&gt;(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UnmodifiableCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Collection</span>&lt;E&gt;,Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1820017752578914078L</span>;</span><br><span class="line">    <span class="keyword">final</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; c;</span><br><span class="line">    UnmodifiableCollection(Collection&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; c) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;<span class="keyword">return</span> c.size();&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;<span class="keyword">return</span> c.isEmpty();&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;<span class="keyword">return</span> c.contains(o);&#125;</span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;<span class="keyword">return</span> c.toArray();&#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;<span class="keyword">return</span> c.toArray(a);&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;<span class="keyword">return</span> c.toString();&#125;</span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;E&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Iterator&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; i = c.iterator();</span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;<span class="keyword">return</span> i.hasNext();&#125;</span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;<span class="keyword">return</span> i.next();&#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; coll)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> c.containsAll(coll);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; coll)</span> &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; coll)</span> &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; coll)</span> &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它<code>unmodifiableXXX</code>也是类似的实现。</p>
<h6 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h6><p>类型安全就是保证容器不会保存错误类型的对象，为什么会出现错误类型的对象？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hello]</span><br></pre></td></tr></table></figure>
<p>主要 Java 使用类型擦除来实现泛型，我们正常会添加上泛型参数来使用泛型机制避免添加错误类型对象。但泛型是 Java5 之后引进的，以前的代码没有泛型所以会出现问题。我们可以使用下面一组装饰方法来生成类型安全的容器对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">checkedList</span><span class="params">(List&lt;E&gt; list, Class&lt;E&gt; type)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; Map&lt;K, V&gt; <span class="title function_">checkedMap</span><span class="params">(Map&lt;K, V&gt; m,</span></span><br><span class="line"><span class="params">                                          Class&lt;K&gt; keyType, Class&lt;V&gt; valueType)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title function_">checkedSet</span><span class="params">(Set&lt;E&gt; s, Class&lt;E&gt; type)</span></span><br></pre></td></tr></table></figure>
<p>装饰完的对象，插入或修改元素的时候若类型不匹配会抛异常<code>ClassCastException</code>，看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">list = Collections.checkedList(list, Integer.class);</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>下面看看<code>checkedCollection</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Collection&lt;E&gt; <span class="title function_">checkedCollection</span><span class="params">(</span></span><br><span class="line"><span class="params">  Collection&lt;E&gt; c, Class&lt;E&gt; type)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CheckedCollection</span>&lt;&gt;(c, type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CheckedCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Collection</span>&lt;E&gt;, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1578914078182001775L</span>;</span><br><span class="line">    <span class="keyword">final</span> Collection&lt;E&gt; c;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;E&gt; type;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">typeCheck</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o != <span class="literal">null</span> &amp;&amp; !type.isInstance(o))</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassCastException</span>(badElementMsg(o));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">badElementMsg</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Attempt to insert &quot;</span> + o.getClass() +</span><br><span class="line">        <span class="string">&quot; element into collection with element type &quot;</span> + type;</span><br><span class="line">    &#125;</span><br><span class="line">    CheckedCollection(Collection&lt;E&gt; c, Class&lt;E&gt; type) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="literal">null</span> || type == <span class="literal">null</span>)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123; <span class="keyword">return</span> c.size(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123; <span class="keyword">return</span> c.isEmpty(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123; <span class="keyword">return</span> c.contains(o); &#125;</span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123; <span class="keyword">return</span> c.toArray(); &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123; <span class="keyword">return</span> c.toArray(a); &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> c.toString(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123; <span class="keyword">return</span> c.remove(o); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123; c.clear(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; coll)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> c.containsAll(coll);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; coll)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> c.removeAll(coll);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; coll)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> c.retainAll(coll);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;E&gt; it = c.iterator();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;E&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123; <span class="keyword">return</span> it.hasNext(); &#125;</span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">return</span> it.next(); &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123; it.remove(); &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        typeCheck(e);</span><br><span class="line">        <span class="keyword">return</span> c.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它<code>checkedXXX</code>都是一样的原理。</p>
<h6 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h6><p><code>Collections</code>提供了一组装饰方法，可以将容器对象变成线程安全的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">synchronizedCollection</span><span class="params">(Collection&lt;T&gt; c)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title function_">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="title function_">synchronizedSet</span><span class="params">(Set&lt;T&gt; s)</span></span><br></pre></td></tr></table></figure>
<p>之前介绍的容器对象基本都不是线程安全的，所以存在并发访问的时候可能出现问题。使用上面的装饰方法，会将所有容器方法加锁保证线程安全。但这种方法不是最优的，Java 提供了很多针对并发访问的容器类将在后面进行介绍。</p>
<h4 id="容器类总结"><a href="#容器类总结" class="headerlink" title="容器类总结"></a>容器类总结</h4><p>容器类有两个根接口，分别是<code>Collection</code>和<code>Map</code>，<code>Collection</code>表示单个元素的集合，<code>Map</code>表示键值对的集合。<br><code>Collection</code>表示的数据集合有基本的增、删、查、遍历等方法，但没有定义元素间的顺序或位置，也没有规定是否有重复元素。<br><code>List</code>是<code>Collection</code>的子接口，表示有顺序或位置的数据集合，增加了根据索引位置进行操作的方法。它有两个主要的实现类：<code>ArrayList</code>和<code>LinkedList</code>。<code>ArrayList</code>基于数组实现，<code>LinkedList</code>基于链表实现；<code>ArrayList</code>的随机访问效率很高，但从中间插入和删除元素需要移动元素，效率比较低，<code>LinkedList</code>则正好相反，随机访问效率比较低，但增删元素只需要调整邻近节点的链接。<br><code>Set</code>也是<code>Collection</code>的子接口，它没有增加新的方法，但保证不含重复元素。它有两个主要的实现类<code>HashSet</code>和<code>TreeSet</code>。<code>HashSet</code>基于哈希表实现，要求键重写<code>hashCode</code>方法，效率更高，但元素间没有顺序；<code>TreeSet</code>基于排序二叉树实现，元素按比较有序，元素需要实现<code>Comparable</code>接口，或者创建<code>TreeSet</code>时提供一个<code>Comparator</code>对象。<code>HashSet</code>还有一个子类<code>LinkedHashSet</code>可以按插入有序。还有一个针对枚举类型的实现类<code>EnumSet</code>，它基于位向量实现，效率很高。<br><code>Queue</code>是<code>Collection</code>的子接口，表示先进先出的队列，在尾部添加，从头部查看或删除。<code>Deque</code>是<code>Queue</code>的子接口，表示更为通用的双端队列，有明确的在头或尾进行香看、添加和删除的方法。普通队列有两个主要的实现类：<code>LinkedList</code>和<code>ArrayDeque</code>。<code>LinkedList</code>基于链表实现，<code>ArrayDeque</code>基于循环数组实现。一般而言，如果只需要<code>Deque</code>接口，<code>ArrayDeque</code>的效率更高一些。<br><code>Queue</code>还有一个特殊的实现类<code>PriorityQueue</code>，表示优先级队列，内部是用堆实现的。堆除了用于实现优先级队列，还可以高效方便地解决很多其他问题，比如求前 K 个最大的元素、求中值等。<br><code>Map</code>接口表示键值对集合，经常根据键进行操作，它有两个主要的实现类:<code>HashMap</code>和<code>TreeMap</code>。<code>HashMap</code>基于哈希表实现，要求键重写<code>hashCode</code>方法，操作效率很高，但元素没有顺序。<code>TreeMap</code>基于排序二叉树实现，要求键实现<code>Comparable</code>接口，或提供一个<code>Comparator</code>对象，操作效率稍低，但可以按键有序。<br><code>HashMap</code>还有一个子类<code>LinkedHashMap</code>，它可以按插入或访问有序。之所以能有序，是因为每个元素还加入到了一个双向链表中。如果键本来就是有序的，使用<code>LinkedHashMap</code>而非<code>TreeMap</code>可以提高效率。按访问有序的特点可以方便地用于实现<code>LRU</code>缓存。<br>如果键为枚举类型，可以使用专门的实现类<code>EnumMap</code>，它使用效率更高的数组实现。<br>需要说明的是，除了<code>Hashtable</code>、<code>Vector</code>和<code>Stack</code>，我们介绍的各种容器类都不是线程安全的，也就是说，如果多个线程同时读写同一个容器对象，是不安全的。如果需要线程安全，可以使用<code>Collections</code>提供的<code>synchronizedXXX</code>方法对容器对象进行同步，或者使用线程安全的专门容器类。<br>此外，容器类提供的迭代器都有一个特点，都会在迭代中间进行结构性变化检测，如果容器发生了结构性变化，就会抛出<code>ConcurrentModificationException</code>，所以不能在迭代中间直接调用容器类提供的<code>add/remove</code>方法，如需添加和删除，应调用迭代器的相关方法。<br>在解决一个特定问题时，经常需要综合使用多种容器类。比如，要统计一本书中出现次数最多的前 10 个单词，可以先使用<code>HashMap</code>统计每个单词出现的次数，再使用前面实现的<code>TopK</code>类用<code>PriorityQueue</code>求前 10 个单词或者使用<code>Collections</code>提供的<code>sort</code>方法。<br>在之前各节介绍的例子中，为简单起见，容器中的元素类型往往是简单的，但需要说明的是，它们也可以是复杂的自定义类型，还可以是容器类型。比如在一个新闻应用中，表示当天的前十大新闻可以用一个<code>List</code>表示，形如<code>List&lt;News&gt;</code>；而为了表示每个分类的前十大新闻，可以用一个<code>Map</code>表示、键为分类<code>Category</code>，值为<code>List&lt;News&gt;</code>，形如<code>Map&lt;Category，List&lt;News&gt;&gt;</code>；表示每天的每个分类的前十大新闻可以在<code>Map</code>中使用<code>Map</code>，键为日期，值也是一个<code>Map</code>，形如<code>Map&lt;Date, Map&lt;Category,List&lt;News&gt;&gt;</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/20/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8805%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/20/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8805%EF%BC%89/" itemprop="url">Java 基础系列（05）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-20T12:04:00+08:00">
                2023-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Map-Set"><a href="#Map-Set" class="headerlink" title="Map &amp; Set"></a>Map &amp; Set</h3><h4 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h4><p><code>Map</code>维护的是键到值的映射关系，键是不能重复的，但值可以。访问的时候给定一个键，返回这个键对应的值。给同一个键重复设值，新值会覆盖旧值。接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K,V&gt; &#123;  <span class="comment">// K、V 是类型参数，分别表示键和值的类型</span></span><br><span class="line">    V <span class="title function_">put</span><span class="params">(K key, V value)</span>;  <span class="comment">// 保存键值对，若 key 不存在返回 null，存在就返回旧值</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(Object key)</span>;  <span class="comment">// 根据键获取值，找不到返回 null</span></span><br><span class="line">    V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span>;  <span class="comment">// 同上，但找不到返回 defaultValue</span></span><br><span class="line">    V <span class="title function_">remove</span><span class="params">(Object key)</span>;  <span class="comment">// 根据键删除键值对，返回对应的值，若键不存在返回 null</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;  <span class="comment">// 返回键值对的数量</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;  <span class="comment">// 返回 Map 是否为空</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span>;  <span class="comment">// 返回是否包含某个键</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span>;  <span class="comment">// 返回是否包含某个值</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span>;<span class="comment">// 将 m 中所有键值对保存到当前 Map</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;  <span class="comment">// 清空所有键值对</span></span><br><span class="line">    Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>;  <span class="comment">//឴ 返回 Map 中所有键的集合</span></span><br><span class="line">    Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span>;  <span class="comment">//឴ 获取 Map 中所有值的集合</span></span><br><span class="line">    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();  <span class="comment">//឴ 获取 Map 中所有键值对的集合</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Entry</span>&lt;K,V&gt; &#123;  <span class="comment">// 内部接口，表示键值对</span></span><br><span class="line">        K <span class="title function_">getKey</span><span class="params">()</span>;</span><br><span class="line">        V <span class="title function_">getValue</span><span class="params">()</span>;</span><br><span class="line">        V <span class="title function_">setValue</span><span class="params">(V value)</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Set</code>是一个表示数学中集合概念的接口，即元素不重复：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Set</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 迭代遍历的时候不要求元素有特别的顺序</span></span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素。元素存在时直接返回 false，不存在时才会添加进去并返回 true</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个集合里的所有元素，重复元素不添加。返回当前集合是否有变化</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它扩展了<code>Collection</code>接口但没有定义新方法，它要求所有的实现者必须满足其语义约束，即不能有重复的元素。<br><code>Map</code>中的<code>keySet</code>方法因为所有键是不重复的，所以会返回一个<code>Set</code>。<code>keySet、values、entrySet</code>返回的都是视图，不是复制的值，基于返回值的修改都会作用到<code>Map</code>自身：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.values().clear();</span><br><span class="line">map.keySet().clear();</span><br><span class="line">map.entrySet().clear();</span><br></pre></td></tr></table></figure>
<p>上面的三种写法都会清空掉<code>Map</code>。</p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><p><code>HashMap</code>实现了<code>Map</code>接口。我们看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> rnd.nextInt(<span class="number">4</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.getOrDefault(n, <span class="number">0</span>);</span><br><span class="line">    map.put(n, count + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; kv : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(kv.getKey() + <span class="string">&quot;: &quot;</span> + kv.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子想要检验随机数类生成的随机数是否均匀，里面的用法也很简单，其一次输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: <span class="number">265</span></span><br><span class="line"><span class="number">1</span>: <span class="number">244</span></span><br><span class="line"><span class="number">2</span>: <span class="number">248</span></span><br><span class="line"><span class="number">3</span>: <span class="number">243</span></span><br></pre></td></tr></table></figure>
<p>除了默认的构造方法，<code>HashMap</code>还有如下的几种构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span><br></pre></td></tr></table></figure>
<p><code>initialCapacity</code>和<code>loadFactor</code>是什么含义后面看。最后一个构造会将<code>m</code>的键值对添加到当前的<code>Map</code>中。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><h6 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h6><p><code>HashMap</code>有如下几个主要的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>size</code>表示键值对的数目；</p>
</li>
<li><p><code>table</code>是一个<code>Entry</code>类型的数组，称为哈希表或哈希桶，数组里面的每一个元素都指向一个单链表。<code>Entry</code>是一个内部类，它的实例变量和构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="type">int</span> hash;</span><br><span class="line">    Entry(<span class="type">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出这是一个单链表的节点，<code>key</code>和<code>value</code>分别表示键与值，<code>next</code>指向下一个节点，<code>hash</code>存储<code>key</code>的哈希值，之所以存储哈希值是为了加快比较速度。<br><code>table</code>的初值是<code>EMPTY_TABLE</code>，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>随着往<code>Map</code>里面添加元素，<code>table</code>的容量会扩展，每次扩展双倍。具体扩展的时机与<code>threshold</code>相关。</p>
</li>
<li><p><code>threshold</code>表示阈值，当<code>size ≥ threshold</code>时考虑扩展空间。一般来讲，<code>threshold = table.length * loadFactor</code>。</p>
</li>
<li><p><code>loadFactor</code>是负载因子，指示<code>table</code>被占用的程度，默认值是 0.75，可以通过构造修改。</p>
</li>
</ul>
<h6 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h6><p><code>HashMap</code>的默认构造是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DEFAULT_INITIAL_CAPACITY</code>默认是 16，<code>DEFAULT_LOAD_FACTOR</code>默认是 0.75。它调用的构造是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要就是设置<code>loadFactor</code>和<code>threshold</code>的初值。</p>
<h6 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(table == EMPTY_TABLE) &#123;</span><br><span class="line">    	inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(key == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span>(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次添加元素的时候调用<code>inflateTable</code>给<code>table</code>分配空间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inflateTable</span><span class="params">(<span class="type">int</span> toSize)</span> &#123;</span><br><span class="line">    <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> roundUpToPowerOf2(toSize);</span><br><span class="line">    threshold = (<span class="type">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码写的很清楚，默认情况下会分配一个长度 16 的数组，此时<code>threshold</code>是 12。<br>下面调用<code>hash</code>方法计算<code>key</code>的哈希值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数使用对象本身的<code>hashCode</code>再做一些位运算，增加随机和均匀性。<br>下面调用<code>indexFor</code>方法计算指定哈希值应该放在数组哪一个下标：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> h &amp; (length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>HashMap</code>中，数组的长度是 2 的次幂，所以<code>h &amp; (length - 1)</code>等价于<code>h % (length - 1)</code>。我们知道<code>table[i]</code>指向一个单链表，下面就是从单链表里面寻找这个键，如果这个键存在就执行修改操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">    Object k;</span><br><span class="line">    <span class="comment">// hash 相同并且键相同就是存在这个键</span></span><br><span class="line">    <span class="keyword">if</span>(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">        e.value = value;</span><br><span class="line">        e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实只比较键就可以了，先比较哈希是为了提高效率。因为哈希不同后面的键比较就不需要了，而哈希是整型比较起来会很快。<br>如果键不存在就使用<code>addEntry</code>插入一条，<code>modCount</code>也是用来记录结构性变化次数的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 将键值对封装成 Entry 并插入到对应位置链表的头部</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>addEntry</code>里面，如果容量足够就直接插入元素，插入的时候是插入到链表头部。如果容量不够，就使用<code>resize</code>分配两倍空间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span>(rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>resize</code>分配好空间之后，使用<code>transfer</code>方法转移所有键值对并更新<code>threshold</code>的值。</p>
<h6 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h6><p>根据键获取值的<code>get</code>方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(key == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span> == entry ? <span class="literal">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">      e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span>(e.hash == hash </span><br><span class="line">          &amp;&amp; ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        	<span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要流程就是根据键的哈希值找到对应单链表的头结点，然后依次往下比较，找到直接返回，找不到返回<code>null</code>。<br><code>containsKey</code>的查找流程和<code>get</code>有些像：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> getEntry(key) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HashMap</code>可以高效的操作键，但对于值需要挨个查找。<code>containsValue</code>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(value == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> containsNullValue();</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length ; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i] ; e != <span class="literal">null</span> ; e = e.next)</span><br><span class="line">            <span class="keyword">if</span>(value.equals(e.value))</span><br><span class="line">            	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑很简单就是从前到后遍历每一个链表里的每一个节点，看看值是否存在。</p>
<h6 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = removeEntryForKey(key);</span><br><span class="line">    <span class="keyword">return</span> (e == <span class="literal">null</span> ? <span class="literal">null</span> : e.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">removeEntryForKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line">    <span class="keyword">while</span>(e != <span class="literal">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span>(e.hash == hash &amp;&amp;</span><br><span class="line">          ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span>(prev == e)</span><br><span class="line">            	table[i] = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            	prev.next = next;</span><br><span class="line">            e.recordRemoval(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e;</span><br><span class="line">        e = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑很简单，根据键找到<code>table[i]</code>，然后顺着链表找到要删除的节点进行删除。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>查找时会先比较哈希值然后再使用<code>equals</code>方法进行比较，即如果两个对象哈希值不一样那么就认为它们不一样。这也就解释了前面说的，<code>hashCode</code>和<code>equals</code>必须一起重写且<code>equals</code>返回<code>true</code>那么<code>hashCode</code>必须返回一样的值，反之不一定。<br>在 Java8 里面，对<code>HashMap</code>进行了优化，当哈希桶里面某个链表过长时会将其转换成平衡的排序二叉树。<br>值得注意，<code>**HashMap**</code><strong>线程不安全</strong>。还有一个实现和<code>HashMap</code>基本相同的线程安全的类<code>HashTable</code>，这个类是使用<code>synchronized</code>关键字实现的线程安全。<code>HashMap</code>的键或值都可以是<code>null</code>，但<code>HashTable</code>不可以。在不需要并发的场景下推荐使用<code>HashMap</code>，高并发下推荐使用后面将会介绍的<code>ConcurrentHashMap</code>。</p>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p><code>HashSet</code>的构造有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>这里<code>initialCapacity</code>和<code>loadFactor</code>的含义与<code>HashMap</code>一致。<br><code>HashSet</code>的使用也很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">set.add(<span class="string">&quot;卢研&quot;</span>);</span><br><span class="line">set.addAll(Arrays.asList(<span class="string">&quot;卢研&quot;</span>, <span class="string">&quot;刘妙霞&quot;</span>));</span><br><span class="line"><span class="keyword">for</span> (String name : set) &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边“卢研”并不会被添加两次，输出的顺序并不是按照添加的顺序的来的。和<code>HashMap</code>类似，<code>HashSet</code>要求元素重写<code>hashCode</code>和<code>equals</code>方法，<code>equals</code>返回<code>true</code>时<code>hashCode</code>必须相同，反之不要求。尤其对于自定义类一定要注意这点，因为<code>equals</code>方法比较的是两个对象的地址。<br><code>HashSet</code>内部使用<code>HashMap</code>实现，它内部有一个<code>HashMap</code>的实例变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br></pre></td></tr></table></figure>
<p>我们知道<code>HashMap</code>有键和值，但<code>HashSet</code>只有键，所以存的时候所有键的值都是一样的，这个值定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>
<p>下面<code>HashSet</code>的构造，主要就是初始化<code>HashMap</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">	map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据 c 的容量计算 HashMap 的初始容量，最少为 16，默认的负载因子是 0.75</span></span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(Math.max((<span class="type">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面看看一些常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素，调用 map.put 的返回值为 null 说明这个键没出现过，因为添加的时候值一定不为 null</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> map.put(e, PRESENT) == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若存在对应的键，其值一定是 PRESENT</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> map.remove(o) == PRESENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HashSet</code>可以高效的实现去重、集合运算等。但其内元素是无序的，若要保持添加的先后顺序可以使用<code>HashSet</code>子类<code>LinkedHashSet</code>。除此之外还有一个重要的<code>Set</code>的实现类<code>TreeSet</code>支持排序。</p>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>前面我们提到过<code>HashMap</code>有一个局限，键值对之间没有特定顺序。<code>TreeMap</code>内部使用排序二叉树，使得键值对之间有序（升序或降序而不是添加的顺序）。<br>排序二叉树就是对树里的任意一棵子树来说，左子树的所有节点值都小于根节点，右子树所有节点值都大于根节点。</p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p><code>TreeMap</code>有两个基本构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span></span><br></pre></td></tr></table></figure>
<p>第一个是无参构造要求<code>Map</code>里的键必须实现<code>Comparable</code>接口，后面会将<code>Comparable.compareTo</code>作为键之间排序的依据。<br>第二个构造接受一个<code>Comparator</code>，这样就不要求键去实现<code>Comparable</code>接口，比较的时候会调用<code>comparator.compare</code>方法。<br>需要强调的是，<code>TreeMap</code>是按键有序，和值无关，和插入顺序也无关。下面是简单的案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;abs&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;come&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;T&quot;</span>, <span class="string">&quot;To&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; kv : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(kv.getKey() + <span class="string">&quot;-&gt;&quot;</span> + kv.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T-&gt;To</span><br><span class="line">a-&gt;abs</span><br><span class="line">c-&gt;come</span><br></pre></td></tr></table></figure>
<p>可以看出，我们默认是从小到大按键进行排序，<code>String</code>类实现的<code>Comparable</code>接口是依次比较字符。如果我们想忽略大小写呢？那么只能使用第二种构造，传一个<code>Comparator</code>进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</span><br></pre></td></tr></table></figure>
<p>如果希望从大到小排序呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(Collections.reverseOrder());</span><br></pre></td></tr></table></figure>
<p><code>Collections.reverseOrder</code>方法里面还可以再传递一个<code>Comparator</code>进去，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(</span><br><span class="line">	Collections.reverseOrder(String.CASE_INSENSITIVE_ORDER));</span><br></pre></td></tr></table></figure>
<p>这就是忽略大小写并逆序排序。对于更复杂的排序规则那就需要自己实现<code>Comparator</code>了，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sdf.parse(o1).compareTo(sdf.parse(o2));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">map.put(<span class="string">&quot;2023-12-3&quot;</span>, <span class="string">&quot;100&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;2023-10-15&quot;</span>, <span class="string">&quot;50&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;2023-12-25&quot;</span>, <span class="string">&quot;200&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; kv : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(kv.getKey() + <span class="string">&quot;-&gt;&quot;</span> + kv.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个案例就是将键当做一个日期来比较大小，输出的结果是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023</span>-<span class="number">10</span>-<span class="number">15</span>-&gt;<span class="number">50</span></span><br><span class="line"><span class="number">2023</span>-<span class="number">12</span>-<span class="number">3</span>-&gt;<span class="number">100</span></span><br><span class="line"><span class="number">2023</span>-<span class="number">12</span>-<span class="number">25</span>-&gt;<span class="number">200</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>TreeMap</code>要求键是唯一的，而是否唯一的判定标准也是看<code>Comparable</code>或<code>Comparator</code>的比较方法。那这就会出现一些有趣的现象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = </span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">map.put(<span class="string">&quot;T&quot;</span>, <span class="string">&quot;To&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;t&quot;</span>, <span class="string">&quot;to&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; kv : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(kv.getKey() + <span class="string">&quot;-&gt;&quot;</span> + kv.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T-&gt;to</span><br></pre></td></tr></table></figure>
<p>一开始设置键值对<code>T -&gt; To</code>，接下来当我们设置<code>t -&gt; to</code>的时候，因为比较是忽略大小写的，所以认为<code>T</code>和<code>t</code>是相同的键，因此执行的是修改而不是添加，最后的结果就是剩下一对键值对<code>T -&gt; to</code>。</p>
<h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p><code>TreeMap</code>内部使用红黑树实现，红黑树是一种大致平衡的排序二叉树。</p>
<h6 id="内部组成"><a href="#内部组成" class="headerlink" title="内部组成"></a>内部组成</h6><p><code>TreeMap</code>主要有以下几个成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;  <span class="comment">// 比较器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root = <span class="literal">null</span>;  <span class="comment">// 根节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 键值对数量</span></span><br></pre></td></tr></table></figure>
<p><code>Entry</code>是静态内部类，其主要成员和构造如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    K key;  <span class="comment">// 键</span></span><br><span class="line">    V value;  <span class="comment">// 值</span></span><br><span class="line">    Entry&lt;K,V&gt; left = <span class="literal">null</span>;  <span class="comment">// 左孩子</span></span><br><span class="line">    Entry&lt;K,V&gt; right = <span class="literal">null</span>;  <span class="comment">// 右孩子</span></span><br><span class="line">    Entry&lt;K,V&gt; parent;  <span class="comment">// 父节点</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK;  <span class="comment">// 每个节点有个颜色，非黑即红</span></span><br><span class="line">    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="保存键值对"><a href="#保存键值对" class="headerlink" title="保存键值对"></a>保存键值对</h6><p><code>put</code>方法的代码比较长，我们断开看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>) &#123;</span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, <span class="literal">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当添加第一个节点的时候会进到<code>if</code>里面，主要创建一个新节点，让<code>root</code>指向它。里面调用<code>compare</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object k1, Object k2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> comparator==<span class="literal">null</span> ? ((Comparable&lt;? <span class="built_in">super</span> K&gt;)k1).compareTo((K)k2)</span><br><span class="line">    	: comparator.compare((K)k1, (K)k2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要检查是否有比较器或键是否实现了<code>Comparable</code>接口。接下来根据是否包含比较器进入不同的流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cmp;</span><br><span class="line">Entry&lt;K,V&gt; parent;</span><br><span class="line"><span class="comment">//split comparator and comparable paths</span></span><br><span class="line">Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;</span><br><span class="line"><span class="keyword">if</span>(cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        cmp = cpr.compare(key, t.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>)</span><br><span class="line">        	t = t.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>)</span><br><span class="line">        	t = t.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	<span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主体流程就是键小就往左边插入，键大就往右边插入，键一样大就是修改。当退出循环的时候<code>parent</code>指向待插入位置的父节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(key == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        cmp = k.compareTo(t.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>)</span><br><span class="line">        	t = t.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>)</span><br><span class="line">        	t = t.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	<span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span>(t != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有比较器就把键当做<code>Comparable</code>进行比较，流程和上面是一样的。<br>找到父节点后，就创建新节点并插进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent);</span><br><span class="line"><span class="keyword">if</span>(cmp &lt; <span class="number">0</span>)</span><br><span class="line">	parent.left = e;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	parent.right = e;</span><br><span class="line">fixAfterInsertion(e);</span><br><span class="line">size++;</span><br><span class="line">modCount++;</span><br></pre></td></tr></table></figure>
<p>每次插入之后，都会调用<code>fixAfterInsertion</code>方法来调整红黑树的结构使之大致平衡。<br>从整个流程也可以看出，比较优先使用比较器而不是<code>Comparable</code>接口。</p>
<h6 id="用键获取值"><a href="#用键获取值" class="headerlink" title="用键获取值"></a>用键获取值</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> (p == <span class="literal">null</span> ? <span class="literal">null</span> : p.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// Offload comparator-based version for sake of performance</span></span><br><span class="line">    <span class="keyword">if</span>(comparator != <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="keyword">if</span>(key == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>)</span><br><span class="line">        	p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>)</span><br><span class="line">        	p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	<span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主体流程也是很简单，根据键的大小确定往左找还是往右找。里面<code>getEntryUsingComparator</code>方法流程也是一样的，只不过使用比较器进行比较。</p>
<h6 id="查找值"><a href="#查找值" class="headerlink" title="查找值"></a>查找值</h6><p><code>TreeMap</code>可以高效的查找键，但是查找值需要依次遍历。遍历是按照键从小到大进行的，没有使用递归，而是定义了函数<code>successor</code>返回一个节点的后继节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; e = getFirstEntry(); e != <span class="literal">null</span>; e = successor(e))</span><br><span class="line">        <span class="keyword">if</span>(valEquals(value, e.value))</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回最小的节点，显然是在树的最左边</span></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getFirstEntry</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">while</span> (p.left != <span class="literal">null</span>)</span><br><span class="line">    		p = p.left;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; <span class="title function_">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="literal">null</span>)</span><br><span class="line">        	p = p.left;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">        Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">            ch = p;</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对任意一个节点的后继节点的查找策略：</p>
<ol>
<li>如果这个节点有右孩子，那么后继节点一定是右孩子里最小的节点（最左侧节点）。</li>
<li>若这个节点没有右孩子，那么后继节点一定是它的某个祖先节点，不一定是父节点。这个祖先节点一定在它的右侧，若找不到这样的祖先节点就说明遍历结束。</li>
</ol>
<h6 id="删除键值对"><a href="#删除键值对" class="headerlink" title="删除键值对"></a>删除键值对</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> p.value;</span><br><span class="line">    deleteEntry(p);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主体逻辑就是找到键对应的节点，删除掉该节点并返回删除节点的值。<code>deleteEntry</code>方法就是做的删除操作，逻辑比较复杂，主要分三种情况：</p>
<ul>
<li>待删节点是叶子节点，那么直接将其父节点的对应孩子引用置为<code>null</code>。</li>
<li>待删节点只有一个孩子，那么直接让父节点指向这个孩子节点即可。</li>
<li>待删节点有两个孩子，找到该节点的后继节点并将后继节点的值填充到当前节点里面，再删除掉后继节点即可。而我们知道，后继节点是自己右孩子最左侧的节点，因此这个后继节点没有左孩子，很好删除。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">//If strictly internal, copy successor&#x27;s element to p and then make p</span></span><br><span class="line">    <span class="comment">//point to successor.</span></span><br><span class="line">    <span class="keyword">if</span>(p.left != <span class="literal">null</span> &amp;&amp; p.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125; <span class="comment">//p has 2 children</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Start fixup at replacement node, if it exists.</span></span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="literal">null</span> ? p.left : p.right);</span><br><span class="line">    <span class="keyword">if</span>(replacement != <span class="literal">null</span>) &#123;  <span class="comment">// 有一个孩子节点</span></span><br><span class="line">        <span class="comment">//Link replacement to parent</span></span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span>(p.parent == <span class="literal">null</span>)</span><br><span class="line">        	root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p == p.parent.left)</span><br><span class="line">        	p.parent.left = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	p.parent.right = replacement;</span><br><span class="line">        <span class="comment">// Null out links so they are OK to use by fixAfterDeletion.</span></span><br><span class="line">        p.left = p.right = p.parent = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// Fix replacement</span></span><br><span class="line">        <span class="keyword">if</span>(p.color == BLACK)</span><br><span class="line">        	fixAfterDeletion(replacement);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="literal">null</span>) &#123;  <span class="comment">// 树里只有一个节点</span></span><br><span class="line">    	root = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 普通的叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(p.color == BLACK)</span><br><span class="line">        	fixAfterDeletion(p);</span><br><span class="line">        <span class="keyword">if</span>(p.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p == p.parent.left)</span><br><span class="line">            	p.parent.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p == p.parent.right)</span><br><span class="line">            	p.parent.right = <span class="literal">null</span>;</span><br><span class="line">            p.parent = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><code>TreeMap</code>除了实现<code>Map</code>接口还实现了<code>SortedMap</code>、<code>NavigableMap</code>接口，所以它能够更方便进行一些操作，例如：查找第一个节点、最后一个节点、某一个范围的键、邻近键等。<br>在日常使用中，如果需要排序考虑使用<code>TreeMap</code>，否则考虑使用<code>HashMap</code>。</p>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>之前讲<code>HashSet</code>里面的元素是无序的，如果我们想让元素有序（大小有序），可以使用<code>TreeSet</code>。实际上<code>TreeSet</code>内部也是维护了一个<code>TreeMap</code>，所有的操作也是基于<code>TreeMap</code>的。它有以下两个构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span></span><br></pre></td></tr></table></figure>
<p>构造里面就是实例化<code>TreeMap</code>。因此和<code>TreeMap</code>类似，元素之间必须可比较，要么传入一个比较器，要么自己实现<code>Comparable</code>接口。<br><code>TreeSet</code>有如下两个成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>
<p>下面看一些常用功能的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> m.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> m.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> m.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到全是基于<code>TreeMap</code>的操作。</p>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p><code>HashMap</code>里键值对是无序的，<code>TreeMap</code>里键值对是按键有序。有时我们需要让键值对保持插入时的顺序或者保持访问的顺序。保持插入顺序就是先插入的在前面，后插入的在后面。保持访问的顺序，就是最近访问的在后面，最久未访问的在前面。<br><code>LinkedHashMap</code>继承于<code>HashMap</code>，因此<code>LinkedHashMap</code>也是使用哈希桶+单链表的形式存数据。除此之外，<code>LinkedHashMap</code>还维护了一个双向循环链表，这个链表就是用来记录元素的插入顺序或访问顺序，每一个<code>Entry</code>即在哈希桶里还在这个链表里面。</p>
<h5 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h5><p>按插入排序的构造有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span></span><br></pre></td></tr></table></figure>
<p>按访问顺序排序的构造只有一个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> accessOrder)</span></span><br></pre></td></tr></table></figure>
<p>所有的构造中<code>initialCapacity</code>和<code>loadFactor</code>都是用来调用父类即<code>HashMap</code>的构造的，<code>accessOrder</code>设为<code>true</code>表示按访问顺序排序。<br>下面看个按插入有序的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="number">3</span>);</span><br><span class="line">map.put(<span class="string">&quot;c&quot;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; kv : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(kv.getKey() + <span class="string">&quot; &quot;</span> + kv.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a <span class="number">3</span></span><br><span class="line">b <span class="number">2</span></span><br><span class="line">c <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>我们再看一个按访问有序的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">16</span>, <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="number">3</span>);</span><br><span class="line">map.put(<span class="string">&quot;c&quot;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; kv : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(kv.getKey() + <span class="string">&quot; &quot;</span> + kv.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b <span class="number">2</span></span><br><span class="line">a <span class="number">3</span></span><br><span class="line">c <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>注意，最近访问的元素会放到最后面。按访问有序有一个典型的应用：<code>LRU</code>缓存。<code>LRU(Least Recently Used)</code>是一种流行的替换算法，即最近最少使用。<br>主要的应用场景是：当我们往缓存里面添加数据的时候，若缓存已经满了，则我们需要选择一条数据清理掉，<code>LRU</code>算法就是选择最近最少使用的数据进行清理。<br><code>LinkedHashMap</code>能够实现按访问排序，但默认情况下不会清理旧元素即容量没有限制。是否清理主要看下面函数的返回值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LinkedHashMap</code>每次添加元素之后都会调用这个方法，传进去最久未使用的元素，若这个方法返回<code>true</code>，这个元素将会被删除。可以看到默认的实现就是返回<code>false</code>即不删除。如果需要删除的话，我们可以自定义类继承它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxEntries;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> maxEntries)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.maxEntries = maxEntries;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> size() &gt; maxEntries;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><p><code>LinkedHashMap</code>作为<code>HashMap</code>的子类，多加了以下实例变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; header;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>
<p><code>accessOrder</code>表示是否按访问顺序排列，<code>header</code>表示双向循环链表的头结点。注意这边的<code>Entry</code>类是<code>LinkedHashMap</code>自定义继承于<code>HashMap.Entry</code>的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">    	<span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;  <span class="comment">// 从双向链表里删除当前元素</span></span><br><span class="line">        before.after = after;</span><br><span class="line">        after.before = before;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将当前节点插入到指定节点 existingEntry 前</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> &#123;</span><br><span class="line">        after = existingEntry;</span><br><span class="line">        before = existingEntry.before;</span><br><span class="line">        before.after = <span class="built_in">this</span>;</span><br><span class="line">        after.before = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆写父类方法，每次访问存在的元素时会调用这个方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> &#123;</span><br><span class="line">        LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class="line">        <span class="keyword">if</span>(lm.accessOrder) &#123;</span><br><span class="line">            lm.modCount++;</span><br><span class="line">            remove();</span><br><span class="line">            addBefore(lm.header);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆写父类方法，每次删除元素时会调用这个方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> &#123;</span><br><span class="line">    	remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>recordAccess</code>和<code>recordRemoval</code>是定义在<code>HashMap.Entry</code>里面的方法，这两个方法在<code>HashMap</code>里面的实现是空的，它们是专门用来给子类覆写的。<br><code>LinkedHashMap</code>覆写了这两个方法：</p>
<ul>
<li>删除键值对时会调用<code>recordRemoval</code>方法，这个方法就是将节点从维护的双向链表里删除。</li>
<li>访问已存在的键值对时会调用<code>recordAccess</code>方法，这个方法里面在按照访问顺序排列时会将节点移到双向链表的尾部。因为这个链表是循环的，所以头的前面就是尾。</li>
</ul>
<p><code>HashMap</code>构造里会调用<code>init</code>方法，这个方法默认是空实现，也是设计用来被覆写的。<code>LinkedHashMap</code>就重写了这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    header = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(-<span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    header.before = header.after = header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做的事情就是初始化头结点。<br><code>HashMap</code>插入新键值对时会调用<code>addEntry</code>方法，这个方法会进行哈希桶扩容检查并调用<code>createEntry</code>方法将键值对插入到哈希桶指定下标的单链表的头部。<code>LinkedHashMap</code>重写了这两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.addEntry(hash, key, value, bucketIndex);</span><br><span class="line">    <span class="comment">//Remove eldest entry if instructed</span></span><br><span class="line">    Entry&lt;K,V&gt; eldest = header.after;</span><br><span class="line">    <span class="keyword">if</span>(removeEldestEntry(eldest)) &#123;  <span class="comment">// 是否删除最久未访问节点</span></span><br><span class="line">    	removeEntryForKey(eldest.key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, old);</span><br><span class="line">    table[bucketIndex] = e;  <span class="comment">// 节点插到哈希桶里</span></span><br><span class="line">    e.addBefore(header);  <span class="comment">// 节点插到双向链表里</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LinkedHashMap</code>在修改元素或访问元素的时候会做一次检验，若按照访问顺序排列则将这个元素放到双向链表的尾部。下面看一下<code>get</code>的方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);</span><br><span class="line">    <span class="keyword">if</span>(e == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    e.recordAccess(<span class="built_in">this</span>);  <span class="comment">// 将本节点插入到双向链表的尾部</span></span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p><code>LinkedHashMap</code>是<code>HashMap</code>的子类，<code>LinkedHashMap.Entry</code>是<code>HashMap.Entry</code>的子类。除了使用哈希桶来维护键与值的映射关系，还将每个键值对放到一个双向链表里面。这个双向链表存储着键值对插入的先后顺序，通过配置可以表示访问的先后的顺序。</p>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>每一种<code>Map</code>背后都有一种与之对应的<code>Set</code>，所以理所当然有<code>LinkedHashSet</code>。它有以下构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span></span><br></pre></td></tr></table></figure>
<p><code>LinkedHashSet</code>内部使用<code>LinkedHashMap</code>，所以能够按照插入的顺序访问元素。但是没有构造传递<code>accessOrder</code>，所以无法维护访问顺序。</p>
<h4 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h4><p>当我们需要<code>Map</code>的实现类且键的类型是枚举类型时，可以选择<code>EnumMap</code>。</p>
<h5 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h5><p>假设我们定义了表示大小的<code>Size</code>枚举类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    SMALL, MEDIUM, BIG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以像下面这样使用<code>EnumMap</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Size, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(Size.class);</span><br><span class="line">map.put(Size.SMALL, <span class="number">10</span>);</span><br><span class="line">map.put(Size.BIG, <span class="number">100</span>);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>
<p>使用上没什么两样，主要看创建。创建<code>EnumMap</code>对象的时候需要传递一个类型信息，例如上面的<code>Size.class</code>，有了这个类型信息，<code>EnumMap</code>内部就可以依据这个枚举类进行初始化。<br>注意，<code>EnumMap</code>是保证顺序的，输出是按照键在枚举中的顺序。</p>
<h5 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h5><p><code>EnumMap</code>有如下实例变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;K&gt; keyType;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> K[] keyUniverse;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] vals;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>keyType</code>是类型信息。</li>
<li><code>size</code>是键值对的个数。</li>
<li><code>keyUniverse</code>是键的数组，存储所有可能的枚举值。</li>
<li><code>vals</code>存储键所对应的值，存的时候要和键数组的下标保持一致。</li>
</ul>
<p><code>EnumMap</code>的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">EnumMap</span><span class="params">(Class&lt;K&gt; keyType)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.keyType = keyType;</span><br><span class="line">    keyUniverse = getKeyUniverse(keyType);</span><br><span class="line">    vals = <span class="keyword">new</span> <span class="title class_">Object</span>[keyUniverse.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getKeyUniverse</code>方法比较复杂，它最终是调用对应枚举类型的<code>values</code>方法获取所有的枚举值存到<code>keyUniverse</code>数组里。<br>我们下面看保存键值对的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    typeCheck(key);</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> key.ordinal();  <span class="comment">// 使用 ordinal 作为下标访问元素</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">oldValue</span> <span class="operator">=</span> vals[index];</span><br><span class="line">    vals[index] = maskNull(value);</span><br><span class="line">    <span class="keyword">if</span>(oldValue == <span class="literal">null</span>)</span><br><span class="line">    	size++;</span><br><span class="line">    <span class="keyword">return</span> unmaskNull(oldValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查键的类型是否匹配</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">typeCheck</span><span class="params">(K key)</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">keyClass</span> <span class="operator">=</span> key.getClass();</span><br><span class="line">    <span class="keyword">if</span>(keyClass != keyType &amp;&amp; keyClass.getSuperclass() != keyType)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassCastException</span>(keyClass + <span class="string">&quot; != &quot;</span> + keyType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体代码比较简单，但有两个方法<code>maskNull</code>和<code>unmaskNull</code>。<code>EnumMap</code>允许值为<code>null</code>，而数组里元素的默认值也是<code>null</code>，那么遇到<code>null</code>算这个元素出现了还是没出现？于是出现了这两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">NULL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&quot;java.util.EnumMap.NULL&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">maskNull</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (value == <span class="literal">null</span> ? NULL : value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> V <span class="title function_">unmaskNull</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span>(V) (value == NULL ? <span class="literal">null</span> : value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是<code>get</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (isValidKey(key) ? unmaskNull(vals[((Enum)key).ordinal()]) : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键的类型检查，不通过只会返回 false 而不是报错</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(key == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//Cheaper than instanceof Enum followed by getDeclaringClass</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">keyClass</span> <span class="operator">=</span> key.getClass();</span><br><span class="line">    <span class="keyword">return</span> keyClass == keyType || keyClass.getSuperclass() == keyType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它常用方法的源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;  <span class="comment">// 查看是否包含值</span></span><br><span class="line">    value = maskNull(value);</span><br><span class="line">    <span class="keyword">for</span>(Object val : vals)</span><br><span class="line">    	<span class="keyword">if</span>(value.equals(val))</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;  <span class="comment">// 删除键值对</span></span><br><span class="line">    <span class="keyword">if</span>(!isValidKey(key))</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ((Enum)key).ordinal();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">oldValue</span> <span class="operator">=</span> vals[index];</span><br><span class="line">    vals[index] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(oldValue != <span class="literal">null</span>)</span><br><span class="line">    	size--;</span><br><span class="line">    <span class="keyword">return</span> unmaskNull(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h4><p><code>EnumSet</code>是针对枚举类型的集合。之前就说每种<code>Map</code>都有与之对应的<code>Set</code>，所以<code>EnumSet</code>也是存在的。但是注意，<code>EnumSet</code>内部和<code>EnumMap</code>无关，而是采用了更高效的位向量来实现。<br>我在使用这个类的时候遇到一些错误<code>java: No enum constant javax.lang.model.element.Modifier.SEALED</code>，解决方案是：</p>
<ol>
<li><code>IDEA</code>-&gt;<code>File</code>-&gt;<code>Project Structure</code>-&gt;<code>Language level</code></li>
<li>将 JDK 的版本调到 17 就解决了。</li>
</ol>
<h5 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a>用法</h5><p><code>EnumSet</code>是一个抽象类，所以不能直接<code>new</code>出来。但是<code>EnumSet</code>提供了很多静态方法来创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建指定枚举类型的空集</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">noneOf</span><span class="params">(Class&lt;E&gt; elementType)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建指定枚举类型的全集，初始集合包含所有枚举值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">allOf</span><span class="params">(Class&lt;E&gt; elementType)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 ordinal 作为依据，初始集合包含枚举值中范围是 [from, to] 元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">range</span><span class="params">(E from, E to)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始集合包含指定集合的补集</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">complementOf</span><span class="params">(EnumSet&lt;E&gt; s)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始集合包含参数里的所有元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">of</span><span class="params">(E e)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">of</span><span class="params">(E e1, E e2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">of</span><span class="params">(E e1, E e2, E e3)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">of</span><span class="params">(E e1, E e2, E e3, E e4)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">of</span><span class="params">(E first, E... rest)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始集合包含容器中的所有元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">copyOf</span><span class="params">(EnumSet&lt;E&gt; s)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">copyOf</span><span class="params">(Collection&lt;E&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是<code>of</code>方法有很多重载，从功能角度来说有最后一个就足够了，之所以定义前面的重载方法，是因为使用可变长参数效率比较低。</p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>假设我们定义枚举类型<code>Day</code>表示周几：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">    Mon, Tues, Wed, Thur, Fri, Sat, Sun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再定义员工类，里面包含该员工能工作的具体时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Day&gt; workDays;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name, Set&lt;Day&gt; workDays)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.workDays = workDays;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Day&gt; <span class="title function_">getWorkDays</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> workDays;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义一些员工出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Worker[] workers = <span class="keyword">new</span> <span class="title class_">Worker</span>[] &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;张三&quot;</span>, EnumSet.of(Day.Mon, Day.Tues, Day.Wed, Day.Fri)),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;李四&quot;</span>, EnumSet.of(Day.Tues, Day.Thur, Day.Sat)),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;王五&quot;</span>, EnumSet.of(Day.Tues, Day.Thur))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面基于这些员工回答一些问题：</p>
<ol>
<li><p>哪些天一个人都不会来？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Day&gt; days = EnumSet.allOf(Day.class);</span><br><span class="line"><span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">    days.removeAll(worker.getWorkDays());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(days);</span><br></pre></td></tr></table></figure>
<p>[Sun]<br>创建全集 -&gt; 删掉有人来的日期 -&gt; 剩下的日期就是没人来的。</p>
</li>
<li><p>哪些天至少有一个人来？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Day&gt; days = EnumSet.noneOf(Day.class);</span><br><span class="line"><span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">    days.addAll(worker.getWorkDays());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(days);</span><br></pre></td></tr></table></figure>
<p>[Mon, Tues, Wed, Thur, Fri, Sat]<br>创建空集 -&gt; 添加有人来的日期 -&gt; 存在的就是有人来的。</p>
</li>
<li><p>哪些天至少两个人来？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Day&gt; days = EnumSet.noneOf(Day.class);</span><br><span class="line">Map&lt;Day, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(Day.class);</span><br><span class="line"><span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Day day : worker.getWorkDays()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.getOrDefault(day, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        map.put(day, count);</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= <span class="number">2</span>) days.add(day);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(days);</span><br></pre></td></tr></table></figure>
<p>[Tues, Thur]<br>我们先借助<code>EnumMap</code>统计每天有多少人去，选出至少两个人的添加到集合里面。</p>
</li>
<li><p>哪些天所有人都在？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Day&gt; days = EnumSet.allOf(Day.class);</span><br><span class="line"><span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">    days.retainAll(worker.getWorkDays());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(days);</span><br></pre></td></tr></table></figure>
<p>[Tues]<br>创建全集并保留每一个员工都在的日期，最后剩余的就是答案。</p>
</li>
<li><p>哪些人周一、周二都会来？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Day&gt; mt = EnumSet.of(Day.Mon, Day.Tues);</span><br><span class="line"><span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">    <span class="keyword">if</span> (worker.getWorkDays().containsAll(mt)) &#123;</span><br><span class="line">        System.out.println(worker.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>张三<br>看每个员工的工作日期是否同时包含周一和周二。</p>
</li>
</ol>
<h5 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h5><p><code>EnumSet</code>使用位向量实现，所谓位向量就是使用一位表示元素的状态，使用一组位表示集合的状态。而集合中每个元素的状态只有存在和不存在两种。<br>对于元素是<code>Day</code>类型的集合，一共就 7 种元素，所以使用一个字节（8 位）即可表示。位向量中自右向左表示元素，例如包含<code>Day.Mon</code>、<code>Day.Tues</code>、<code>Day.Wed</code>、<code>Day.Fri</code>的集合位向量图为：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703648545502-48d8e98e-7d30-4124-97e7-7110903b2af5.png#averageHue=%23d8d8d8&clientId=u2e2c9feb-4180-4&from=paste&height=102&id=u3d63d8e1&originHeight=102&originWidth=601&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31160&status=done&style=none&taskId=ue89ce0a7-21bc-412a-a071-e3086619b0f&title=&width=601" alt="image.png"><br><code>EnumSet</code>里面位向量的长度是多少呢？<br><code>EnumSet</code>是一个抽象类，里面并没有定义位向量。它有两个子类<code>RegularEnumSet</code>和<code>JumboEnumSet</code>，其中<code>RegularEnumSet</code>内部使用一个<code>long</code>作为位向量，<code>JumboEnumSet</code>使用一个<code>long</code><strong>数组</strong>作为位向量。使用<code>EnumSet</code>静态方法创建集合的时候，若枚举值个数小于等于 64 会创建<code>RegularEnumSet</code>，否则会创建<code>JumboEnumSet</code>。<br><code>EnumSet</code>内部定义了如下两个成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Class&lt;E&gt; elementType;</span><br><span class="line"><span class="keyword">final</span> Enum[] universe;</span><br></pre></td></tr></table></figure>
<p>其中<code>elementType</code>表示枚举类型，<code>universe</code>存储所有枚举值。<code>EnumSet</code>内部没有位向量及记录元素个数的变量，这些内容由子类维护。<br>对于<code>RegularEnumSet</code>有以下定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">elements</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Long.bitCount(elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>elements</code>作为位向量存在，<code>size</code>方法用来统计位向量里面有多少元素。<br>对<code>JumboEnumSet</code>有如下定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> elements[];</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><code>elements</code>数组作为位向量，使用<code>size</code>变量记录元素的个数。<br>下面我们看看<code>EnumSet</code>的静态方法<code>noneOf</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">noneOf</span><span class="params">(Class&lt;E&gt; elementType)</span> &#123;</span><br><span class="line">    Enum[] universe = getUniverse(elementType);</span><br><span class="line">    <span class="keyword">if</span>(universe == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassCastException</span>(elementType + <span class="string">&quot; not an enum&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(universe.length &lt;= <span class="number">64</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegularEnumSet</span>&lt;&gt;(elementType, universe);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JumboEnumSet</span>&lt;&gt;(elementType, universe);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RegularEnumSet(Class&lt;E&gt;elementType, Enum[] universe) &#123;</span><br><span class="line">	<span class="built_in">super</span>(elementType, universe);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JumboEnumSet(Class&lt;E&gt;elementType, Enum[] universe) &#123;</span><br><span class="line">    <span class="built_in">super</span>(elementType, universe);</span><br><span class="line">    <span class="comment">// (universe.length + 63) &gt;&gt;&gt; 6 可以计算出至少需要多少 long 才能存下</span></span><br><span class="line">    elements = <span class="keyword">new</span> <span class="title class_">long</span>[(universe.length + <span class="number">63</span>) &gt;&gt;&gt; <span class="number">6</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法里面是根据枚举值的数量选择对应的子类进行创建，子类的构造里面会调用父类的构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EnumSet(Class&lt;E&gt;elementType, Enum[] universe) &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementType = elementType;</span><br><span class="line">    <span class="built_in">this</span>.universe = universe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它的工厂方法都是先调用<code>noneOf</code>然后再往集合里面添加元素。<br>下面看看<code>RegularEnumSet</code>的<code>add</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    typeCheck(e);</span><br><span class="line">    <span class="type">long</span> <span class="variable">oldElements</span> <span class="operator">=</span> elements;</span><br><span class="line">    elements |= (<span class="number">1L</span> &lt;&lt; ((Enum)e).ordinal());</span><br><span class="line">    <span class="keyword">return</span> elements != oldElements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要就是根据元素值的<code>ordinal</code>决定给位向量里哪一位置 1。<br><code>JumboEnumSet</code>的<code>add</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    typeCheck(e);</span><br><span class="line">    <span class="type">int</span> <span class="variable">eOrdinal</span> <span class="operator">=</span> e.ordinal();</span><br><span class="line">    <span class="type">int</span> <span class="variable">eWordNum</span> <span class="operator">=</span> eOrdinal &gt;&gt;&gt; <span class="number">6</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">oldElements</span> <span class="operator">=</span> elements[eWordNum];</span><br><span class="line">    elements[eWordNum] |= (<span class="number">1L</span> &lt;&lt; eOrdinal);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> (elements[eWordNum] != oldElements);</span><br><span class="line">    <span class="keyword">if</span>(result)</span><br><span class="line">    	size++;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个思路和上面<code>RegularEnumSet</code>的思路类似，只是多了一个寻找位向量下标的操作。如前面的内容，不论左移还是右移，移动的位数不是直接使用后面的数字。对<code>int</code>移位是取后面数字的低 5 位作为移动位数，<code>long</code>是取 6 位。<br>其它的方法<code>JumboEnumSet</code>的实现和<code>RegularEnumSet</code>都是类似的，只不过都多了寻找下标的操作。因此，后面我们主要看<code>RegularEnumSet</code>的实现。<br>我们再看<code>RegularEnumSet</code>的<code>remove</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(e == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">eClass</span> <span class="operator">=</span> e.getClass();</span><br><span class="line">    <span class="keyword">if</span>(eClass != elementType &amp;&amp; eClass.getSuperclass() != elementType)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">oldElements</span> <span class="operator">=</span> elements;</span><br><span class="line">    elements &amp;= ~(<span class="number">1L</span> &lt;&lt; ((Enum)e).ordinal());</span><br><span class="line">    <span class="keyword">return</span> elements != oldElements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要思路就是将要删除的位置为 0，其余位置为 1，然后再与位向量相与即可。<br>再看<code>contains</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(e == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;<span class="type">Class</span> <span class="variable">eClass</span> <span class="operator">=</span> e.getClass();</span><br><span class="line">    <span class="keyword">if</span>(eClass != elementType &amp;&amp; eClass.getSuperclass() != elementType)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (elements &amp; (<span class="number">1L</span> &lt;&lt; ((Enum)e).ordinal())) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是<code>EnumSet</code>的工厂方法<code>complementOf</code>，它能够求补集，内部调用的是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">complement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(universe.length != <span class="number">0</span>) &#123;</span><br><span class="line">        elements = ~elements;</span><br><span class="line">        elements &amp;= -<span class="number">1L</span> &gt;&gt;&gt; -universe.length; <span class="comment">// Mask unused bits</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求补集本来是直接取反就可以了，但是考虑的位向量里面可能存在没使用到的位。例如枚举值一共就 7 种可能，使用一个<code>long</code>存储，那么高 57 位是用不到的，默认都是置 0，取反就变成 1 了。因此，就有了最后一句话<code>elements &amp;= -1L &gt;&gt;&gt; -universe.length</code>，需要注意的是移动<code>-universe.length</code>位相当于移动<code>64 - universe.length</code>位。</p>
<h3 id="堆和优先级队列"><a href="#堆和优先级队列" class="headerlink" title="堆和优先级队列"></a>堆和优先级队列</h3><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>首先堆是一棵完全二叉树，完全二叉树比满二叉树的约束要小一点。满二叉树（图A）里所有非叶子节点都有两个孩子，且叶子节点只会出现在最后一行，这就要求最后一行是满的。而完全二叉树（图B）相对于满二叉树不要求最后一行是满的，如果最后一行不满，所有节点必须从左到右依次排列，中间不能空着。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703830772252-25bb81af-ee4e-48ae-ac55-3704b0125d0d.png#averageHue=%23f8f8f8&clientId=u934a904e-b132-4&from=paste&height=194&id=u028b7d8b&originHeight=528&originWidth=978&originalType=binary&ratio=2&rotation=0&showTitle=false&size=154093&status=done&style=none&taskId=u64edecb3-23c4-49c9-a354-7d8c2cf0b82&title=&width=360" alt="image.png"><br>（A）满二叉树<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703830824298-c5b974e8-52f4-41f0-a562-092f60fe8e9e.png#averageHue=%23f8f8f8&clientId=u934a904e-b132-4&from=paste&height=194&id=ue24b42ca&originHeight=702&originWidth=1040&originalType=binary&ratio=2&rotation=0&showTitle=false&size=168948&status=done&style=none&taskId=ueaa73243-2fd6-41ad-a799-ead44df8854&title=&width=287" alt="image.png"><br>（B）完全二叉树<br>如上图（B），我们可以给一个完全二叉树里面的节点从 1 开始、自上而下、自左到右编号。我们发现对任意一个节点<code>i</code>：</p>
<ul>
<li>它的父节点编号是<code>i / 2</code>；</li>
<li>它的子节点编号分别是<code>i * 2</code>和<code>i * 2 + 1</code>。</li>
</ul>
<p>这样的特性很好，因为这样我们就可以物理上使用数组来存储逻辑上的树，这可以有效提升随机访问的效率。在堆中不要求元素之间完全有序，但对于父子之间存在一定的顺序，按照顺序可以把堆分成：最大堆和最小堆。<br>最大堆里面任意一个节点的值都不能大于父节点的值，最小堆则相反。因此最大堆的根节点是整个树里值最大的，最小堆则是最小的。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703832887812-70b3fd55-b329-4077-8914-a1862a5d9d09.png#averageHue=%23fbfbfb&clientId=u934a904e-b132-4&from=paste&height=250&id=u76817a50&originHeight=504&originWidth=830&originalType=binary&ratio=2&rotation=0&showTitle=false&size=118276&status=done&style=none&taskId=ub5c048e7-b402-4c9d-ae52-bebc0f591da&title=&width=412" alt="image.png"><br>最大堆例图<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703832899714-f044e380-9169-454c-a712-928ae02316b8.png#averageHue=%23fbfbfb&clientId=u934a904e-b132-4&from=paste&height=250&id=u63c202ac&originHeight=512&originWidth=834&originalType=binary&ratio=2&rotation=0&showTitle=false&size=122626&status=done&style=none&taskId=u40817453-adb9-48ef-b547-c6cccf1beb6&title=&width=407" alt="image.png"><br>最小堆例图</p>
<h5 id="堆的算法"><a href="#堆的算法" class="headerlink" title="堆的算法"></a>堆的算法</h5><p>最大堆和最小堆的算法都是类似的，下面的算法以最小堆举例子。</p>
<h6 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h6><p>所谓添加元素就是往最小堆里面添加元素并继续保持最小堆的特性：</p>
<ol>
<li>如果堆是空的那么直接添加一个根就行。</li>
<li>如果堆不空那么先将元素添加到最后并重复做：<ul>
<li>若元素值不小于父节点的值或元素没有父节点则结束</li>
<li>元素值小于父节点的值就和父节点交换位置</li>
</ul>
</li>
</ol>
<p>假设我们想在已存在的树里面追加一个节点 3，我们画图看一下例子：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703834638239-32f40a68-8071-4134-b201-ab8c3d3b13b1.png#averageHue=%23fbfbfb&clientId=u934a904e-b132-4&from=paste&height=220&id=qgrNk&originHeight=560&originWidth=914&originalType=binary&ratio=2&rotation=0&showTitle=false&size=142072&status=done&style=none&taskId=uecace63f-9d7a-479d-b7c3-33b4607c03b&title=&width=359" alt="image.png"><br>（a）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703834676625-b9a62ee0-af57-459c-babc-522f42ec9a62.png#averageHue=%23f9f9f9&clientId=u934a904e-b132-4&from=paste&height=270&id=oOZp3&originHeight=540&originWidth=898&originalType=binary&ratio=2&rotation=0&showTitle=false&size=151995&status=done&style=none&taskId=ua6a90f37-f1dc-466c-acd5-23253721db5&title=&width=449" alt="image.png"><br>（c）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703834719346-18dbc976-1a3a-4f61-b07e-c1e5061756b1.png#averageHue=%23fafafa&clientId=u934a904e-b132-4&from=paste&height=270&id=HIjrW&originHeight=540&originWidth=892&originalType=binary&ratio=2&rotation=0&showTitle=false&size=146941&status=done&style=none&taskId=u23c06b6d-1850-476b-8f09-e4963acd053&title=&width=446" alt="image.png"><br>（e）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703834656419-b4687e70-bc75-4aa1-b39b-11db1d3ef56e.png#averageHue=%23fafafa&clientId=u934a904e-b132-4&from=paste&height=220&id=VMGOI&originHeight=534&originWidth=890&originalType=binary&ratio=2&rotation=0&showTitle=false&size=147980&status=done&style=none&taskId=u5a0bdc0a-8ee8-4596-b929-23b234467ad&title=&width=367" alt="image.png"><br>（b）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703834696308-e3f469b4-1256-4f69-9df3-ae862f64f21a.png#averageHue=%23fafafa&clientId=u934a904e-b132-4&from=paste&height=267&id=eOfdl&originHeight=534&originWidth=884&originalType=binary&ratio=2&rotation=0&showTitle=false&size=148507&status=done&style=none&taskId=ub61d985e-e3a3-4122-94b1-54f4082c43c&title=&width=442" alt="image.png"><br>（d）<br>我们把这样满足自底向上比较、交换使得树满足堆性质的过程称为<strong>向上调整（siftup）</strong>。</p>
<h6 id="头部删除元素"><a href="#头部删除元素" class="headerlink" title="头部删除元素"></a>头部删除元素</h6><p>队列中一种常用操作是从头部删除元素，Java 是用堆实现优先级队列的。堆里面删除头部元素的一般步骤是：</p>
<ol>
<li>用最后一个元素替换头部元素并删除最后一个元素；</li>
<li>从头部开始，将元素与其孩子节点比较：<ol>
<li>若元素不小于孩子节点，结束；</li>
<li>若元素小于孩子节点，则将元素与其较小的孩子交换；</li>
<li>重复上述过程直到树满足最小堆。</li>
</ol>
</li>
</ol>
<p>下面描述了一个最小堆里删除头元素的过程：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703839847513-e4bce9d6-13ed-4d89-b99d-1a0f818ce192.png#averageHue=%23fbfbfb&clientId=u934a904e-b132-4&from=paste&height=228&id=ua7c8d7a0&originHeight=245&originWidth=387&originalType=binary&ratio=2&rotation=0&showTitle=false&size=38724&status=done&style=none&taskId=u50a752c7-b763-4790-8bc8-e334d373f72&title=&width=360" alt="image.png"><br>（a）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703839912798-7bd735d8-bb5d-47fc-b793-d4966c8c469a.png#averageHue=%23fafafa&clientId=u934a904e-b132-4&from=paste&height=228&id=u863f73cb&originHeight=228&originWidth=362&originalType=binary&ratio=2&rotation=0&showTitle=false&size=34089&status=done&style=none&taskId=u5fdcdb90-0efd-4325-b955-b17e0185941&title=&width=362" alt="image.png"><br>（c）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703839875343-d7e76d6b-3951-4ffa-90ed-a764b2942baf.png#averageHue=%23fafafa&clientId=u934a904e-b132-4&from=paste&height=228&id=ue0e24dc8&originHeight=227&originWidth=364&originalType=binary&ratio=2&rotation=0&showTitle=false&size=36670&status=done&style=none&taskId=u93c09756-015e-4fef-be5c-66a6b1dbcc9&title=&width=366" alt="image.png"><br>（b）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703839928727-e6afbdce-462f-45c5-b723-787450ffdbc3.png#averageHue=%23fafafa&clientId=u934a904e-b132-4&from=paste&height=225&id=ubc86baf6&originHeight=225&originWidth=364&originalType=binary&ratio=2&rotation=0&showTitle=false&size=33052&status=done&style=none&taskId=ucdd89eea-f432-44c4-9ac6-317f05ad2ef&title=&width=364" alt="image.png"><br>（d）<br>我们把这样满足自上向下比较、交换使得树满足堆性质的过程称为<strong>向下调整（siftdown）</strong>。</p>
<h6 id="中间删除元素"><a href="#中间删除元素" class="headerlink" title="中间删除元素"></a>中间删除元素</h6><p>从堆中间删除元素和从头部删除类似，我们先用结尾的元素替换要删除的元素。替换后做判断：若该元素小于父元素就向上调整，若该元素大于子元素就向下调整。<br>删除节点 21 的示例图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703840299441-2ab492ca-5c31-4052-a693-0bb41f7ce059.png#averageHue=%23f8f8f8&clientId=u934a904e-b132-4&from=paste&height=228&id=ued366b86&originHeight=216&originWidth=349&originalType=binary&ratio=2&rotation=0&showTitle=false&size=38038&status=done&style=none&taskId=ua61946e8-007a-42d5-9ba8-14fb4d39a21&title=&width=368" alt="image.png"><br>（a）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703840317301-e382bf81-0c76-4e87-b012-418bccf80e32.png#averageHue=%23f8f8f8&clientId=u934a904e-b132-4&from=paste&height=228&id=ufbcce7a2&originHeight=216&originWidth=350&originalType=binary&ratio=2&rotation=0&showTitle=false&size=38964&status=done&style=none&taskId=uabda82cd-e57e-441b-a65e-e7d1fb48da2&title=&width=369" alt="image.png"><br>（b）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703840334386-5b34380d-694d-4bef-a6b0-681ace21a569.png#averageHue=%23f9f9f9&clientId=u934a904e-b132-4&from=paste&height=228&id=u5652cfe1&originHeight=232&originWidth=369&originalType=binary&ratio=2&rotation=0&showTitle=false&size=38467&status=done&style=none&taskId=u6bd7edab-46fe-4e5d-b3ea-1bc9e4d88ff&title=&width=363" alt="image.png"><br>（c）<br>删除节点 9 的示例图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703840351373-1fb56801-420e-45cf-bb42-f363e0ced05d.png#averageHue=%23f9f9f9&clientId=u934a904e-b132-4&from=paste&height=228&id=uf2979300&originHeight=211&originWidth=338&originalType=binary&ratio=2&rotation=0&showTitle=false&size=35550&status=done&style=none&taskId=u319eba56-f02c-450c-a0b9-1620a655887&title=&width=365" alt="image.png"><br>（a）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703840370163-af7026a4-1d87-4a49-baff-65d8602e96df.png#averageHue=%23f9f9f9&clientId=u934a904e-b132-4&from=paste&height=228&id=u1792f8c8&originHeight=212&originWidth=338&originalType=binary&ratio=2&rotation=0&showTitle=false&size=35930&status=done&style=none&taskId=u9e8fc7dc-c30f-47b9-963f-ce7cdd4a6dc&title=&width=364" alt="image.png"><br>（b）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703840384843-02bf0b28-d32f-4352-927a-a1a3e754c350.png#averageHue=%23f8f8f8&clientId=u934a904e-b132-4&from=paste&height=228&id=u9275004b&originHeight=228&originWidth=372&originalType=binary&ratio=2&rotation=0&showTitle=false&size=39360&status=done&style=none&taskId=u09aed5e9-fb41-472f-87de-63c79f69c12&title=&width=372" alt="image.png"><br>（c）</p>
<h6 id="构建初始堆"><a href="#构建初始堆" class="headerlink" title="构建初始堆"></a>构建初始堆</h6><p>将一个无序数组构建成堆的过程称为<code>heapify</code>，基本过程是从最后一个非叶子节点开始直到第一个节点，对这里面的每一个节点都执行一次向下调整。说白了就是从小树到大树，将每一棵树都构建成堆，到最后整棵树就成为了堆。<br>不妨假设树里面有<code>size</code>个节点，那么最后一个非叶子节点的下标是<code>size / 2</code>。因为对于任一节点<code>i</code>，如果下标为<code>2 * i</code>的节点存在于树里，那么<code>i</code>就不会是叶子节点，反之也成立。构建初始堆的示意代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size / <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        siftdown(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="查找和遍历"><a href="#查找和遍历" class="headerlink" title="查找和遍历"></a>查找和遍历</h6><p>在堆中进行查找本质上就是在数组里进行查找，只需要从头到尾遍历一遍数组即可。<br>遍历和查找类似，但需要注意的是堆的第一个元素一定是最大值或最小值。有趣的是，我们逐个从头部删除元素，可以确保输出是有序的。</p>
<h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p><code>PriorityQueue</code>是优先级队列，它的内部是使用堆实现的。它实现了<code>Queue</code>接口，与<code>LinkedList</code>类似，队列长度没有限制。与一般队列有所区别的是，队列里面的元素都具有一个优先级，队头的元素永远是优先级最高的。</p>
<h5 id="用法-4"><a href="#用法-4" class="headerlink" title="用法"></a>用法</h5><p><code>Queue</code>接口我们之前说过了，为了方便，这边再重新看一下定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;  <span class="comment">// 尾部添加元素，队满时抛异常</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>;  <span class="comment">// 尾部添加元素，队满时返回 false</span></span><br><span class="line">    E <span class="title function_">remove</span><span class="params">()</span>;  <span class="comment">// 头部删除元素，队空时抛异常</span></span><br><span class="line">    E <span class="title function_">poll</span><span class="params">()</span>;  <span class="comment">// 头部删除元素，队空时返回 null</span></span><br><span class="line">    E <span class="title function_">element</span><span class="params">()</span>;  <span class="comment">// 查看头部元素，队空时抛异常</span></span><br><span class="line">    E <span class="title function_">peek</span><span class="params">()</span>;  <span class="comment">// 查看头部元素，队空时返回 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PriorityQueue</code>有多个构造，部分构造如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(<span class="type">int</span> initialCapacity, Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br></pre></td></tr></table></figure>
<p><code>PriorityQueue</code>是用堆实现的，物理上就是数组，一个能动态扩展的数组。数组默认大小是 11，可以传递<code>initialCapacity</code>表示初始数组的大小，也可以传递一个集合那么集合元素的数目就是初始数组的大小。为了保持元素的顺序，<code>PriorityQueue</code>要求元素要么实现<code>Comparable</code>接口，要么传递一个<code>Comparator</code>进去。看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">pq.offer(<span class="number">10</span>);</span><br><span class="line">pq.add(<span class="number">22</span>);</span><br><span class="line">pq.addAll(Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;</span><br><span class="line">	<span class="number">11</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">19</span>, <span class="number">13</span> &#125;));</span><br><span class="line"><span class="keyword">while</span>(pq.peek() != <span class="literal">null</span>)&#123;</span><br><span class="line">    System.out.print(pq.poll() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次我们从头部删除一个元素，所以输出的是一个升序的序列。如果需要降序，可以自己传递一个<code>Comparator</code>进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="number">11</span>, Collections.reverseOrder());</span><br></pre></td></tr></table></figure>
<p>我们定义一个任务类，里面有优先级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Task&gt; taskComparator = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Task&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Task o1, Task o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o2.priority - o1.priority;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(String name, <span class="type">int</span> priority)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.priority = priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPriority</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Task&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="number">11</span>, Task.taskComparator);</span><br><span class="line">pq.addAll(Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;看电视&quot;</span>, <span class="number">10</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;研究技术&quot;</span>, <span class="number">50</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;看书&quot;</span>, <span class="number">30</span>))</span><br><span class="line">);</span><br><span class="line"><span class="keyword">while</span> (pq.peek() != <span class="literal">null</span>) &#123;  <span class="comment">// 按优先级输出各个任务</span></span><br><span class="line">    <span class="type">Task</span> <span class="variable">t</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">    System.out.println(t.name + <span class="string">&quot; &quot;</span> + t.priority);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h5><h6 id="成员及构造"><a href="#成员及构造" class="headerlink" title="成员及构造"></a>成员及构造</h6><p><code>PriorityQueue</code>内部有如下成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> E&gt; comparator;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>queue</code>是存储元素的数组；</li>
<li><code>size</code>是元素的个数；</li>
<li><code>comparator</code>是比较器；</li>
<li><code>modCount</code>表示队列结构化修改的次数。</li>
</ul>
<p>我们说<code>PriorityQueue</code>使用堆实现，和上面介绍的堆不同的是，节点编号从 0 开始即存储的时候从数组下标 0 的地方开始存储。那么对于任意下标<code>i</code>：</p>
<ul>
<li>父节点下标是<code>(i - 1) / 2</code></li>
<li>子节点的下标是<code>i * 2 + 1</code>与<code>i * 2 + 2</code></li>
</ul>
<p>我们再看看<code>PriorityQueue</code>几个基本的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(initialCapacity, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(<span class="type">int</span> initialCapacity, Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h6><p>两种添加方法实现差不多，只不过满队时一个抛异常一个不抛。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(e == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= queue.length)  <span class="comment">// 队列不够就扩容</span></span><br><span class="line">    	grow(i + <span class="number">1</span>);</span><br><span class="line">    size = i + <span class="number">1</span>;  <span class="comment">// 元素个数 +1</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)  <span class="comment">// 第一次添加直接加在队头</span></span><br><span class="line">    	queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 放在最后，向上调整</span></span><br><span class="line">    	siftUp(i, e);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> queue.length;</span><br><span class="line">    <span class="comment">// 目前容量不满 64 就翻倍否则增加 50%</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">        (oldCapacity + <span class="number">2</span>) : (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span>(newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    	newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 数组拷贝</span></span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向上调整的方法分为使用比较器和<code>Comparable</code>两种，逻辑都一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(comparator != <span class="literal">null</span>)</span><br><span class="line">    	siftUpUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> queue[parent];</span><br><span class="line">        <span class="keyword">if</span>(comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意因为下标从 0 开始，所以节点<code>i</code>的父节点下标是<code>(i - 1) / 2</code>。</p>
<h6 id="头部元素"><a href="#头部元素" class="headerlink" title="头部元素"></a>头部元素</h6><p>取头部元素比较简单，主体逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) queue[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除头部元素"><a href="#删除头部元素" class="headerlink" title="删除头部元素"></a>删除头部元素</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> (E) queue[<span class="number">0</span>];</span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) queue[s];</span><br><span class="line">    queue[s] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(s != <span class="number">0</span>)</span><br><span class="line">    	siftDown(<span class="number">0</span>, x);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(comparator != <span class="literal">null</span>)</span><br><span class="line">    	siftDownUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownComparable</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> E&gt; key = (Comparable&lt;? <span class="built_in">super</span> E&gt;)x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">//loop while a non-leaf</span></span><br><span class="line">    <span class="keyword">while</span>(k &lt; half) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">//assume left child is least</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; size &amp;&amp;</span><br><span class="line">          ((Comparable&lt;? <span class="built_in">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">        	c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span>(key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是下标<code>i</code>的孩子分别是<code>2 * i + 1</code>和<code>2 * i + 2</code>。</p>
<h6 id="根据值删除元素"><a href="#根据值删除元素" class="headerlink" title="根据值删除元素"></a>根据值删除元素</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexOf(o);</span><br><span class="line">    <span class="keyword">if</span>(i == -<span class="number">1</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        removeAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从前到后比较</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] es = queue;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = size; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(es[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">removeAt</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; size;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> --size;</span><br><span class="line">    <span class="keyword">if</span>(s == i) <span class="comment">// removed last element</span></span><br><span class="line">    	queue[i] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">moved</span> <span class="operator">=</span> (E) queue[s];</span><br><span class="line">        queue[s] = <span class="literal">null</span>;</span><br><span class="line">        siftDown(i, moved);</span><br><span class="line">        <span class="keyword">if</span>(queue[i] == moved) &#123;</span><br><span class="line">        	siftUp(i, moved);</span><br><span class="line">            <span class="keyword">if</span>(queue[i] != moved)</span><br><span class="line">            	<span class="keyword">return</span> moved;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>removeAt</code>方法有一个返回值，但是返回的不是删除掉的元素。我们知道删除掉元素<code>i</code>之后，会将最后一个元素放过来，然后执行向上或向下调整。如果成功向上调整了（元素被放到下标小于<code>i</code>的地方），那么返回原来的最后一个元素，否则返回<code>null</code>。这么设计的原因是保证遍历的时候不会漏掉元素。</p>
<h6 id="构造堆"><a href="#构造堆" class="headerlink" title="构造堆"></a>构造堆</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initFromCollection</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    initElementsFromCollection(c);</span><br><span class="line">    heapify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initElementsFromCollection</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">if</span>(a.getClass() != Object[].class)</span><br><span class="line">    	a = Arrays.copyOf(a, a.length, Object[].class);</span><br><span class="line">    <span class="built_in">this</span>.queue = a;</span><br><span class="line">    <span class="built_in">this</span>.size = a.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    	siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面有一句奇怪的话<code>a.getClass() != Object[].class</code>，为什么两者会不想等？<br><code>a.getClass()</code>的静态类型是<code>Object[]</code>，但动态类型可能是<code>Integer[]</code>或者其它。使用<code>a.getClass()</code>获取的是动态类型而不是静态类型。而使用<code>Object[].class</code>获取到的类型一定是<code>Object[]</code>，因此需要判定一下两者是否一样。</p>
<h4 id="PriorityQueue-的应用"><a href="#PriorityQueue-的应用" class="headerlink" title="PriorityQueue 的应用"></a>PriorityQueue 的应用</h4><h5 id="前-K-个最大元素"><a href="#前-K-个最大元素" class="headerlink" title="前 K 个最大元素"></a>前 K 个最大元素</h5><p>想要求一个数组里最大的 K 个元素，甚至数据可能会源源不断的到来，需要动态的维护这 K 个元素。</p>
<ul>
<li>对数组排序，排完序直接取前 K 个元素即可，时间复杂度是$O(N\times logN)$。</li>
<li>先找最大的，然后在剩下里面找最大的，重复 K 次即可，时间复杂度为$O(N\times K)$。</li>
<li>新开一个长度为 K 的数组用来保存最大的 K 个元素，每次添加元素的时候都将元素与这 K 个元素的最小值比较，若大于该最小值就替换掉这个最小值。</li>
</ul>
<p>前两种没什么好说的，第三种如果我们使用堆来存储最大的 K 个元素那么插入的时间复杂度可以降为$O(logK)$，整体的时间复杂度就变为$O(N\times logK)$。<br>因为我们每次比较的时候都是使用 K 个元素里面最小值进行比较的，所以我们应该维护一个最小堆，这样最小值就是堆的根元素。看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TopK</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;E&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;E&gt; p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TopK</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        <span class="built_in">this</span>.p = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.size() &lt; k) &#123;  <span class="comment">// 元素不满 k 个直接插入</span></span><br><span class="line">            p.add(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Comparable&lt;E&gt; min = p.peek();</span><br><span class="line">        <span class="keyword">if</span> (min.compareTo(e) &gt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        p.poll();</span><br><span class="line">        p.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;E&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">            add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E[] toArray(E[] a) &#123;</span><br><span class="line">        <span class="keyword">return</span> p.toArray(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TopK&lt;Integer&gt; top = <span class="keyword">new</span> <span class="title class_">TopK</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">top.addAll(Arrays.asList(<span class="number">20</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">22</span>, <span class="number">19</span>, <span class="number">49</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>));</span><br><span class="line">System.out.println(Arrays.toString(top.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">0</span>])));</span><br></pre></td></tr></table></figure>
<p>代码输出<code>[10, 19, 20, 22, 49]</code>，堆里保存了最大的 5 个元素。</p>
<h5 id="求中位数"><a href="#求中位数" class="headerlink" title="求中位数"></a>求中位数</h5><p>中位数就是数据排序之后位于中间位置的数，若数据总数是奇数那么中位数没有歧义，若数据总数是偶数，中间将会有两个数字，此时中位数可以是：较小的那个、较大的那个、随便一个、两者的平均值。<br>我们当然可以使用排序来寻找中位数，但没有必要，尤其是数据源源不断添加的情况下排序效率很低。我们可以维护两个堆，最大堆维护比中位数小的数，最小堆维护比中位数大的数，具体流程如下：</p>
<ul>
<li>假设中位数用<code>m</code>保存，最大堆里的元素都<code>≤m</code>，最小堆的元素都<code>≥m</code>。</li>
<li>当新元素<code>e</code>到达时，若<code>e ≤ m</code>将<code>e</code>插入到最大堆，否则插入到最小堆。</li>
<li>当两个堆的元素数目差<code>≥2</code>时做以下调整：<ul>
<li>设元素较少的堆为<code>A</code>，元素较多的堆为<code>B</code>；</li>
<li>将<code>m</code>插入到<code>A</code>中，同时将<code>B</code>的根拿出来作为新的中位数赋值给<code>m</code>。</li>
</ul>
</li>
</ul>
<p>所有元素插入完成之后，若两个堆元素数目一样，那么<code>m</code>就是唯一的中位数；若元素数目不一样，那么两个堆元素数目差必然为 1，取出元素较多的堆的根，这个根就是另一个中位数，拿到两个中位数之后取大的还是小的或者平均值都很简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Median</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;E&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> E m;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;E&gt; minP;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;E&gt; maxP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Median</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.minP = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.maxP = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="number">11</span>, Collections.reverseOrder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="literal">null</span>) &#123;</span><br><span class="line">            m = e;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e.compareTo(m) &lt;= <span class="number">0</span>) maxP.add(e);</span><br><span class="line">        <span class="keyword">else</span> minP.add(e);</span><br><span class="line">        <span class="keyword">if</span> (minP.size() - maxP.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            maxP.add(m);</span><br><span class="line">            m = minP.poll();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxP.size() - minP.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            minP.add(m);</span><br><span class="line">            m = maxP.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;E&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">            add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getM</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Median&lt;Integer&gt; median = <span class="keyword">new</span> <span class="title class_">Median</span>&lt;&gt;();</span><br><span class="line">median.addAll(Arrays.asList(<span class="number">20</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">22</span>, <span class="number">19</span>, <span class="number">49</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>));</span><br><span class="line">System.out.println(median.getM());</span><br></pre></td></tr></table></figure>
<p>我们代码认为的中位数没有明确要求总数为偶数时取较小还是较大，测试代码输出结果是<code>10</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/14/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8804%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/14/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8804%EF%BC%89/" itemprop="url">Java 基础系列（04）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-14T12:03:58+08:00">
                2023-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><p>泛型字面意思是广泛的类型，类、接口、方法代码可以应用于非常广泛的类型，代码与它们能够操作的数据类型不再绑定在一起。下面看一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是一个简单的泛型例子，这边的<code>T</code>是类型参数，泛型就是类型参数化，处理的数据类型不是固定的而是可以作为参数传入的。使用时直接用<code>Pair&lt;Integer&gt; pair = new Pair&lt;Integer&gt;(1)</code>来创建带泛型的类对象，我们使用<code>pair.getData()</code>方法返回的数据直接就是<code>Integer</code>类型。<br>参数类型可以有多个，多个类型之间使用逗号隔开：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;U, V&gt; &#123;</span><br><span class="line">    U first;</span><br><span class="line">    V second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(U first, V second)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> U <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getSecond</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建对象的时候可以使用<code>Pair&lt;Integer, String&gt; pair = new Pair&lt;Integer, String&gt;(1, &quot;张三&quot;) </code>，从 Java7 开始<code>new</code>后面的泛型可以省略以简洁代码：<code>Pair&lt;Integer, String&gt; pair = new Pair&lt;&gt;(1, &quot;张三&quot;) </code>。<br>上面带泛型的类创建对象的时候，传递的类型可以是任意的，按需传递。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>对于上面的例子，如果没有泛型机制我们也是可以实现的，以第一个例子看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    Object data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 使用强转变为原类型</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> (Integer) pair.getData();</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure>

<p>我们直接使用<code>Object</code>作为数据类型也可以实现类似的功能，只是稍微麻烦一点。实际上编译器内部也是这么做的，它会将含有泛型的代码转化成不含泛型的代码。主要是将泛型参数<code>T</code>之类的<strong>擦除</strong>，将其转化成<code>Object</code>，然后插入必要的强制类型转换。当代码进入虚拟机运行的时候，是没有泛型的概念的。<br>既然这样为什么不直接使用<code>Object</code>？泛型是 Java5 开始支持的，这么设计也是为了兼容性。泛型有两个主要的好处：更好的安全性和更好的可读性。<br>可读性可以理解，安全性可以使用一个例子看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) pair.getData();</span><br></pre></td></tr></table></figure>
<p>因为 data 是<code>Object</code>类型，所以强转成<code>String</code>不会报语法错误，但是实际上运行时会报错。<br>如果使用泛型就不会发生这样的问题，因为如果接受变量的类型不一致会直接编译出错。</p>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>除了类可以泛型，方法也可以使用泛型。注意，方法是否泛型与其所在类是否泛型无关：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">index</span><span class="params">(T[] arr, T ele)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i].equals(ele)) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法就是一个泛型方法，类型参数是<code>T</code>，定义在返回值类型的前面。我们可以有如下调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index(<span class="keyword">new</span> <span class="title class_">Integer</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, <span class="number">4</span>);</span><br><span class="line">index(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;卢研&quot;</span>, <span class="string">&quot;刘妙霞&quot;</span>&#125;, <span class="string">&quot;卢研&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>index</code>是一种算法，一种在数组里面寻找元素的算法，与具体数据类型无关。和泛型类相似，泛型方法也可以定义多个泛型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U,V&gt; Pair&lt;U,V&gt; <span class="title function_">makePair</span><span class="params">(U first, V second)</span>&#123;</span><br><span class="line">    Pair&lt;U,V&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(first, second);</span><br><span class="line">    <span class="keyword">return</span> pair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与泛型类不同，我们在调用泛型方法的时候不需要指定具体的类型进去，因为根据函数参数能够推断出泛型的具体类型。就好比可以直接写<code>makePair(1,&quot;卢研&quot;)</code>而不需要<code>makePair&lt;Integer, String&gt;(1,&quot;卢研&quot;)</code>，实际上后者的写法是错误的。</p>
<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>接口也可以使用泛型，之前介绍的<code>Comparable</code>和<code>Comparator</code>接口都使用了泛型。它们代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T o)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现接口的时候需要指定具体的类型，例如对于<code>Integer</code>来说，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Integer</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Integer anotherInteger)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> compare(<span class="built_in">this</span>.value, anotherInteger.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型参数限定"><a href="#类型参数限定" class="headerlink" title="类型参数限定"></a>类型参数限定</h4><p>根据之前的理解，我们把泛型参数当做<code>Object</code>，这个范围太大了。Java 支持给这个泛型添加一个上限，使用关键字<code>extends</code>实现。</p>
<h5 id="上界是具体类"><a href="#上界是具体类" class="headerlink" title="上界是具体类"></a>上界是具体类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;</span><br><span class="line">    T one, two;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T one, T two)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.one = one;</span><br><span class="line">        <span class="built_in">this</span>.two = two;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> one.doubleValue() + two.doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这个类仍然是泛型类，不过我们对泛型参数<code>T</code>设置了一个上限<code>Number</code>。这样变量<code>one</code>和<code>two</code>就可以当做<code>Number</code>处理，创建对象时传递的类型必须要是<code>Number</code>及其子类。限定类型之后，如果类型使用不匹配会报错。<br>指定边界之后，泛型擦除时不会转换成<code>Object</code>而会转换成它的边界类型。</p>
<h5 id="上界是接口"><a href="#上界是接口" class="headerlink" title="上界是接口"></a>上界是接口</h5><p>在实际使用中，一种很常见的场景是限定类型必须实现<code>Comparable</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">max</span><span class="params">(T[] arr)</span>&#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].compareTo(max)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边使用泛型方法举例子，方法功能是返回数组里面的最大的元素。数组元素的类型只要实现了<code>Comparable</code>接口即可。注意，泛型参数继承<code>Comparable&lt;T&gt;</code>表示类型<code>T</code>必须能够与同一类型的其它元素比较。</p>
<h5 id="上界是其它类型参数"><a href="#上界是其它类型参数" class="headerlink" title="上界是其它类型参数"></a>上界是其它类型参数</h5><p>Java 还支持一个类型参数以另一个类型参数作为上界，为什么需要这个功能，我们使用例子一步步看。首先我们自己实现一个低配版的<code>ArrayList</code>命名为<code>MyList</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> Object[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_SIZE];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T ele)</span> &#123;</span><br><span class="line">        ensureCapacity(size + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">this</span>.arr[size++] = ele;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="built_in">this</span>.arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity &gt;= minCapacity) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; minCapacity)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        arr = Arrays.copyOf(arr, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类主要方法就是<code>add</code>和<code>get</code>，因为不存在<code>new T[SIZE]</code>这样的写法，所以数组被定义为<code>Object</code>类型。下面我们想要添加一个新方法<code>addAll</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(MyList&lt;T&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size; ++i) &#123;</span><br><span class="line">        add(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码实现比较简单，一切似乎都没有问题。那我们看下面的使用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyList&lt;Number&gt; list1 = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;&gt;();</span><br><span class="line">MyList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;&gt;();</span><br><span class="line">list1.addAll(list2);  <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>
<p>正如注释所说，代码编译错误。错误的原因是参数需要<code>MyList&lt;Number&gt;</code>，传进来的却是<code>MyList&lt;Integer&gt;</code>。按理来说，<code>Integer</code>是<code>Number</code>类的子类，将一些<code>Integer</code>放到<code>Number</code>数组里面也是合情合理。为什么不能把<code>MyList&lt;Integer&gt;</code>也看成<code>MyList&lt;Number&gt;</code>的子类呢？假设可以看成子类，我们再看另一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;&gt;();</span><br><span class="line">MyList&lt;Number&gt; list = list2;  <span class="comment">// 假设这么写成立</span></span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">3.14</span>));  <span class="comment">// 那么按照假设，这样写也是没错的</span></span><br></pre></td></tr></table></figure>
<p>所以从这个例子也可以看出，严格区分不同泛型类是很有必要的。<br>回到原来的案例，我想实现<code>addAll</code>方法能够传递<code>MyList&lt;Integer&gt;</code>怎么办？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E <span class="keyword">extends</span> <span class="title class_">T</span>&gt; <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(MyList&lt;E&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size; ++i) &#123;</span><br><span class="line">        add(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以实现了。</p>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><h5 id="有限定通配符"><a href="#有限定通配符" class="headerlink" title="有限定通配符"></a>有限定通配符</h5><p>通配符<code>?</code>大量应用于 Java 容器类里面，它往往能够简化参数类型的限定，下面我使用通配符简化上面<code>addAll</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(MyList&lt;? extends T&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size; ++i) &#123;</span><br><span class="line">        add(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法里面<code>?</code>是<strong>有限定通配符</strong>，它表示匹配<code>T</code>或<code>T</code>的某个子类，具体是哪个子类不知道，是一种抽象的概念。下面我们对比一下<code>&lt;E extends T&gt;</code>和<code>&lt;? extends T&gt;</code>：</p>
<ul>
<li><code>&lt;E entends T&gt;</code>用于定义类型参数，它声明了一个类型<code>E</code>。</li>
<li><code>&lt;? extends T&gt;</code>用于实例化类型参数，定义泛型变量的时候可以使用它。</li>
</ul>
<p>注意，通配符使用于定义变量的地方，就像上面的形参<code>MyList&lt;? extends T&gt; list</code>。</p>
<h5 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h5><p>除了有限定通配符，还有<strong>无限定通配符</strong><code>&lt;?&gt;</code>，它可以匹配任意<code>Object</code>及其子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(MyList&lt;E&gt; arr)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(MyList&lt;?&gt; arr)</span></span><br></pre></td></tr></table></figure>
<p>上面的两种写法可以得到一样的效果，所以通配符的一个好处就是可以简化泛型代码。但通配符并不是万能的，是有限制的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyList&lt;?&gt; list = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;Number&gt;();  <span class="comment">// 合法，? 可以匹配 Number</span></span><br><span class="line"></span><br><span class="line"><span class="type">Number</span> <span class="variable">n</span> <span class="operator">=</span> list.get(<span class="number">0</span>);  <span class="comment">// 错误，因为返回值类型是 ? 而不是 Number</span></span><br><span class="line"><span class="type">Number</span> <span class="variable">n</span> <span class="operator">=</span> (Number) list.get(<span class="number">0</span>);  <span class="comment">// 正确，我们知道实际类型是 Number，所以可以强转</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，因为形参需要 ? 而传递一个 Double；</span></span><br><span class="line"><span class="comment">// 这种情况下甚至无法强转，因为怎么把 Double 强转成 ?</span></span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">3.14</span>));</span><br><span class="line"></span><br><span class="line">list.add(list.get(<span class="number">0</span>));  <span class="comment">// 这样也不行</span></span><br></pre></td></tr></table></figure>
<p>其实添加这些限制也能理解，因为<code>list</code>的静态类型是<code>MyList&lt;?&gt;</code>，那么添加的时候即可以添加<code>Integer</code>也可以添加<code>String</code>，这很显然是不合理的。<br>总结下来，当我们关注泛型里的类型的时候就不能使用通配符，否则就使用通配符。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(T[] arr, T ele)</span></span><br></pre></td></tr></table></figure>
<p>这个函数就没办法写成通配符形式，因为我们需要<code>T</code>这个类型定义形参。<br>当需要多种类型且类型之间有依赖关系的时候也不能使用通配符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;D, S <span class="keyword">extends</span> <span class="title class_">D</span>&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(MyList&lt;D&gt; dest, MyList&lt;S&gt; src)</span></span><br></pre></td></tr></table></figure>
<p>虽然这种情况无法使用通配符完全替换，但可以使用通配符简化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;D&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(MyList&lt;D&gt; dest, MyList&lt;? extends D&gt; src)</span></span><br></pre></td></tr></table></figure>
<h5 id="超类型通配符"><a href="#超类型通配符" class="headerlink" title="超类型通配符"></a>超类型通配符</h5><p>与<code>&lt;? extends T&gt;</code>刚好相反，超类型通配符形式为<code>&lt;? super T&gt;</code>，它匹配<code>T</code>的某种父类型。举个例子，我们希望在上面列表里面加一个方法<code>copyTo</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyTo</span><span class="params">(MyList&lt;T&gt; dest)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        dest.add(get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法就是把列表里面的元素全部添加到<code>dest</code>列表里面。我们写出下面的测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyList&lt;Integer&gt; ints = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;&gt;();</span><br><span class="line">MyList&lt;Number&gt; numbers = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;&gt;();</span><br><span class="line">ints.copyTo(number);  <span class="comment">// 编译出错</span></span><br></pre></td></tr></table></figure>
<p>方法需要的是<code>MyList&lt;Integer&gt;</code>但实参是<code>MyList&lt;Number&gt;</code>，类型不匹配。但实际上把一堆<code>Integer</code>存到<code>Number</code>数组里面是很合理的操作，此时只需要把形参改为<code>MyList&lt;? super T&gt; dest</code>即可。<br> 超通配符的另一种常见使用场景是<code>Comparable/Comparator</code>接口。我们先定义一个求最大值的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;E&gt;&gt; E <span class="title function_">max</span><span class="params">(MyList&lt;E&gt; arr)</span> &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">ans</span> <span class="operator">=</span> arr.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.size; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.get(i).compareTo(ans) &gt; <span class="number">0</span>) ans = arr.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再定义两个类，分别为<code>Base</code>和<code>Child</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Base&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sortOrder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">(<span class="type">int</span> sortOrder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sortOrder = sortOrder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Base o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortOrder - o.sortOrder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">(<span class="type">int</span> sortOrder)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(sortOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Base</code>实现了<code>Comparable&lt;Base&gt;</code>，<code>Child</code>没做特别说明，因为继承所以默认也是实现了<code>Comparable&lt;Base&gt;</code>。下面我们使用测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyList&lt;Child&gt; childs = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;&gt;();</span><br><span class="line">childs.add(<span class="keyword">new</span> <span class="title class_">Child</span>(<span class="number">20</span>));</span><br><span class="line">childs.add(<span class="keyword">new</span> <span class="title class_">Child</span>(<span class="number">80</span>));</span><br><span class="line"><span class="type">Child</span> <span class="variable">maxChild</span> <span class="operator">=</span> MyList.max(childs);  <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure>
<p>我们想求<code>Child</code>列表里的最大值，所以把<code>childs</code>作为参数传进<code>max</code>方法。<code>max</code>解析的时候认为<code>E</code>是<code>Child</code>，而<code>Child</code>类并不满足<code>&lt;E extends Comparable&lt;E&gt;&gt;</code>。即<code>Child</code>并没有实现<code>Comparable&lt;Child&gt;</code>，而实际上我们知道这边父类的比较规则完全可以适配到子类上来，对<code>Child</code>列表找最大值是很合理的操作。因此修改函数签名为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> E&gt;&gt; E <span class="title function_">max</span><span class="params">(MyList&lt;E&gt; arr)</span></span><br></pre></td></tr></table></figure>
<p>只有在通配符才能使用<code>super</code>表示父级，常规的类型参数写法是不支持这样的。</p>
<h5 id="通配符小结"><a href="#通配符小结" class="headerlink" title="通配符小结"></a>通配符小结</h5><p>目前一共介绍了<code>&lt;?&gt;</code>、<code>&lt;? extends E&gt;</code>、<code>&lt;? super E&gt;</code>这三种通配符，下面进行比较：</p>
<ol>
<li>它们的目的都是为了使接口或方法更灵活，可以接受更广的类型。</li>
<li><code>&lt;? super E&gt;</code>用于灵活写入或比较，使对象可以写进父类型的容器，使父类型的比较方法可以应用于子类型，它不能被类型参数形式代替。</li>
<li><code>&lt;? extends E&gt;</code>用于灵活读取，使方法可以读取任何<code>E</code>及其子类型的容器对象，它可以用类型参数形式替代，但用通配符更简洁。</li>
</ol>
<p>Java 里面有很多通配符的例子，在<code>Collections</code>类中就有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">max</span><span class="params">(Collection&lt;? extends T&gt; coll, Comparator&lt;? <span class="built_in">super</span> T&gt; comp)</span></span><br></pre></td></tr></table></figure>
<h4 id="细节和局限"><a href="#细节和局限" class="headerlink" title="细节和局限"></a>细节和局限</h4><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><p>因为 Java 泛型本质上是擦除，是将类型改为<code>Object</code>或上限类型。所以泛型里面不能使用基本数据类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyList&lt;<span class="type">int</span>&gt; ints = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;<span class="type">int</span>&gt;();  <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>
<p>这种写法是错误的，不能使用基本数据类型作为泛型参数。对于这个问题我们可以使用基本数据类型对应的包装类型。</p>
<h5 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h5><p>之前讲过，每个类在内存里都有一份类型信息，而创建出来的每一个对象都包含着这个类型信息的引用。这个类型信息实际上也是一个对象，它的类型是<code>Class</code>，我们可以通过<code>类名.class</code>或<code>对象.getClass()</code>来获取类信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; cs = <span class="string">&quot;&quot;</span>.getClass();</span><br><span class="line">Class&lt;?&gt; cs2 = String.class;</span><br></pre></td></tr></table></figure>
<p>注意，类型信息与泛型无关，所以类似于<code>Pair&lt;Integer&gt;.class</code>的写法是错误的，我们应该直接使用<code>Pair.class</code>。同一个泛型类的对象即使泛型不同，它们获取的类信息是一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer&gt; p1 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;();</span><br><span class="line">Pair&lt;String&gt; p2 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;();</span><br><span class="line">print(Pair.class == p1.getClass());  <span class="comment">//true</span></span><br><span class="line">print(p1.getClass() == p2.getClass());  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>原因很简单，类型擦除会将所有类型改为<code>Object</code>，所以即使泛型不一样，类信息实际上是一样的。</p>
<h5 id="一些冲突"><a href="#一些冲突" class="headerlink" title="一些冲突"></a>一些冲突</h5><p>我们看之前的一个例子，有两个类<code>Base</code>和<code>Child</code>，它们的签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Base&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span></span><br></pre></td></tr></table></figure>
<p>这边<code>Child</code>没有直接实现<code>Comparable</code>接口，比较使用的是父类那一套逻辑。如果子类的比较需要自定义怎么办，直觉上可以让子类再实现一次：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Child&gt; &#123;</span><br><span class="line">	<span class="comment">// 主体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但实际上是错误的，因为一个接口不能实现两次。当子类继承父类的时候默认就实现了一次接口，这边再实现就重复了。注意<code>Comparable&lt;Base&gt;</code>和<code>Comparable&lt;Child&gt;</code>是同一个接口，因为类型擦除之后它们都相当于<code>Comparable</code>。那我却是需要修改怎么办呢？可以重写接口方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Base o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Child))&#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> (Child)o;</span><br><span class="line">        <span class="comment">// 比较逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后关于重载，你可能会认为下面的重载是成立的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(MyList&lt;Integer&gt; intArr)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(MyList&lt;String&gt; strArr)</span></span><br></pre></td></tr></table></figure>
<p>实际上是不成立的，仍然是类型擦除搞的鬼。擦完之后，两个方法的形参类型都变为了<code>MyList</code>，所以重载失败。</p>
<h5 id="定义泛型类"><a href="#定义泛型类" class="headerlink" title="定义泛型类"></a>定义泛型类</h5><p>不能使用类型参数创建对象，如下代码是错误的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">T</span> <span class="variable">elm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();  <span class="comment">// 错误</span></span><br><span class="line">T[] arr = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">10</span>];  <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>其实很好理解，当我们写这样的代码的时候，我们预期是创建对应类型的对象，但实际上因为类型擦除创建的却是<code>Object</code>对象，产生了冲突。<br>除此之外，静态变量或静态方法里面不能使用类型参数，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> T elm;  <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title function_">func</span><span class="params">()</span> &#123;  <span class="comment">// 错误</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态变量和静态方法是属于类级别的，不管有多少对象都共享这一份。如果允许上面的写法，那么对于不同的类型<code>T</code>都需要一份对应的静态变量或方法，这就冲突了。<br>Java 泛型的上限可以有多个的，多个上限之间使用<code>&amp;</code>分隔：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> <span class="title class_">Base</span> &amp; Comparable &amp; Serializable</span><br></pre></td></tr></table></figure>
<p>如果有上界类，那么类应该放第一个。类型擦除的时候会使用第一个上界替换。</p>
<h5 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h5><p>泛型是不能创数组的，例如下面的代码是不允许的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer&gt;[] list = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;Integer&gt;[<span class="number">5</span>];  <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>为什么不允许呢？如果是允许的，那么下面的代码就是对的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] os = list;</span><br><span class="line">os[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String&gt;();  <span class="comment">// 类型和一开始定义的就不同了</span></span><br></pre></td></tr></table></figure>
<p>这很显然就出现问题了，所以泛型是不允许创建数组的，如果真的需要怎么办？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair[] list = <span class="keyword">new</span> <span class="title class_">Pair</span>[<span class="number">5</span>];</span><br><span class="line">MyList&lt;Pair&lt;String&gt;&gt; options = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>我们可以直接使用原始类型的数组替代，或者使用容器类。</p>
<h3 id="列表和队列"><a href="#列表和队列" class="headerlink" title="列表和队列"></a>列表和队列</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p><code>ArrayList</code>是泛型容器，和我们上面实现的<code>MyList</code>类似但更强：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p><code>ArrayList</code>的主要方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>  <span class="comment">// 添加元素到末尾</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>  <span class="comment">// 判断容器 size 是否为 0</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>  <span class="comment">//឴ 返回元素个数</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>  <span class="comment">// 返回下标 index 处的元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span>  <span class="comment">// 查找元素，找到返回下标否则返回 -1</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span>  <span class="comment">// 从后往前查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>  <span class="comment">// 判断元素是否存在于容器里面，使用 equals 作为依据</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>  <span class="comment">// 删除指定下标的元素并返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定元素，使用 equals 作为依据，返回是否删除了元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>  <span class="comment">// 删除全部元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>  <span class="comment">// 在指定下标处插入元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span>  <span class="comment">// 修改指定位置的元素</span></span><br></pre></td></tr></table></figure>
<p>方法及使用很简单，不多说。</p>
<h5 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h5><p>和我们上面实现的<code>MyList</code>类似，<code>ArrayList</code>内部也是维护一个数组存储数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure>
<p><code>elementData</code>就是存储数据的数组，会随着元素的增加而扩增；<code>size</code>表示元素的个数。</p>
<h6 id="add和remove"><a href="#add和remove" class="headerlink" title="add和remove"></a>add和remove</h6><p>数组的<code>add</code>方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">	<span class="comment">// 确保容量充足</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 分配的空间最少也要 DEFAULT_CAPACITY 个，默认是 10 个</span></span><br><span class="line">    <span class="keyword">if</span>(elementData == EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    	minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span>(minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    	grow(minCapacity);  <span class="comment">// 分配空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// &gt;&gt;1 等价于 ÷2，所以扩容为原来的 1.5 倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 容量不足 minCapacity 就使用 minCapacity</span></span><br><span class="line">    <span class="keyword">if</span>(newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    	newCapacity = minCapacity;</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面<code>modCount</code>变量用来记录内部结构性变化的次数，结构性变化包含增加和删除，修改元素不算。<br>数组<code>remove</code>方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">	<span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;  <span class="comment">// 计算要移动的元素个数</span></span><br><span class="line">    <span class="keyword">if</span>(numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    	System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>;  <span class="comment">// 置 null 取消引用便于垃圾回收</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h6><p>除了普通 for 循环，我们还可以使用 foreach 循环来遍历<code>ArrayList</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;卢研&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;刘妙霞&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String name : list) &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上背后编译器会把代码转化成下面的样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但我们会更倾向于使用 	foreach 循环，因为它更简洁。<br><code>ArrayList</code>实现了<code>Iterable</code>接口，它表示可迭代的。定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">	Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口内有一个方法需要返回<code>Iterator&lt;T&gt;</code>即迭代器，迭代器内部包含：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;  <span class="comment">// 是否还有元素未访问</span></span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;  <span class="comment">// 返回下一个元素</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;  <span class="comment">// 删除最后访问的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要类实现了<code>Iterable</code>接口就可以使用 foreach 循环遍历。除了<code>iterator()</code>方法，<code>ArrayList</code>还提供了两个<code>listIterator</code>方法用来返回<code>ListIterator</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span></span><br></pre></td></tr></table></figure>
<p><code>ListIterator</code>是对<code>Iterator</code>的扩展，主要添加了以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ListIterator</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">previous</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>listIterator()</code>方法返回的迭代器从下标<code>0</code>开始，<code>listIterator(int index)</code>方法返回的迭代器从指定下标<code>index</code>开始。当我们想要倒序遍历的时候，可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ListIterator&lt;String&gt; it = list.listIterator(list.size());</span><br><span class="line"><span class="keyword">while</span> (it.hasPrevious()) &#123;</span><br><span class="line">    System.out.println(it.previous());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="迭代的陷阱"><a href="#迭代的陷阱" class="headerlink" title="迭代的陷阱"></a>迭代的陷阱</h6><p>假设我们有需求，在一个整型<code>ArrayList</code>里面，我想在遍历的同时删除值小于 100 的元素，我们的直觉是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">99</span>);</span><br><span class="line">list.add(<span class="number">100</span>);</span><br><span class="line">list.add(<span class="number">101</span>);</span><br><span class="line"><span class="keyword">for</span> (Integer a : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= <span class="number">100</span>) list.remove(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是运行的时候会报错<code>java.util.ConcurrentModificationException</code>，这个称为并发修改错误。因为迭代器内部维护了一些与索引相关的变量，这要求在迭代的过程中列表不能发生结构性变化（增加和删除），否则这些变量就失效了。想要避免异常可以这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it.next() &lt; <span class="number">100</span>) it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于它是怎么在迭代过程中知道列表发生了结构性变化以及为什么它自己的<code>remove</code>方法就可以避免，看下面迭代器的原理。</p>
<h6 id="迭代器的原理"><a href="#迭代器的原理" class="headerlink" title="迭代器的原理"></a>迭代器的原理</h6><p>我们看<code>ArrayList</code>的<code>iterator()</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它返回了<code>Itr</code>对象，这是一个静态内部类，它的签名是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>这个类有 3 个实例成员变量，分别是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cursor;  <span class="comment">// 下一个要返回元素的下标</span></span><br><span class="line"><span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>;  <span class="comment">// 最后访问元素的下标，默认是 -1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;  <span class="comment">// 记录当前列表经历结构性变化的次数</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是<code>expectedModCount</code>变量，每次调用<code>next()</code>方法最开始都会比对<code>expectedModCount</code>和<code>modCount</code>，用来检查列表在遍历期间是否有结构性变化。<br>接下来我们看<code>hasNext()</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> cursor != size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个非常容易理解，不多说。下面是<code>next()</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= size)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= elementData.length)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(modCount != expectedModCount)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>checkForComodification</code>方法判断列表是否发生结构性变化；<code>next</code>方法更新对应索引并返回访问的元素。<br>最后看看<code>remove()</code>方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(lastRet &lt; <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码不难，主要是更新几个变量。因为使用这个方法删除会更新<code>expectedModCount</code>所以不会因为发生结构性变化而报错。但是有一点需要注意，每次删除之后都会将<code>lastRet</code>置为 -1，所以下面继续删除会抛异常。因此我们每次调用<code>remove</code>方法之前必须先调用<code>next</code>方法。</p>
<h5 id="实现的接口"><a href="#实现的接口" class="headerlink" title="实现的接口"></a>实现的接口</h5><h6 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h6><p><code>Collection</code>是集合接口，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>;</span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    Object[] toArray();</span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大部分方法我们都看过，下面介绍几个<code>xxxAll</code>方法：</p>
<ol>
<li><code>addAll</code>方法表示添加参数集合<code>c</code>中的所有元素。</li>
<li><code>removeAll</code>方法删除所有存在于参数集合<code>c</code>里的元素。</li>
<li><code>retainAll</code>方法仅保留存在于参数集合<code>c</code>里的元素。</li>
<li><code>containsAll</code>方法返回当前集合是否完全包含给定的集合<code>c</code>。</li>
</ol>
<p>上面的方法涉及比较的时候都是使用<code>equals</code>进行比较。</p>
<h6 id="List"><a href="#List" class="headerlink" title="List"></a>List</h6><p><code>List</code>表示有顺序的集合，是对<code>Collection</code>的扩展，主要增加了以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span>;</span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>;</span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span>;</span><br><span class="line">ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span>;</span><br><span class="line">ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span>;</span><br></pre></td></tr></table></figure>
<h6 id="RandomAccess"><a href="#RandomAccess" class="headerlink" title="RandomAccess"></a>RandomAccess</h6><p><code>RandomAccess</code>是随机访问接口，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RandomAccess</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个空接口，主要用来声明类具有一种性质，这边主要表示实现的类具有随机访问的性质。</p>
<h5 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h5><p><code>ArrayList</code>还有额外的两个有参构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>第一个构造能传递一个初始化数组大小进去，在一些能够提前预知列表大小的时候可以使用。第二个构造会根据一个已有的<code>Collection</code>创建，数据会复制一份。<br><code>ArrayList</code>有两个方法可以返回数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray()</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a)</span><br></pre></td></tr></table></figure>
<p>第一个方法直接返回一个<code>Object</code>数组，它的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">	<span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个方法返回对应类型的数组，若是传递的数组<code>a</code>够大就把元素复制进去，要是不够大就新开一个数组返回，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">// Make a new array of a&#x27;s runtime type, but my contents:</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Arrays</code>类中有一个静态方法<code>asList</code>可以将数组转换成列表，但是返回的列表不是我们这边的<code>ArrayList</code>，而是<code>Arrays</code>类里面的一个内部类。在这个内部类的实现中，数组直接使用传进去的数组，也不能动态改变大小，对它调用<code>add</code>和<code>remove</code>会抛异常。因此正确使用<code>asList</code>的方法应该是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(a));</span><br></pre></td></tr></table></figure>
<p>除此之外，还有两个方法用来控制内部数组的大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span></span><br></pre></td></tr></table></figure>
<p>第一个方法会将大小缩减到和元素个数一样多，用来节省空间；第二个方法用来确保列表大小至少为<code>minCapacity</code>，如果不够会进行扩展。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><code>**ArrayList**</code><strong>是线程不安全的</strong>，<code>Vector</code>是一个原理和<code>ArrayList</code>差不多但使用<code>synchronized</code>关键字实现线程安全的类。<code>ArrayList</code>有以下几个特点：</p>
<ol>
<li>因为内部使用数组，所以可以随机访问，按照下标获取元素效率很高。</li>
<li>添加元素效率一般，不超出容量的时候很快，超出容量要重开数组空间较慢。</li>
<li>插入和删除元素很慢，因为需要移动元素。</li>
</ol>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p><code>LinkedList</code>是基于链表实现的列表类，它随机访问效率很低，但插入和删除效率很高。它除了实现<code>List</code>接口还实现了<code>Deque</code>和<code>Queue</code>接口。可以按照栈、队列、双端队列的方式操作它。</p>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><h6 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h6><p><code>LinkedList</code>有两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>第一个是默认的构造，第二个接受一个集合作为参数。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;));</span><br></pre></td></tr></table></figure>
<h6 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h6><p><code>LinkedList</code>实现了<code>List</code>接口，<code>List</code>扩展了<code>Collection</code>接口，所以这些接口里的方法都是可以使用的。除此之外，还实现了<code>Queue</code>接口，下面看看接口内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>;</span><br><span class="line">    E <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">poll</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">element</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">peek</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Queue</code>扩展了<code>Collection</code>接口，主要的操作有三种：</p>
<ol>
<li>在尾部添加元素（<code>add</code>、<code>offer</code>）；</li>
<li>删除并返回头部元素（<code>remove</code>、<code>poll</code>）；</li>
<li>查看头部元素（<code>element</code>、<code>peek</code>）；</li>
</ol>
<p>每种操作都有两个方法实现，它们的主要差别就是当队列为空或为满的时候，一种会报错，另一种不会：</p>
<ul>
<li>队列为空时<code>element、remove</code>会抛异常<code>NoSuchElementException</code>，而<code>peek、poll</code>则是返回<code>null</code>。</li>
<li>队列满的时候<code>add</code>抛异常<code>IllegalStateException</code>，而<code>offer</code>则是返回<code>false</code>。</li>
</ul>
<p>把<code>LinkedList</code>当做队列操作的简单例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">queue.offer(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">queue.offer(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">queue.offer(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(queue.peek()!=<span class="literal">null</span>)&#123;</span><br><span class="line">	System.out.println(queue.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h6><p>栈是另一种使用比较频繁的数据结构，它的特点是后进先出。栈没有单独的接口，它的一些操作定义在双端队列<code>Deque</code>中，主要方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span>;  <span class="comment">// 头部添加元素，栈满则抛 IllegalStateException 异常</span></span><br><span class="line">E <span class="title function_">pop</span><span class="params">()</span>;  <span class="comment">// 删除并返回头部元素，栈为空抛 NoSuchElementException 异常</span></span><br><span class="line">E <span class="title function_">peek</span><span class="params">()</span>;  <span class="comment">// 查看栈头部元素，栈为空返回 null</span></span><br></pre></td></tr></table></figure>
<p>把<code>LinkedList</code>当做栈操作的简单例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">stack.push(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(stack.peek()!=<span class="literal">null</span>)&#123;</span><br><span class="line">	System.out.println(stack.pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 里有<code>Stack</code>类表示栈，这个类是<code>Vector</code>的子类，没有实现<code>Deque</code>。它使用<code>synchronized</code>关键字实现了线程安全，也因此操作效率低，所以不要求线程安全的情况下不建议使用。</p>
<h6 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h6><p><code>Deque</code>可以操作两端，除了栈操作，它还定义了如下更明确的双端操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span>;</span><br><span class="line">E <span class="title function_">getFirst</span><span class="params">()</span>;</span><br><span class="line">E <span class="title function_">getLast</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span>;</span><br><span class="line">E <span class="title function_">peekFirst</span><span class="params">()</span>;</span><br><span class="line">E <span class="title function_">peekLast</span><span class="params">()</span>;</span><br><span class="line">E <span class="title function_">pollFirst</span><span class="params">()</span>;</span><br><span class="line">E <span class="title function_">pollLast</span><span class="params">()</span>;</span><br><span class="line">E <span class="title function_">removeFirst</span><span class="params">()</span>;</span><br><span class="line">E <span class="title function_">removeLast</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p><code>xxxFirst</code>表示操作头部，<code>xxxLast</code>表示操作尾部。每种操作有两种形式，含义和上面一样，一种会报错，一种不会。队列空时，使用<code>getXXX</code>或<code>removeXXX</code>会抛异常，而<code>peekXXX</code>或<code>pollXXX</code>则会返回<code>null</code>；队列满时，使用<code>addXXX</code>会抛异常，而使用<code>offerXXX</code>会返回<code>false</code>。<br><code>Deque</code>还有一个迭代器方法，可以返回一个从后往前遍历的迭代器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; <span class="title function_">descendingIterator</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><code>LinkedList</code>内部实现使用的是双向链表，链表节点是一个内部类，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LinkedList</code>内部主要维护三个成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 节点数量</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;  <span class="comment">// 头节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;  <span class="comment">// 为节点</span></span><br></pre></td></tr></table></figure>
<p>下面主要看一些函数的源码。</p>
<h6 id="add"><a href="#add" class="headerlink" title="add"></a>add</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">null</span>)</span><br><span class="line">    	first = newNode;</span><br><span class="line">    <span class="keyword">else</span> l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出<code>add</code>是直接往尾部插入一个节点，与<code>ArrayList</code>类似，<code>modCount</code>也是用来记录链表结构化改变次数的。</p>
<h6 id="get"><a href="#get" class="headerlink" title="get"></a>get</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(index);  <span class="comment">// 检查要插入的下标是否合法</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkElementIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!isElementIndex(index))</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isElementIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">   		Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">        	x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">        x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>get</code>方法的核心是调用<code>node(index)</code>方法，这个方法会判断要查找下标在链表的前半段还是后半段，然后确定从前往后还是从后往前查找。从这也能看出，链表的随机访问效率是很低的。</p>
<h6 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span>(x.item == <span class="literal">null</span>)</span><br><span class="line">            	<span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span>(o.equals(x.item))</span><br><span class="line">            	<span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按元素查找就是直接从前往后查找，使用<code>equals</code>判断元素是否相同。</p>
<h6 id="插入-add"><a href="#插入-add" class="headerlink" title="插入 add"></a>插入 add</h6><p><code>add</code>还有一个重载方法表示在指定下标处插入，源码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="keyword">if</span>(index == size)</span><br><span class="line">    	linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span>(pred == <span class="literal">null</span>)</span><br><span class="line">    	first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，找到要插入位置的元素，在其前面插入。</p>
<h6 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">    <span class="keyword">if</span>(prev == <span class="literal">null</span>) &#123;</span><br><span class="line">    	first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(next == <span class="literal">null</span>) &#123;</span><br><span class="line">    	last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单总结：<code>ArrayList</code>使用数组实现，因此比较适合频繁需要按照下标访问元素的情况，不适合大量删除或插入的情况；<code>LinkedList</code>相反，适合频繁插入或删除而不适合随机访问的情况。</p>
<h4 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h4><p>除了<code>LinkedList</code>，Java 里还有一个类<code>ArrayDeque</code>实现了双向队列<code>Deque</code>。<code>ArrayDeque</code>内部使用数组存储数据，按道理说对于删除和添加数组效率很低。但<code>ArrayList</code>使用循环数组提高效率，所谓循环数组就是在逻辑上将数组尾部与数组头部相连。</p>
<h5 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h5><p><code>ArrayDeque</code>有三种构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(<span class="type">int</span> numElements)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>这些构造的含义很好推测，不过对于有参构造，传递进去的<code>numElements</code>并不直接是数组的大小。<br>因为实现了<code>Deque</code>，所以对于栈运用<code>push、pop、peek</code>方法，也有明确的双端队列的方法<code>addFirst</code>等，这些方法及用法和上面讲的是一样的，不多说。</p>
<h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><h6 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h6><p><code>ArrayDeque</code>主要维护下面几个成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> E[] elements;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> tail;</span><br></pre></td></tr></table></figure>
<p>我们将数组逻辑上看成一个环，然后通过移动<code>head</code>和<code>tail</code>来避免删除时大量移动剩余元素。Java 的循环数组将<code>tail</code>理解成下一个元素的下标，因此当<code>head = tail</code>时表示队列为空。<br>下面看看各构造的内部实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">()</span> &#123;</span><br><span class="line">	elements = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">16</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出无参构造默认分配 16 个空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(<span class="type">int</span> numElements)</span> &#123;</span><br><span class="line">	allocateElements(numElements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个构造调用<code>allocateElements</code>方法来分配空间，分配空间大小逻辑比较复杂，总结来说：至少分配 8 个空间，需要的大于等于 8 个时，分配的个数一定是 2 的次幂且严格大于需要的空间数。举个例子：<code>4=&gt;8</code>、<code>8=&gt;16</code>、<code>25=&gt;32</code>。为什么要严格大于所需的空间，因为循环数组的性质决定了能使用的空间数等于分配的空间数减一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    allocateElements(c.size());</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先按需分配空间，再将集合的元素添加到队列中，<code>addAll</code>内部就是循环调用<code>add</code>方法。</p>
<h6 id="add-1"><a href="#add-1" class="headerlink" title="add"></a>add</h6><p><code>add</code>是往尾部添加元素，看下面源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(e == <span class="literal">null</span>)  <span class="comment">// 不能添加 null</span></span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    elements[tail] = e;</span><br><span class="line">    <span class="keyword">if</span>( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)</span><br><span class="line">    	doubleCapacity();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doubleCapacity</span><span class="params">()</span> &#123;  <span class="comment">// 这个函数执行的时候 head 和 tail 是重合的</span></span><br><span class="line">    <span class="keyword">assert</span> head == tail;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> elements.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> n - p;  <span class="comment">// number of elements to the right of p</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Sorry, deque too big&quot;</span>);</span><br><span class="line">    Object[] a = <span class="keyword">new</span> <span class="title class_">Object</span>[newCapacity];</span><br><span class="line">    System.arraycopy(elements, p, a, <span class="number">0</span>, r);  <span class="comment">// 先复制 head 后面的</span></span><br><span class="line">    System.arraycopy(elements, <span class="number">0</span>, a, r, p);  <span class="comment">// 再复制 tail 前面的</span></span><br><span class="line">    elements = (E[])a;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    tail = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出队列里面的元素都不为<code>null</code>，需要注意的是<code>tail = (tail+1) &amp; (elements.length-1)</code>。因为是循环数组，所以下标<code>n-1</code>后一个下标是<code>0</code>，<code>0</code>前一个下标是<code>n-1</code>。实现这个功能，我第一个想到的是使用<code>%</code>，但<code>%</code>效率很低，<strong>这边的写法需要配合数组容量是 2 的次幂</strong>。<br>假设数组容量是 8，那么<code>elements.length-1</code>的二进制就是<code>0111</code>。任何一个<code>0-7</code>以内的数与<code>0111</code>相与的结果都是这个数本身，相当于没做操作。考虑特殊情况，<code>tail=7</code>时，此时<code>tail+1=8=1000</code>，与<code>0111</code>相与结果是<code>0</code>；<code>tail=0</code>时，此时<code>tail-1=-1=1111</code>，与<code>0111</code>相与的结果是<code>7</code>。综上所述，<code>(tail±1) &amp; (elements.length-1)</code>都可以得出正确的位置。</p>
<h6 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst"></a>addFirst</h6><p><code>addFirst</code>是头部添加元素的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(e == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;</span><br><span class="line">    <span class="keyword">if</span>(head == tail) doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="removeFirst"><a href="#removeFirst" class="headerlink" title="removeFirst"></a>removeFirst</h6><p><code>removeFirst</code>是头部删除函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> pollFirst();</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> elements[h]; <span class="comment">//Element is null if deque empty</span></span><br><span class="line">    <span class="keyword">if</span>(result == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    elements[h] = <span class="literal">null</span>; <span class="comment">//Must null out slot</span></span><br><span class="line">    head = (h + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="size"><a href="#size" class="headerlink" title="size"></a>size</h6><p><code>size</code>是获取元素个数的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (tail - head) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h6><p><code>contains</code>方法用来判断元素是否存在于队列中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(o == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> elements.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> head;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">while</span>( (x = elements[i]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(o.equals(x))</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        i = (i + <span class="number">1</span>) &amp; mask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>head</code>开始遍历，使用<code>equals</code>方法作为比较依据。这边使用<code>null</code>作为结束标记而不是<code>tail</code>，因为有效元素一定不是<code>null</code>。</p>
<h6 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h6><p><code>toArray</code>方法返回队列数组的副本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">	<span class="keyword">return</span> copyElements(<span class="keyword">new</span> <span class="title class_">Object</span>[size()]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; T[] copyElements(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span>(head &lt; tail) &#123;</span><br><span class="line">    	System.arraycopy(elements, head, a, <span class="number">0</span>, size());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(head &gt; tail) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">headPortionLen</span> <span class="operator">=</span> elements.length - head;</span><br><span class="line">        System.arraycopy(elements, head, a, <span class="number">0</span>, headPortionLen);</span><br><span class="line">        System.arraycopy(elements, <span class="number">0</span>, a, headPortionLen, tail);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>head &gt; tail</code>的情况，先复制后面再复制前面的部分。这样能保证返回的数组元素是原来的顺序。<br>因为<code>Deque</code>接口里面没有根据下标的操作，所以<code>ArrayDeque</code>也不能按照索引操作数据。一般而言，<code>ArrayDeque</code>效率优于<code>LinkedList</code>，所有我们应该优先使用<code>ArrayList</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/02/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8803%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/02/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8803%EF%BC%89/" itemprop="url">Java 基础系列（03）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-02T12:03:55+08:00">
                2023-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="常用基础类"><a href="#常用基础类" class="headerlink" title="常用基础类"></a>常用基础类</h3><h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>Java 有 8 中基本类型，每种类型都有一种对应的包装类。具体的对应关系如下：</p>
<table>
<thead>
<tr>
<th><strong>基本类型</strong></th>
<th><strong>包装类</strong></th>
<th><strong>基本类型</strong></th>
<th><strong>包装类</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>Boolean</code></td>
<td><code>long</code></td>
<td><code>Long</code></td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>Byte</code></td>
<td><code>float</code></td>
<td><code>Float</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>Short</code></td>
<td><code>double</code></td>
<td><code>Double</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>Integer</code></td>
<td><code>char</code></td>
<td><code>Character</code></td>
</tr>
</tbody></table>
<h5 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h5><p>Java 里面基本数据类型与其对应的包装类型是可以互相转换的，这称为装箱与拆箱。将基本类型转换成包装类型叫做装箱，反之叫做拆箱。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">bObj</span> <span class="operator">=</span> Boolean.valueOf(b1);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> bObj.booleanValue();</span><br></pre></td></tr></table></figure>
<p>上面使用<code>boolean</code>类型举例子，实际上所有基本类型都是相似的。使用对应包装类型的静态方法<code>valueOf</code>进行装箱，拆箱只需要调用对象的<code>xxxValue</code>方法即可。<br>装箱与拆箱的操作比较繁琐，所以在 Java5 之后引入了自动装箱与拆箱技术。简单说就是可以直接相互赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">bObj</span> <span class="operator">=</span> b1;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> bObj;</span><br></pre></td></tr></table></figure>
<p>自动拆装箱是编译器提供的能力，实际上，背后还是做的上面那一套。<br>每种包装类都有对应的构造方法，例如<code>Boolean bObj = new Boolean(true);</code>。所以我们有两种方法从基本类型转到包装类型：一个是使用<code>valueOf</code>方法，一个是使用<code>new</code>。两者的区别主要是，<code>new</code>出来的对象每次都是新的，而<code>valueOf</code>方法则会维护一个缓存（Float 与 Double除外）提升效率。实际上，从 Java9 开始这些构造方法已经被标记过时了。</p>
<h5 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h5><p>所有包装类都实现了<code>Object</code>类的一些方法并实现了<code>Comparable</code>接口。</p>
<h6 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h6><p><code>equals</code>方法用来判断当前对象与传进来的对象是否相同。<code>Object</code>的默认实现是比较两个对象的引用是否相同（这和<code>==</code>运算符的含义是一样的），这在许多时候是不合适的。对于包装类型而言，我们的比较依据应该是它们值的大小关系，所以所有包装类型都有自己的实现。<br>对于<code>Long</code>类型，其<code>equals</code>实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">    	<span class="keyword">return</span> value == ((Long)obj).longValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>Float</code>类型，其实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (obj <span class="keyword">instanceof</span> Float)</span><br><span class="line">    	&amp;&amp; (floatToIntBits(((Float)obj).value) == floatToIntBits(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从实现可以看出浮点数比较看的是静态函数<code>floatToIntBits</code>的返回值，这个函数指的是将浮点数的二进制看做一个<code>int</code>。<br>对于<code>Double</code>类型会调用<code>doubleToLongBits</code>方法，将<code>Double</code>的二进制看做一个<code>long</code>，然后进行比较。</p>
<h6 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h6><p><code>hashCode</code>返回一个对象的哈希值。哈希值是一个<code>int</code>类型的数，对象的哈希值不能改变。同一个对象的哈希值必须一样，不同对象的哈希值一般应不同。<br><code>hashCode</code>与<code>equals</code>方法有密切联系。对两个对象来说，若<code>equals</code>返回<code>true</code>则<code>hashCode</code>必须一样，<code>equals</code>返回<code>false</code>不做要求。<code>hashCode</code>默认实现是将对象地址转成整数，子类若是重写<code>equals</code>方法必须也重写<code>hashCode</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">int</span>)value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Character</code>类直接使用其值作为哈希值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> value ? <span class="number">1231</span> : <span class="number">1237</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Boolean</code>类型根据真假返回两个质数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span>(<span class="type">int</span>)(value ^ (value &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Long</code>类型将高 32 位与低 32 位做异或作为返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> floatToIntBits(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">bits</span> <span class="operator">=</span> doubleToLongBits(value);</span><br><span class="line">    <span class="keyword">return</span>(<span class="type">int</span>)(bits ^ (bits &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于浮点数，将其二进制看做整数然后执行一样的操作。<code>Float</code>将看做<code>Integer</code>，<code>Double</code>将看做<code>Long</code>。</p>
<h6 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo"></a>compareTo</h6><p>每个包装类都实现了<code>Comparable</code>接口，接口里面只有<code>compareTo</code>一个方法。这个方法将当前对象与参数对象作比较，返回一个整数。整数符号为正表示大于，符号为负表示小于，整数为 0 表示相等。<br>各个包装类的实现都是使用基本类型值进行比较，对于<code>Boolean</code>类型来说，<code>false</code>小于<code>true</code>。</p>
<h5 id="包装类与字符串"><a href="#包装类与字符串" class="headerlink" title="包装类与字符串"></a>包装类与字符串</h5><h6 id="字符串转包装类"><a href="#字符串转包装类" class="headerlink" title="字符串转包装类"></a>字符串转包装类</h6><p>各包装类都有<code>valueOf</code>静态方法将字符串转成对应的包装类，这个方法上面还讲过另一种重载形式——将基本类型转成对应的包装类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.valueOf(<span class="string">&quot;false&quot;</span>);</span><br></pre></td></tr></table></figure>
<h6 id="字符串转基本类型"><a href="#字符串转基本类型" class="headerlink" title="字符串转基本类型"></a>字符串转基本类型</h6><p>各包装类还有<code>parseXXX</code>静态方法将字符串转成基本数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;false&quot;</span>);</span><br></pre></td></tr></table></figure>
<h6 id="基本类型转字符串"><a href="#基本类型转字符串" class="headerlink" title="基本类型转字符串"></a>基本类型转字符串</h6><p>各包装类还有静态的<code>toString</code>方法，接受基本数据数据，将之转成字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Boolean.toString(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h5 id="常用常量"><a href="#常用常量" class="headerlink" title="常用常量"></a>常用常量</h5><p>包装类中还定义了一些静态常量，对于<code>Boolean</code>类来说，定义了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">TRUE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">FALSE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>所有数值类型都定义了<code>MAX_VALUE</code>和<code>MIN_VALUE</code>表示该类型能表示的最大或最小范围，对于<code>Integer</code>来说：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_VALUE</span> <span class="operator">=</span> <span class="number">0x80000000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_VALUE</span> <span class="operator">=</span> <span class="number">0x7fffffff</span>;</span><br></pre></td></tr></table></figure>
<p><code>Float</code>和<code>Double</code>还定义了特殊数值，例如对<code>Double</code>而言：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">POSITIVE_INFINITY</span> <span class="operator">=</span> <span class="number">1.0</span> / <span class="number">0.0</span>;  <span class="comment">// 正无穷</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">NEGATIVE_INFINITY</span> <span class="operator">=</span> -<span class="number">1.0</span> / <span class="number">0.0</span>;  <span class="comment">// 负无穷</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">NaN</span> <span class="operator">=</span> <span class="number">0.0d</span> / <span class="number">0.0</span>;  <span class="comment">// 非数值</span></span><br></pre></td></tr></table></figure>
<h5 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h5><p>6 中数值类型的包装类都继承于<code>Number</code>类，这是一个抽象类。它定义了如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="title function_">byteValue</span><span class="params">()</span></span><br><span class="line"><span class="type">short</span> <span class="title function_">shortValue</span><span class="params">()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">intValue</span><span class="params">()</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">longValue</span><span class="params">()</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">floatValue</span><span class="params">()</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">doubleValue</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>通过这些方法，包装类能返回任意类型的基本类型。但如果类型不匹配怎么办？<br>例如对于<code>Integer i = 100</code>，<code>i.byteValue()</code>返回对<code>byte</code>强转后的结果。</p>
<h5 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h5><p>包装类都是不可变的，即对象一旦创建就无法修改。这主要通过下面的方式：</p>
<ul>
<li>所有包装类都声明为<code>final</code>，不可被继承。</li>
<li>内部基本类型值都是<code>final</code>的，且都是私有的。</li>
<li>不提供<code>setter</code>来修改基本类型值。</li>
</ul>
<h4 id="剖析-Integer"><a href="#剖析-Integer" class="headerlink" title="剖析 Integer"></a>剖析 Integer</h4><p><code>Long</code>和<code>Integer</code>相似，所以不多说。本节主要研究一些二进制操作。</p>
<h5 id="位翻转"><a href="#位翻转" class="headerlink" title="位翻转"></a>位翻转</h5><h6 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h6><p>位翻转指的是首尾互换，类似于求逆序。<code>Integer</code>有两个静态方法实现翻转：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">reverseBytes</span><span class="params">(<span class="type">int</span> i)</span></span><br></pre></td></tr></table></figure>
<p>其中<code>reverse</code>表示按位翻转，<code>reverseBytes</code>表示按字节翻转。看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0x12345678</span>;</span><br><span class="line">    System.out.println(Integer.toBinaryString(a));</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> Integer.reverse(a);</span><br><span class="line">    System.out.println(Integer.toBinaryString(r));</span><br><span class="line">    <span class="type">int</span> <span class="variable">rb</span> <span class="operator">=</span> Integer.reverseBytes(a);</span><br><span class="line">    System.out.println(Integer.toHexString(rb));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子会输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10010001101000101011001111000</span></span><br><span class="line"><span class="number">11110011010100010110001001000</span></span><br><span class="line"><span class="number">78563412</span></span><br></pre></td></tr></table></figure>
<p>对于按字节翻转，原来的数字是<code>0x12345678</code>，按字节翻转后是<code>0x78563412</code>。我们知道一个字节是 8 位，而十六进制数里面每个数字都是 4 位，所以一个字节表示十六进制里面的两位数。因此原来数字里面分为<code>12、34、56、78</code>这四个字节，那么翻转之后就是<code>78、56、34、12</code>。<br>对于按位翻转，看上面的结果似乎不对。但实际上，上面的输出结果并不是 32 位，它们前面还有前导 0 被省略掉了，补上之后的输出应该是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00010010001101000101011001111000</span></span><br><span class="line"><span class="number">00011110011010100010110001001000</span></span><br></pre></td></tr></table></figure>
<p>这样看来，按位翻转确实是首尾交换没错了。</p>
<h6 id="按字节翻转实现"><a href="#按字节翻转实现" class="headerlink" title="按字节翻转实现"></a>按字节翻转实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">reverseBytes</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((i &gt;&gt;&gt; <span class="number">24</span>) ) |</span><br><span class="line">        ((i &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF00</span>) |</span><br><span class="line">        ((i &lt;&lt; <span class="number">8</span>) &amp; <span class="number">0xFF0000</span>) |</span><br><span class="line">        ((i &lt;&lt; <span class="number">24</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>左边是按位翻转的源代码，这个代码其实还是比较好理解的，主体思想就是：将每个字节放到它该在的位置，其它位置置为 0，最后将这些数字或在一起即可。</p>
<h6 id="按位翻转实现"><a href="#按位翻转实现" class="headerlink" title="按位翻转实现"></a>按位翻转实现</h6><p>按照一样的思想，我们可以实现按位翻转。但问题是一个<code>Integer</code>有 32 位，按照上面的做法，我们需要将 32 个数字或在一起，很麻烦。下面看看源码的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">//HD, Figure 7-1</span></span><br><span class="line">    i = (i &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span> | (i &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>;</span><br><span class="line">    i = (i &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span> | (i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>;</span><br><span class="line">    i = (i &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span> | (i &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>;</span><br><span class="line">    i = (i &lt;&lt; <span class="number">24</span>) | ((i &amp; <span class="number">0xff00</span>) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">    ((i &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff00</span>) | (i &gt;&gt;&gt; <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码注释“HD”表示一本书《Hacker’s Delight》，中文翻译为《算法心得：高效算法的奥秘》。算法的主要思路就是交换，首先相邻位之间做交换；接着两位为一组，相邻组两两交换；4 位一组，组间两两交换；8 位一组，直接按字节交换结束。<br>十进制数也能使用这个算法：<code>12345678</code>→<code>21 43 65 87</code>→<code>4321 8765</code>→<code>87654321</code>。<br>对于十进制而言使用这样的方法效率不高，但二进制使用这样的方法效率很高。我们首先两两交换每一位，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (i &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span> | (i &amp; <span class="number">0xAAAAAAAA</span>) &gt;&gt;&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>5 的二进制是<code>0101</code>，A 的二进制是<code>1010</code>。因此<code>i &amp; 0x55555555</code>是取 i 的奇数位（从右开始数起），<code>i &amp; 0xAAAAAAAA</code>是取 i 的偶数位。然后奇数位左移 1 位，偶数位右移 1 位，最后两者或在一起就实现了两两交换的操作。<br>这个思路还可以有一点优化<code>i = (i &amp; 0x55555555) &lt;&lt; 1 | (i &gt;&gt;&gt; 1) &amp; 0x55555555</code>。这边只使用了一个常量<code>0x55555555</code>实现，先将 i 右移 1 位，那么偶数位自然变成奇数位。<br>同理，实现 2 位一组的交换的代码如下（3 的二进制是<code>0011</code>，C 的二进制是<code>1100</code>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = (i &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span> | (i &amp; <span class="number">0xCCCCCCCC</span>) &gt;&gt;&gt; <span class="number">2</span>  <span class="comment">// 优化前</span></span><br><span class="line">i = (i &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span> | (i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>  <span class="comment">// 优化后</span></span><br></pre></td></tr></table></figure>
<p>实现 4 位一组交换的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = (i &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span> | (i &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt;&gt; <span class="number">4</span>  <span class="comment">// 优化前</span></span><br><span class="line">i = (i &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span> | (i &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>  <span class="comment">// 优化后</span></span><br></pre></td></tr></table></figure>
<h5 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h5><p><code>Integer</code>类有两个静态方法实现循环移位，分别表示循环左移和循环右移。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rotateLeft</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> distance)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rotateRight</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> distance)</span></span><br></pre></td></tr></table></figure>
<p>循环移位与普通移位的差距在于位溢出的时候会放到另一端，而不是补 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.rotateLeft(a, <span class="number">8</span>);</span><br><span class="line">    println(Integer.toHexString(b));</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> Integer.rotateRight(a, <span class="number">8</span>);</span><br><span class="line">    println(Integer.toHexString(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>左边程序的运行结果是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">34567812</span></span><br><span class="line"><span class="number">78123456</span></span><br></pre></td></tr></table></figure>

<p>这两个函数的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rotateLeft</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (i &lt;&lt; distance) | (i &gt;&gt;&gt; -distance);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rotateRight</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (i &gt;&gt;&gt; distance) | (i &lt;&lt; -distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现里面令人费解的是移动负数。实际上在进行移位的时候，不是直接使用后面的数字作为移动的位数，而是使用后面数字的低 5 位作为移动的位数。因为我们知道<code>Integer</code>一共是 32 位，移位的时候最多移 31 位，再多就没有意义了，而 5 位能表示的最大范围正好是 31，所以会选取后面数字的低 5 位作为移动位数。例如<code>i &gt;&gt;&gt; -8</code>，-8 的二进制是<code>...11000</code>，所以实际上移位的时候会移动 <code>24</code> 位。<br>了解了这个，那么我们看看实现的逻辑。对于 5 位的整数<code>k</code>，<code>-k</code>是对<code>k</code>取反加 1，因此<code>-k + k</code>的二进制会是<code>100000</code>。最后我们发现，移动<code>-k</code>位实际上是移动<code>32 - k</code>位。基于此，源码的实现是很好理解的。</p>
<h5 id="valueOf-方法的实现"><a href="#valueOf-方法的实现" class="headerlink" title="valueOf 方法的实现"></a>valueOf 方法的实现</h5><p>之前我们就说过，创建包装类的时候推荐使用<code>valueOf</code>方法而不是直接<code>new</code>。现在我们看看<code>valueOf</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">    	<span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到使用<code>valueOf</code>里面有一个缓存，每次创建的时候优先拿缓存而不是创建。而包装类都是不可变的，缓存被拿去用不用担心被篡改，非常合理。我们再看看缓存内部是什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">            sun.misc.VM.getSavedProperty(</span><br><span class="line">            <span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">//Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        	cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码不难理解，默认情况下缓存的范围是<code>[-128, 127]</code>。这种共享常用对象的方式是一种设计模式，称为享元模式。</p>
<h4 id="剖析-String"><a href="#剖析-String" class="headerlink" title="剖析 String"></a>剖析 String</h4><p>字符串操作是计算机程序中最常用的操作之一，Java 操作字符串的类主要是<code>String</code>和<code>StringBuilder</code>类。</p>
<h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;卢研&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;真帅&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>创建字符串对象可以直接使用常量赋值或者使用<code>new</code>创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 += s2;</span><br><span class="line">System.out.println(s1 + <span class="string">&quot;!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>字符串对象之间可以使用<code>+</code>表示字符串的连接。还可以使用<code>+=</code>表示连接并赋值。<br><code>String</code>类里面有很多方法可以处理字符串，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字符串是否为空串，空串指的是 length 为 0 的串</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符串的长度即字符个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取范围 [beginIndex, length) 的子串，下标越界会报错</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取范围 [beginIndex, endIndex) 的子串，下标越界会报错</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符 ch 在串里的下标（从左到右第一个），找不到返回 -1</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(<span class="type">int</span> ch)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符串 str 在串里的下标（从左到右第一个），找不到返回 -1</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符 ch 在串里的下标（从右到左第一个），找不到返回 -1</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(<span class="type">int</span> ch)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符串 str 在串里的下标（从右到左第一个），找不到返回 -1</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符串是否包含序列 s</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(CharSequence s)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符串是否以 prefix 开头</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符串是否以 suffix 结尾</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">endsWith</span><span class="params">(String suffix)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回两个串内容是否一样</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回两个串内容是否一样（忽略大小写）</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">(String anotherString)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个串大小，返回一个整数，其符号表示大小关系</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String anotherString)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同上，但忽略大小写</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareToIgnoreCase</span><span class="params">(String str)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转大写，返回的是新串，原串不变</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toUpperCase</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转小写，返回的是新串，原串不变</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toLowerCase</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接两个字符串，返回连接后的结果。返回的是新串，原串不变</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String str)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符替换，将串里所有的 oldChar 替换成 newChar</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replace</span><span class="params">(<span class="type">char</span> oldChar, <span class="type">char</span> newChar)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列替换，将串里所有的 target 替换成 replacement</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除首尾的空白字符</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">trim</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 regex 分割字符串，返回分割后的字符串数组</span></span><br><span class="line"><span class="keyword">public</span> String[] split(String regex)</span><br></pre></td></tr></table></figure>
<h5 id="走进-String"><a href="#走进-String" class="headerlink" title="走进 String"></a>走进 String</h5><p>字符串内部使用<code>char</code>数组表示字符串，实例变量的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure>
<p><code>String</code>有两个和字符数组相关的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[])</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[], <span class="type">int</span> offset, <span class="type">int</span> count)</span></span><br></pre></td></tr></table></figure>
<p>需要说明的是，<code>String</code>会创建一个新数组并将参数的字符复制进去，而不会直接使用参数数组。<code>String</code>里面大部分方法都是操作<code>value</code>数组：</p>
<ul>
<li><code>length()</code>方法返回的就是<code>value</code>数组的长度。</li>
<li><code>substring()</code>方法是根据参数调用构造<code>String(char value[], int offset, int count)</code>创建新字符串并返回。</li>
</ul>
<p>还有很多方法就不一一列举。除此之外，还有很多方法和<code>value</code>数组相关：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 index 下标处的字符</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符串的数组表示，返回的是 value 的副本不是本身</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">char</span>[] toCharArray()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 value 数组 [srcBegin, srcEnd) 的内容放到数组 dst 下标 dstBegin 开始处</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getChars</span><span class="params">(<span class="type">int</span> srcBegin, <span class="type">int</span> srcEnd, <span class="type">char</span> dst[], <span class="type">int</span> dstBegin)</span></span><br></pre></td></tr></table></figure>
<h5 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h5><p>Java 使用<code>Charset</code>类表示编码，它有两个常用的静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Charset <span class="title function_">defaultCharset</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Charset <span class="title function_">forName</span><span class="params">(String charsetName)</span></span><br></pre></td></tr></table></figure>
<p>第一个方法返回系统的默认编码，第二个方法返回给定名称的<code>Charset</code>对象。常见的名称有<code>UTF-8</code>、<code>GBK</code>、<code>windows-1252</code>等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Charset</span> <span class="variable">charset</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>String</code>提供了以下方法返回字符串按照指定编码的字节表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getBytes()</span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getBytes(String charsetName)</span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getBytes(Charset charset)</span><br></pre></td></tr></table></figure>
<p>第一个没有参数，表示按照默认编码返回字节。<br><code>String</code>类还提供对应的构造根据字节数组和编码来创建字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">byte</span> bytes[], <span class="type">int</span> offset, <span class="type">int</span> length, String charsetName)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">byte</span> bytes[], Charset charset)</span></span><br></pre></td></tr></table></figure>
<h5 id="不可变性-1"><a href="#不可变性-1" class="headerlink" title="不可变性"></a>不可变性</h5><p>与包装类类似，<code>String</code>类也是不可变类。字符串对象一旦创建就不能修改，<code>String</code>很多看似在修改的方法其实都是创建新字符串返回，我们以<code>concat</code>方法举例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">otherLen</span> <span class="operator">=</span> str.length();</span><br><span class="line">    <span class="keyword">if</span>(otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> value.length;</span><br><span class="line">    <span class="type">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到字符串的<code>value</code>数组没有发生变化，而是使用<code>Arrays.copyOf</code>方法复制了一份，最后返回的是<code>new</code>出来的新串。<br>正是因为不可变性，每次字符串操作都是返回新串，效率比较低下。因此如果需要频繁修改字符串可以使用<code>StringBuilder</code>类提高效率。</p>
<h5 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h5><p>Java 里的字符串常量其实是一种特殊的字符串对象，它可以调用所有字符串方法。例如可以使用<code>&quot;我是帅哥&quot;.length()</code>获取字符串常量的长度。这些常量对象会放在<strong>字符串常量池</strong>被所有人共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;帅哥&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;帅哥&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure>
<p>左边的案例会返回<code>true</code>，因为变量<code>s1</code>和<code>s2</code>指向同一个对象<code>&quot;帅哥&quot;</code>即变量里面存储的地址是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;帅哥&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;帅哥&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure>
<p>如果是这样就会返回<code>false</code>，因为变量<code>s1</code>和<code>s2</code>指向的对象是不一样的。<br>对于情形 2，有一个小细节。我们先看使用字符串作为参数的构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = original.value;</span><br><span class="line">    <span class="built_in">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从实现可以看出，两个串<code>value</code>数组的引用是一样的。<br>因此对于例子 2，<code>s1 == s2</code>是<code>false</code>，但<code>s1.value == s2.value</code>却是<code>true</code>。当然，<code>value</code>是私有的，不能直接访问。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1701769281175-4a9a9e0e-08a0-4491-a9af-4f6ac0554315.png#averageHue=%23e8e8e8&clientId=u0ba36842-4240-4&from=paste&height=406&id=ub843fc3d&originHeight=406&originWidth=953&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109456&status=done&style=none&taskId=u0c568dd7-a17c-48ff-93a9-31275a48d85&title=&width=953" alt="image.png"></p>
<h5 id="hashCode-1"><a href="#hashCode-1" class="headerlink" title="hashCode"></a>hashCode</h5><p><code>String</code>类还有一个私有实例变量<code>hash</code>，这个变量用来缓存串的哈希码。这个变量定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> hash;  <span class="comment">//Default to 0</span></span><br></pre></td></tr></table></figure>
<p><code>hash</code>变量的默认值是 0，当我们第一次调用<code>hashCode</code>方法时会把计算出来的值缓存到这个变量里面。我们看下<code>hashCode</code>方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">    <span class="keyword">if</span>(h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> val[] = value;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据源码可以看出字符串哈希值的计算公式是：$s[0]\times31^{n-1}+s[1]\times31^{n-2}+…+s[n-1]$。<br>为什么这么实现呢？因为使用这样的公式能够让哈希值与字符串里每个字符有关，且与每个字符的位置也有关。<br>使用数字<code>31</code>的原因大致有两个：</p>
<ul>
<li>使用 31 能产生更分散的散列，尽量满足不同串的哈希值不一样。</li>
<li>计算效率比较高，因为<code>31*h = 32*h-h</code>而<code>32*h = h&lt;&lt;5</code>。这样可以使用效率更高的加减和位运算代替效率较低的乘法运算。</li>
</ul>
<h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h5><p>在<code>String</code>类中有些方法的参数不是普通的字符串，而是正则表达式。Java 里有专门的类用于正则表达式，如<code>Pattern</code>和<code>Matcher</code>。但对于简单的情况，<code>String</code>类提供了更为简洁的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex)  <span class="comment">// 字符串分割</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(String regex)</span>  <span class="comment">// 检查是否匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串替换，仅替换遇到的第一个</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceFirst</span><span class="params">(String regex, String replacement)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串替换，替换所有</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceAll</span><span class="params">(String regex, String replacement)</span></span><br></pre></td></tr></table></figure>
<p>至于正则表达式的教程看之前整理过的文档：<br><a target="_blank" rel="noopener" href="https://space-jiangsu.yuque.com/bcsfg9/qr2sxk/gaucwl?view=doc_embed">正则表达式学习</a><br><code>**String**</code><strong>类和下面将要介绍的</strong><code>**StringBuilder**</code><strong>类在 Java9 之后内部就优化了一下，使用 byte 数组而不是 char 数组。</strong></p>
<h4 id="剖析-StringBuilder"><a href="#剖析-StringBuilder" class="headerlink" title="剖析 StringBuilder"></a>剖析 StringBuilder</h4><p>之前说过，字符串需要频繁修改的时候，使用<code>String</code>很慢。建议使用<code>StringBuilder</code>或<code>StringBuffer</code>。这两者使用方法几乎是一样的，实现也几乎是一样的，<strong>只不过</strong><code>**StringBuffer**</code><strong>使用关键字</strong><code>**synchronized **</code><strong>实现了线程安全</strong>。</p>
<h5 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">sb.append(<span class="string">&quot;我是&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;帅哥&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure>
<p>我们创建<code>StringBuilder</code>对象之后，可以使用<code>append</code>方法往里面添加字符串。<br>最后再使用<code>toString</code>方法得到字符串。</p>
<h5 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h5><h6 id="append"><a href="#append" class="headerlink" title="append"></a>append</h6><p><code>StringBuilder append(?)</code>函数可以往<code>value</code>后面追加内容，几乎所有类型的数据都可以追加。因为<code>append</code>有一个重载的参数是<code>Object</code>类型，此时是追加该对象的<code>toString</code>。除了直接追加内容，<code>append</code>方法还有以下形式：</p>
<ul>
<li><code>StringBuilder append(char[] str, int offset, int len)</code>表示将<code>str[offset, offset+len)</code>追加到<code>value</code>后面。</li>
<li><code>StringBuilder append(CharSequence s, int start, int end)</code>表示将<code>s[start, end)</code>追加到<code>value</code>后面。</li>
</ul>
<h6 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h6><p><code>StringBuilder insert(int offset, ?)</code>函数可以往<code>value</code>指定下标出插入内容，原先的内容会后移。和<code>append</code>类似，几乎所有类型的数据都可以插入进去，因为有一个<code>Object</code>类型的重载，会将对象的<code>toString</code>插入到<code>value</code>里面。除了直接插入内容，还有一下形式：</p>
<ul>
<li><code>StringBuilder insert(int index, char[] str, int offset, int len)</code>表示将<code>str[offset, offset+len)</code>插入到<code>value</code>的指定位置。</li>
<li><code>StringBuilder insert(int dstOffset, CharSequence s, int start, int end)</code>表示将<code>s[start, end)</code>插入到<code>value</code>的指定位置。</li>
</ul>
<h6 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h6><p><code>StringBuilder delete(int start, int end)</code>删除<code>value[start, end)</code>子串。</p>
<h6 id="deleteCharAt"><a href="#deleteCharAt" class="headerlink" title="deleteCharAt"></a>deleteCharAt</h6><p><code>StringBuilder deleteCharAt(int index)</code>删除<code>value[index]</code>字符。</p>
<h6 id="charAt"><a href="#charAt" class="headerlink" title="charAt"></a>charAt</h6><p><code>char charAt(int index)</code>返回<code>value</code>中下标 index 处的字符。</p>
<h6 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h6><ol>
<li><code>int indexOf(String str)</code>返回子串<code>str</code>在<code>value</code>中的下标（从左到右第一个）。</li>
<li><code>int indexOf(String str, int fromIndex)</code>返回子串<code>str</code>在<code>value[fromIndex,length)</code>中的下标（从左到右第一个）。</li>
</ol>
<h6 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h6><ol>
<li><code>int lastIndexOf(String str)</code>返回子串<code>str</code>在<code>value</code>中的下标（从右到左第一个）。</li>
<li><code>int lastIndexOf(String str, int fromIndex)</code>返回子串<code>str</code>在<code>value[fromIndex,length)</code>中的下标（从右到左第一个）。</li>
</ol>
<h6 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h6><p><code>StringBuilder replace(int start, int end, String str)</code>将<code>value[start, end)</code>替换成<code>str</code>。</p>
<h6 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h6><p><code>StringBuilder reverse()</code>翻转整个<code>value</code>。</p>
<h6 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h6><ol>
<li><code>String substring(int start)</code>返回子串<code>value[start, length)</code>。</li>
<li><code>String substring(int start, int end)</code>返回子串<code>value[start, end)</code>。</li>
</ol>
<h6 id="getChars"><a href="#getChars" class="headerlink" title="getChars"></a>getChars</h6><p><code>void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</code>表示将<code>value[srcBegin, srcEnd)</code>复制到<code>dst[dstBegin,...]</code>处。</p>
<h6 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h6><p><code>String toString()</code>返回<code>value</code>的字符串形式。</p>
<h6 id="length"><a href="#length" class="headerlink" title="length"></a>length</h6><p><code>int length()</code>返回<code>value</code>中字符的个数。</p>
<h6 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h6><p><code>int capacity()</code>函数返回<code>value</code>的当前容量。</p>
<h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><p><code>StringBuilder</code>和<code>String</code>类似，内部维护一个字符数组。定义如<code>int count; char[] value;</code>，其中<code>count</code>表示数组中字符的个数。<code>StringBuilder</code>继承于<code>AbstractStringBuilder</code>，默认的构造是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AbstractStringBuilder(<span class="type">int</span> capacity) &#123;</span><br><span class="line">	value = <span class="keyword">new</span> <span class="title class_">char</span>[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码可以看出，默认创建的<code>StringBuilder</code>容量是 16。</p>
<h6 id="append-1"><a href="#append-1" class="headerlink" title="append"></a>append</h6><p>我们再看看<code>append</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">null</span>) str = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>append</code>方法会将内容复制到自己的<code>value</code>数组中，不过在复制之前会先检查容量，如果容量不够会先扩容。下面看检查容量的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span>(minimumCapacity - value.length &gt; <span class="number">0</span>)</span><br><span class="line">    	expandCapacity(minimumCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码很简单，只是判断一下需要的容量和当前最大容量的关系，不够就扩容。扩容的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">expandCapacity</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> value.length * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(newCapacity - minimumCapacity &lt; <span class="number">0</span>)newCapacity = minimumCapacity;</span><br><span class="line">    <span class="keyword">if</span>(newCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minimumCapacity &lt; <span class="number">0</span>) <span class="comment">//overflow</span></span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        newCapacity = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    value = Arrays.copyOf(value, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边首先计算新容量的大小并分配一个新数组，然后将原来的内容复制到扩容后的数组中。最后将自己的<code>value</code>指向这个新数组。这边主要关注一下扩容的机制，每次在原有容量的基础上翻倍并<code>+2</code>，<code>+2</code>主要顾及到原始容量为 0 的场景。这是一种指数扩容机制，这在不知道要多长的情况下，是很常用的机制。<br>如果，我们在使用<code>StringBuilder</code>之前就能够粗略估算出最大容量，那我们就可以使用构造<code>public StringBuilder(int capacity)</code>来创建<code>StringBuilder</code>。</p>
<h6 id="toString"><a href="#toString" class="headerlink" title="toString"></a>toString</h6><p>字符串构建完毕之后，看看<code>toString</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//Create a copy, don&#x27;t share the array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，构建<code>String</code>时使用的是<code>value</code>的副本而不是本身，这可以保证<code>String</code>的不可变性。</p>
<h6 id="insert-1"><a href="#insert-1" class="headerlink" title="insert"></a>insert</h6><p><code>insert</code>方法能够在指定位置插入一个字符串，方法原型如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">insert</span><span class="params">(<span class="type">int</span> offset, String str)</span></span><br></pre></td></tr></table></figure>
<p>这个方法能在<code>value</code>数组下标<code>offset</code>处插入一个字符串，原先在这的内容会后移。下面看看这个方法内部的实现逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">insert</span><span class="params">(<span class="type">int</span> offset, String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>((offset &lt; <span class="number">0</span>) || (offset &gt; length()))</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(offset);</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">null</span>)</span><br><span class="line">    	str = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    System.arraycopy(value, offset, value, offset + len, count - offset);</span><br><span class="line">    str.getChars(value, offset);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的主体逻辑是：首先确保容量足够；其次将指定位置及其后面的所有字符后移 n 个位置，n 是待插入串的长度；最后把新串插入到指定位置。<br>这里面用到了一个很好用的函数<code>System.arraycopy</code>，其原型如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src, <span class="type">int</span> srcPos,</span></span><br><span class="line"><span class="params">	Object dest, <span class="type">int</span> destPos, <span class="type">int</span> length)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数的含义是：将数组 src 里面范围<code>[srcPos, srcPos+length)</code>的元素复制到数组 dest 起始下标 destPos 处。</p>
<h5 id="String-的-和"><a href="#String-的-和" class="headerlink" title="String 的 + 和 +&#x3D;"></a>String 的 + 和 +&#x3D;</h5><p>Java 中字符串可以使用<code>+</code>和<code>+=</code>做连接，这是 Java 编译器提供的支持。背后 Java 编译会自己生成一个<code>StringBuilder</code>，然后调用<code>append</code>操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">hello+=<span class="string">&quot;,world&quot;</span>;</span><br><span class="line">System.out.println(hello);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">hello.append(<span class="string">&quot;,world&quot;</span>);</span><br><span class="line">System.out.println(hello.toString());</span><br></pre></td></tr></table></figure>
<p>上面左侧的写法会被优化成右侧的写法，既然编译器会自己做这个事情，那我们使用的过程中为什么还要区分呢？对于简单的情况下，确实直接使用<code>String</code>更方便，但对于复杂情况，尤其是在循环里面使用，编译器就显得不够聪明了，看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">tring</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">	hello+=<span class="string">&quot;,world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(hello);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(hello);</span><br><span class="line">    sb.append(<span class="string">&quot;,world&quot;</span>);</span><br><span class="line">    hello = sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(hello);</span><br></pre></td></tr></table></figure>
<p>可以看到每一次循环都会生成<code>StringBuilder</code>对象，这就很低效了。所以，对于简单的情况，我们直接使用<code>String</code>；对于复杂的情况手动使用<code>StringBuilder</code>。</p>
<h4 id="剖析-Arrays"><a href="#剖析-Arrays" class="headerlink" title="剖析 Arrays"></a>剖析 Arrays</h4><p><code>Arrays</code>中有很多针对数组的方法，下面我们看一下。</p>
<h5 id="toString-1"><a href="#toString-1" class="headerlink" title="toString"></a>toString</h5><p>我们直接输出数组对象的时候，会输出其地址。此时我们可以调用<code>Arrays.toString()</code>方法来获取数组的字符串形式，即使是对象数组也会挨个调用对象的<code>toString</code>方法来生成数组的字符串形式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Point</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="type">Point</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">Point[] ps = &#123;p1, p2&#125;;</span><br><span class="line">System.out.println(ps);</span><br><span class="line">println(Arrays.toString(ps));</span><br></pre></td></tr></table></figure>
<p>这个案例输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Lcom.luyan.Point;@28a418fc</span><br><span class="line">[(<span class="number">1</span>,<span class="number">2</span>), (<span class="number">3</span>,<span class="number">4</span>)]</span><br></pre></td></tr></table></figure>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><h6 id="基本类型排序"><a href="#基本类型排序" class="headerlink" title="基本类型排序"></a>基本类型排序</h6><p>对数组而言，排序是非常重要且常用的操作。对于基本数据类型排序，可以使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span></span><br></pre></td></tr></table></figure>
<p>上面第一个函数是对数组<code>a</code>所有元素升序排序，第二个是对子数组<code>a[fromIndex, toIndex)</code>升序排序。这两种方法对除 boolean 外所有的基本数据类型都有对应的重载。</p>
<h6 id="对象数组排序"><a href="#对象数组排序" class="headerlink" title="对象数组排序"></a>对象数组排序</h6><p>除了基本数据类型，对象数组也可以排序，但前提是对象所属的类要实现<code>Comparable</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Object[] a)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Object[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span></span><br></pre></td></tr></table></figure>
<p>上面两个函数与基本数据类型的排序是一样的，只不过换成了对象数组。但对应的类一定要实现<code>Comparable</code>接口，不然会报错的，因为两个对象之间不知道如何比较。</p>
<h6 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h6><p><code>String</code>类实现了<code>Comparable</code>接口，所以可以排序。如果我想对字符串忽略大小写排序怎么办？那么我们可以使用下面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex,</span></span><br><span class="line"><span class="params">                            Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br></pre></td></tr></table></figure>
<p><code>Comparator</code>是比较器接口，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是<code>compare</code>方法，它会返回一个整数，根据整数的符号确定大小关系。<code>String</code>类中有一个公开的静态成员变量，表示忽略大小写的比较器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER</span><br><span class="line">	= <span class="keyword">new</span> <span class="title class_">CaseInsensitiveComparator</span>();</span><br></pre></td></tr></table></figure>
<p>想要忽略大小写对字符串数组排序就可以使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>, <span class="string">&quot;Break&quot;</span>,<span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(arr, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>
<h6 id="降序排序"><a href="#降序排序" class="headerlink" title="降序排序"></a>降序排序</h6><p>目前为止排序都是升序排序，如果想要逆序排序该如何操作？我们可以使用匿名内部类实现<code>Comparator</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>, <span class="string">&quot;Break&quot;</span>,<span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareToIgnoreCase(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>
<p>除了自己实现外，<code>Collections</code>类有两个静态方法能够返回逆序<code>Comparator</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Comparator&lt;T&gt; <span class="title function_">reverseOrder</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Comparator&lt;T&gt; <span class="title function_">reverseOrder</span><span class="params">(Comparator&lt;T&gt; cmp)</span></span><br></pre></td></tr></table></figure>
<p>这样忽略大小写降序排序就可以写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>, <span class="string">&quot;Break&quot;</span>,<span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(arr, Collections.reverseOrder(String.CASE_INSENSITIVE_ORDER));</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>
<h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>对于有序数组，二分查找是效率非常高的查找方式。所有基本数据类型（boolean除外）都支持二分查找：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> key)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex, <span class="type">int</span> key)</span></span><br></pre></td></tr></table></figure>
<p>函数里<code>key</code>指的是要查找的元素。<br>和排序类似，对象数组也可以进行查找，前提是对应的类需要实现<code>Comparable</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(Object[] a, <span class="type">int</span> key)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(Object[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex, <span class="type">int</span> key)</span></span><br></pre></td></tr></table></figure>
<p>对于复杂类型，也可以传递<code>Comparator</code>指定排序方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(T[] a, T key, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(T[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex,</span></span><br><span class="line"><span class="params">                                   T key, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>查找注意点</p>
<ol>
<li>使用二分查找的数组必须是升序数组，想要在降序数组里面查找，那么需要配合<code>Comparator</code>实现。</li>
<li>如果数组使用<code>Comparator</code>排序，那么查找时必须使用一样的比较器。因为只有这样，才能使两者认为的有序是一致的。</li>
<li>查找时若是没找到会返回一个负数，这个负数是<code>-(插入点+1)</code>。插入点指的是将要查找的元素插入在某个地方还能保证数组有序。</li>
<li>如果数组有多个匹配的元素，那么返回谁是不确定的。</li>
</ol>
<h5 id="更多方法"><a href="#更多方法" class="headerlink" title="更多方法"></a>更多方法</h5><h6 id="copyOf"><a href="#copyOf" class="headerlink" title="copyOf"></a>copyOf</h6><p><code>copyOf</code>是复制数组的方法，参数可以传递一个<code>newLength</code>表示新数组的长度。新长度比较短就复制前面一小部分，新长度比较长就在后面补<code>null</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="type">int</span> newLength)</span><br></pre></td></tr></table></figure>
<p>函数会返回复制后的新数组，但是注意对于引用类型，两个数组里面的元素其实是相同的元素。</p>
<h6 id="copyOfRange"><a href="#copyOfRange" class="headerlink" title="copyOfRange"></a>copyOfRange</h6><p><code>copyOfRange</code>方法能够复制<code>original[from, to)</code>到新数组中，返回复制后的数组。对于引用类型，两个数组里面的元素其实是相同的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOfRange(T[] original, <span class="type">int</span> from, <span class="type">int</span> to)</span><br></pre></td></tr></table></figure>
<h6 id="equals-1"><a href="#equals-1" class="headerlink" title="equals"></a>equals</h6><p><code>equals</code>方法能够返回两个数组是否相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object[] a, Object[] a2)</span></span><br></pre></td></tr></table></figure>
<p>数组相同指的是：</p>
<ol>
<li>两个数组长度一致。</li>
<li>数组内对应元素相同，元素相同是指调用<code>equals</code>方法返回<code>true</code>。</li>
</ol>
<h6 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h6><p><code>fill</code>方法用于使用一个元素填充数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(Object[] a, Object val)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(Object[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex, Object val)</span></span><br></pre></td></tr></table></figure>
<p>第一个方法是使用<code>val</code>填充整个数组<code>a</code>；第二个方法使用<code>val</code>填充<code>a[fromIndex, toIndex)</code>。<br>对于引用类型，填充过的元素都会指向同一个对象。</p>
<h6 id="hashCode-2"><a href="#hashCode-2" class="headerlink" title="hashCode"></a>hashCode</h6><p><code>hashCode</code>方法用于返回一个数组的哈希值。我们直接看它的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Object element : a)</span><br><span class="line">        result = <span class="number">31</span> * result + (element == <span class="literal">null</span> ? <span class="number">0</span> : element.hashCode());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现和字符串的很像，这个实现能够照顾到数组里面每个元素以及元素的位置。</p>
<h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5><p>之前介绍的数组都是一维的，其实数组还可以有多维。下面使用二维数组举例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">        arr[i][j] = i + j;</span><br><span class="line">        System.out.print(arr[i][j] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中我们首先定义了一个 2 行 3 列的二维数组，然后给每个元素赋值并输出。<br>我们还能发现，<code>a</code>和<code>a[i]</code>都有<code>length</code>属性。这就很有意思，实际上多维数组只是假象，这些多维数组本质上还是一维数组，只不过一维数组里面每个元素仍然是一维数组（每个元素都指向另一个一维数组）。既然如此，就会出现下面这些写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>][];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">        arr[i][j] = i + j;</span><br><span class="line">        System.out.print(arr[i][j] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>左边案例输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>	</span><br><span class="line"><span class="number">1</span>	<span class="number">2</span>	</span><br><span class="line"><span class="number">2</span>	<span class="number">3</span>	<span class="number">4</span>	</span><br><span class="line"><span class="number">3</span>	<span class="number">4</span>	<span class="number">5</span>	<span class="number">6</span>	</span><br><span class="line"><span class="number">4</span>	<span class="number">5</span>	<span class="number">6</span>	<span class="number">7</span>	<span class="number">8</span>	</span><br></pre></td></tr></table></figure>
<p>可以发现我们创建的二维数组并不是正方形，而是三角形。也就是说，二维数组里面每一行的列数可以自定义。<br><code>Arrays</code>里面的<code>toString</code>、<code>equals</code>、<code>hashCode</code>方法都有对应的<code>deepXXX</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">deepToString</span><span class="params">(Object[] a)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">deepEquals</span><span class="params">(Object[] a1, Object[] a2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">deepHashCode</span><span class="params">(Object a[])</span></span><br></pre></td></tr></table></figure>
<p>这些方法在实现的时候会判断元素是不是也是一个数组，如果是就会递归进行操作。看例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> [][]arr = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">println(Arrays.toString(arr));</span><br><span class="line">println(Arrays.deepToString(arr));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[I@2f92e0f4, [I@28a418fc]</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br></pre></td></tr></table></figure>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><h6 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">binarySearch0</span><span class="params">(T[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex,</span></span><br><span class="line"><span class="params">                                     T key, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> fromIndex;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> toIndex - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">T</span> <span class="variable">midVal</span> <span class="operator">=</span> a[mid];</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> c.compare(midVal, key);</span><br><span class="line">        <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>) low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>) high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid; <span class="comment">//key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>); <span class="comment">//key not found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主体框架还是很简单的，活学活用，以后也用右移表示除以 2。</p>
<h6 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h6><p>对于基本类型的数组使用<strong>双枢轴快速排序</strong>（普通快排的优化版本），对象数组使用<strong>TimSort</strong>（对归并排序的优化）。当数组元素比较少的时候会采用效率更高的插入排序。<br>为什么要区分基本类型数组和对象数组？因为这涉及到稳定性的问题，即排序前后数组中值相同的元素先后顺序是否改变的问题。快排不稳定，而归并排序是稳定的。<br>对于基本数据类型，值相同就是完全相同，稳定性没有意义；但两个对象之间，相同指的是比较结果一样，两者仍然是不同的对象，它们的其它成员变量也可能不同等，所以稳定性很重要。</p>
<h4 id="剖析日期和时间"><a href="#剖析日期和时间" class="headerlink" title="剖析日期和时间"></a>剖析日期和时间</h4><h5 id="Date-类"><a href="#Date-类" class="headerlink" title="Date 类"></a>Date 类</h5><p><code>Date</code>是 Java 最早引入关于日期的类，但由于不能支持国际化，很多方法已经过时。<code>Date</code>内部主要维护一个<code>long</code>类型的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">long</span> fastTime;</span><br></pre></td></tr></table></figure>
<p><code>fastTime</code>表示距离纪元时（1970年1月1日0时0分0秒）的毫秒数，<code>Date</code>主要有两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Date</span><span class="params">(<span class="type">long</span> date)</span> &#123;</span><br><span class="line">	fastTime = date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Date</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无参构造使用<code>System.currentTimeMillis()</code>进行初始化，这个函数会返回当前时刻距离纪元时的毫秒数，使用的还是比较多的。下面是一些<code>Date</code>里面没有过时的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTime</span><span class="params">()</span>  <span class="comment">// 返回毫秒数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>  <span class="comment">// 返回两个 Date 对象是否相同，比较的是毫秒数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Date anotherDate)</span>  <span class="comment">// 与另一个日期对象作比较，返回整数表示大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">before</span><span class="params">(Date when)</span>  <span class="comment">// 判定是否在给定日期之前</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">after</span><span class="params">(Date when)</span>  <span class="comment">// 判定是否在给定日期之后</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>  <span class="comment">// 哈希值算法与 Long 类似</span></span><br></pre></td></tr></table></figure>
<h5 id="Calendar-类"><a href="#Calendar-类" class="headerlink" title="Calendar 类"></a>Calendar 类</h5><p><code>Calendar</code>是日历类，也是 Java 中操作日期和时间的主要类。<code>Calendar</code>内部维护以下成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">long</span> time;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> fields[];</span><br></pre></td></tr></table></figure>
<p><code>time</code>仍然是表示时刻的毫秒数，<code>fields</code>是一个存储日历中各字段值的数组。数组的长度是 17，主要存储的字段有：</p>
<table>
<thead>
<tr>
<th><strong>字段名</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>Calendar.YEAR</code></td>
<td>表示年份。</td>
</tr>
<tr>
<td><code>Calendar.MONTH</code></td>
<td>表示月份，用 0 表示 1 月，1 表示 2 月，…</td>
</tr>
<tr>
<td><code>Calendar.DAY_OF_MONTH</code></td>
<td>表示日，每月第一天是 1。</td>
</tr>
<tr>
<td><code>Calendar.HOUR_OF_DAY</code></td>
<td>表示小时，范围是 0-23。</td>
</tr>
<tr>
<td><code>Calendar.MINUTE</code></td>
<td>表示分钟，范围是 0-59。</td>
</tr>
<tr>
<td><code>Calendar.SECOND</code></td>
<td>表示秒，范围是 0-59。</td>
</tr>
<tr>
<td><code>Calendar.MILLISECOND</code></td>
<td>表示毫秒，范围是 0-999。</td>
</tr>
<tr>
<td><code>Calendar.DAY_OF_WEEK</code></td>
<td>表示周几，周日是 1，周一是 2，…</td>
</tr>
</tbody></table>
<p><code>Calendar</code>类中定义了表示月份和周几的静态变量，例如<code>Calendar.JULY</code>表示 7 月、<code>Calendar.SUNDAY</code>表示周日。<br><code>Calendar</code>是抽象类，不能直接创建对象，它提供了几个静态方法用来获取实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title function_">getInstance</span><span class="params">(TimeZone zone, Locale aLocale)</span></span><br></pre></td></tr></table></figure>
<p><code>TimeZone</code>表示时区，<code>Locale</code>表示国家（或地区）和语言。所有的<code>getInstance</code>方法都需要这两个参数，如果没有就使用默认值（默认当前的时区与国家、语言）。方法中会根据时区与国家选择合适的子类创建对象，中文系统中一般会创建<code>GregorianCalendar</code>类对象。<br>之前就说过，<code>Calendar</code>会将各字段的值存到<code>fields</code>数组里面。当我们想访问某个字段的时候，可以通过<code>get</code>方法获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">println(<span class="string">&quot;年：&quot;</span> + calendar.get(Calendar.YEAR));</span><br><span class="line">println(<span class="string">&quot;月：&quot;</span> + calendar.get(Calendar.MONTH));</span><br><span class="line">println(<span class="string">&quot;日：&quot;</span> + calendar.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">println(<span class="string">&quot;时：&quot;</span> + calendar.get(Calendar.HOUR));</span><br><span class="line">println(<span class="string">&quot;分：&quot;</span> + calendar.get(Calendar.MINUTE));</span><br><span class="line">println(<span class="string">&quot;秒：&quot;</span> + calendar.get(Calendar.SECOND));</span><br><span class="line">println(<span class="string">&quot;毫秒：&quot;</span> + calendar.get(Calendar.MILLISECOND));</span><br><span class="line">println(<span class="string">&quot;周：&quot;</span> + calendar.get(Calendar.DAY_OF_WEEK));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">年：<span class="number">2023</span></span><br><span class="line">月：<span class="number">11</span></span><br><span class="line">日：<span class="number">13</span></span><br><span class="line">时：<span class="number">11</span></span><br><span class="line">分：<span class="number">17</span></span><br><span class="line">秒：<span class="number">59</span></span><br><span class="line">毫秒：<span class="number">534</span></span><br><span class="line">周：<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>因为月是从 0 开始排的，所以拿到字段后需要<code>+1</code>。周日表示 1，所以周三这边显示 4，也需要根据具体情况做变换。<br><code>Calendar</code>类还支持修改各字段的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setTime</span><span class="params">(Date date)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTimeInMillis</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> date)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> date,</span></span><br><span class="line"><span class="params">                      <span class="type">int</span> hourOfDay, <span class="type">int</span> minute, <span class="type">int</span> second)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> field, <span class="type">int</span> value)</span>  <span class="comment">// 用的较多</span></span><br></pre></td></tr></table></figure>
<p>除此之外，还可以使用<code>add</code>方法根据字段增加或减少时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> field, <span class="type">int</span> amount)</span></span><br></pre></td></tr></table></figure>
<p>举个例，我想时间变成第二天下午 2:15 就可以这样设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">calendar.set(Calendar.HOUR_OF_DAY, <span class="number">14</span>);</span><br><span class="line">calendar.set(Calendar.MINUTE, <span class="number">15</span>);</span><br><span class="line">calendar.set(Calendar.SECOND, <span class="number">0</span>);</span><br><span class="line">calendar.set(Calendar.MILLISECOND, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><code>add</code>方法强在不是无脑加法，而是会联动更新其它字段，比如加一天跨年了，那么年份也会联动加一。<br>还有一个方法使用和<code>add</code>一样叫做<code>roll</code>，这个方法也会让一个字段加一，但是不会影响到其它字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">roll</span><span class="params">(<span class="type">int</span> field, <span class="type">int</span> amount)</span></span><br></pre></td></tr></table></figure>
<p>假设现在是<code>2023.12.31</code>，如果使用<code>calendar.add(Calendar.DAY_OF_MONTH, 1) </code>日期会变成<code>2024.1.1</code>；而使用<code>calendar.roll(Calendar.DAY_OF_MONTH, 1) </code>之后日期会变成<code>2023.12.1</code>。<br><code>Calendar</code>可以很方便的转换成<code>Date</code>或毫秒数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Date <span class="title function_">getTime</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTimeInMillis</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>与<code>Date</code>类似，<code>Calendar</code>对象之间也可以进行比较：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Calendar anotherCalendar)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">after</span><span class="params">(Object when)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">before</span><span class="params">(Object when)</span></span><br></pre></td></tr></table></figure>
<h5 id="DateFormat"><a href="#DateFormat" class="headerlink" title="DateFormat"></a>DateFormat</h5><p><code>DateFormat</code>类主要用于将<code>Date</code>与字符串互相转化，主要有下面方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">format</span><span class="params">(Date date)</span></span><br><span class="line"><span class="keyword">public</span> Date <span class="title function_">parse</span><span class="params">(String source)</span></span><br></pre></td></tr></table></figure>
<p>字符串有四种风格，使用静态变量<code>SHORT、MEDIUM、LONG、FULL</code>表示，四种风格描述的详细程度不一样。除了四种风格，还有<code>DEFAULT</code>表示默认风格，默认是<code>MEDIUM</code>。<code>DateFormat</code>也是抽象类，使用的时候需要根据方法获取实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title function_">getDateTimeInstance</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title function_">getDateInstance</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title function_">getTimeInstance</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>这三种方法分别表示：处理日期和时间、只处理日期、只处理时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">calendar.set(<span class="number">2023</span>, Calendar.DECEMBER, <span class="number">31</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">println(DateFormat.getDateInstance().format(date));</span><br><span class="line">println(DateFormat.getTimeInstance().format(date));</span><br><span class="line">println(DateFormat.getDateTimeInstance().format(date));</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023</span>年<span class="number">12</span>月<span class="number">31</span>日</span><br><span class="line"><span class="number">15</span>:<span class="number">40</span>:<span class="number">07</span></span><br><span class="line"><span class="number">2023</span>年<span class="number">12</span>月<span class="number">31</span>日 <span class="number">15</span>:<span class="number">40</span>:<span class="number">07</span></span><br></pre></td></tr></table></figure>

<p>获取实例的方法都有两种重载：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DateFormat <span class="title function_">getDateTimeInstance</span><span class="params">(<span class="type">int</span> dateStyle, <span class="type">int</span> timeStyle)</span></span><br><span class="line">DateFormat <span class="title function_">getDateTimeInstance</span><span class="params">(<span class="type">int</span> dateStyle, <span class="type">int</span> timeStyle, Locale aLocale)</span></span><br></pre></td></tr></table></figure>
<p>简单例子<code>println(DateFormat.getDateInstance(DateFormat.SHORT).format(date))</code>输出简短的日期<code>2023/12/31</code>。</p>
<h5 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h5><p><code>SimpleDateFormat</code>是<code>DateFormat</code>的子类，它的优点是能够接受一个<code>pattern</code>表示日期的自定义格式。<code>pattern</code>里面所有英语字母都有特殊含义，其它字符原样输出，下面是一些常见字母：</p>
<ul>
<li><code>yyyy</code>表示四位数的年</li>
<li><code>MM</code>表示两位数的月</li>
<li><code>dd</code>表示两位数的日</li>
<li><code>HH</code>表示两位数的小时（24小时制）</li>
<li><code>hh</code>表示两位数的小时（12小时制）</li>
<li><code>mm</code>表示两位数的分钟</li>
<li><code>ss</code>表示两位数的秒</li>
<li><code>SSS</code>表示三位数的毫秒</li>
<li><code>E</code>表示周几</li>
<li><code>a</code>表示上午还是下午</li>
</ul>
<p>我们仍然使用<code>format</code>方法将<code>Date</code>对象转换成字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> <span class="string">&quot;yyyy年MM月dd日\nE hh:mm.ss a&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(pattern);</span><br><span class="line">System.out.println(sdf.format(calendar.getTime()));</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023</span>年<span class="number">12</span>月<span class="number">14</span>日</span><br><span class="line">周四 <span class="number">04</span>:<span class="number">01.36</span> 下午</span><br></pre></td></tr></table></figure>
<p>我们除了可以将日期转换成字符串，还可以将指定格式的字符串转换成<code>Date</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> <span class="string">&quot;yyyy年MM月dd日\nE hh:mm.ss a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">timeStr</span> <span class="operator">=</span> <span class="string">&quot;2023年12月14日\n周四 04:02.19 下午&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(pattern);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(timeStr);</span><br><span class="line">    <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">    calendar.setTime(date);</span><br><span class="line">    System.out.println(calendar.get(Calendar.YEAR));</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子会输出<code>2023</code>，我们主要使用<code>parse</code>方法将指定格式的字符串转换成<code>Date</code>对象。这个方法会抛出一个受检异常<code>ParseException</code>，调用者必须处理。<br><code>**DateFormat**</code><strong>和</strong><code>**SimpleDateFormat**</code><strong>都是线程不安全的。</strong></p>
<h4 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h4><p>随机是计算机程序中非常常见的需求，例如：红包金额、随机密码、摇车牌等。</p>
<h5 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random"></a>Math.random</h5><p>Java 对随机的基本支持是<code>Math</code>类的静态方法<code>random</code>，这个方法会返回范围在<code>[0, 1)</code>的随机数。它的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Random randomNumberGenerator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Random <span class="title function_">initRNG</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> randomNumberGenerator;</span><br><span class="line">    <span class="keyword">return</span> (rnd == <span class="literal">null</span>) ? (randomNumberGenerator = <span class="keyword">new</span> <span class="title class_">Random</span>()) : rnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">random</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> randomNumberGenerator;</span><br><span class="line">    <span class="keyword">if</span> (rnd == <span class="literal">null</span>) rnd = initRNG();</span><br><span class="line">    <span class="keyword">return</span> rnd.nextDouble();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>Math</code>类维护了一个<code>Random</code>对象，然后每次调用它的<code>nextDouble</code>方法。这个<code>Random</code>对象是单例的，只有第一次访问的时候会创建这个对象。</p>
<h5 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h5><h6 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h6><p><code>Random</code>提供了更丰富的随机数方法，这些方法不是静态的。下面是一个简单的案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">println(rnd.nextInt());</span><br><span class="line">println(rnd.nextInt(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">1944456130</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><code>nextInt</code>方法会产生一个随机的<code>int</code>（可正可负）；<code>nextInt(100)</code>方法会产生一个随机的范围在<code>[0, 100)</code>的<code>int</code>。除了<code>nextInt</code>方法，还有以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextLong</span><span class="params">()</span>  <span class="comment">// 产生一个随机的 long</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">nextBoolean</span><span class="params">()</span>  <span class="comment">// 产生一个随机的 boolean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextBytes</span><span class="params">(<span class="type">byte</span>[] bytes)</span>  <span class="comment">// 产生一堆随机字节填满数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">float</span> <span class="title function_">nextFloat</span><span class="params">()</span>  <span class="comment">// 产生一个随机的范围在 [0， 1) 的 float</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">nextDouble</span><span class="params">()</span>  <span class="comment">// 产生一个随机的范围在 [0， 1) 的 double</span></span><br></pre></td></tr></table></figure>
<p><code>Random</code>除了默认构造之外，还有一个构造可以接受一个<code>long</code>类型的种子参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Random</span><span class="params">(<span class="type">long</span> seed)</span></span><br></pre></td></tr></table></figure>
<p>种子决定了随机产生的序列，种子相同，那么产生的序列就是相同的，看例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">20231214</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    print(rnd.nextInt(<span class="number">100</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">39</span> <span class="number">27</span> <span class="number">24</span> <span class="number">14</span> <span class="number">90</span> </span><br></pre></td></tr></table></figure>
<p>上面的程序不管执行多少次，结果都是<code>39 27 24 14 90</code>不会变，因为每次运行种子是一样的。我们除了在构造里面传递种子，还可以使用对应的<code>setter</code>设置种子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSeed</span><span class="params">(<span class="type">long</span> seed)</span></span><br></pre></td></tr></table></figure>
<p>使用种子的主要目的是为了实现可重复的随机，测试的时候可以复现场景。</p>
<h6 id="随机的基本原理"><a href="#随机的基本原理" class="headerlink" title="随机的基本原理"></a>随机的基本原理</h6><p><code>Random</code>产生的不是真随机数，而是基于种子的伪随机数。每次生成随机数的时候，先根据当前种子经过某种运算得出新种子，再使用新种子生成随机数。这也就是为什么，在运行环境一样的情况下，若初始种子是一样的，那么每次生成的随机数序列也是一样的。如果构造<code>Random</code>的时候没有传递种子，那么内部会生成一个种子，这个种子是真随机的。下面看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">seedUniquifier</span> <span class="operator">=</span> </span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">8682522807148012L</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Random</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(seedUniquifier() ^ System.nanoTime());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">seedUniquifier</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> seedUniquifier.get();</span><br><span class="line">        <span class="type">long</span> <span class="variable">next</span> <span class="operator">=</span> current * <span class="number">181783497276652981L</span>;</span><br><span class="line">        <span class="keyword">if</span>(seedUniquifier.compareAndSet(current, next))</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>种子是由<code>seedUniquifier()</code>与<code>System.nanoTime()</code>异或生成的。<code>System.nanoTime()</code>返回纳秒级的当前时间。<code>seedUniquifier()</code>相对复杂，它会先获取<code>seedUniquifier</code>的值存到<code>current</code>中，然后将其与一个常数相乘存到<code>next</code>中，若<code>next</code>与<code>current</code>的值不一样就更新<code>seedUniquifier</code>并将<code>next</code>作为返回值。程序里面使用死循环以及<code>compareAndSet</code>方法主要为了确保在多线程情况不会出现两次一样的随机数。<br>当我们有了种子之后，随机数是怎么生成的？我们看一些代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> next(<span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextLong</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ((<span class="type">long</span>)(next(<span class="number">32</span>)) &lt;&lt; <span class="number">32</span>) + next(<span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">float</span> <span class="title function_">nextFloat</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> next(<span class="number">24</span>) / ((<span class="type">float</span>)(<span class="number">1</span> &lt;&lt; <span class="number">24</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">nextBoolean</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> next(<span class="number">1</span>) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他们都是在<code>next(int bits)</code>的基础上做些变换，这个方法是用来生成指定位数的随机数的，下面我们看看源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">multiplier</span> <span class="operator">=</span> <span class="number">0x5DEECE66DL</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">addend</span> <span class="operator">=</span> <span class="number">0xBL</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">mask</span> <span class="operator">=</span> (<span class="number">1L</span> &lt;&lt; <span class="number">48</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">(<span class="type">int</span> bits)</span> &#123;</span><br><span class="line">    <span class="type">long</span> oldseed, nextseed;</span><br><span class="line">    <span class="type">AtomicLong</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="built_in">this</span>.seed;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        oldseed = seed.get();</span><br><span class="line">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码主要使用公式<code>(oldseed * multiplier + addend) &amp; mask</code>生成新种子，这个公式表示对旧种子乘以某个数（multiplier）再加上某个数（addend），最后取低 48 位。最后的随机数就是新种子的高<code>bits</code>位。这种方法有一个名字叫做线性同余随机数生成器（linear congruential pseudorandom number generator）。</p>
<h6 id="随机验证码-密码"><a href="#随机验证码-密码" class="headerlink" title="随机验证码&#x2F;密码"></a>随机验证码&#x2F;密码</h6><p>随机验证码一般由 6 位数字组成，以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成 n 位验证码，每一位都是数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateVRCode</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        chars[i] = (<span class="type">char</span>) (<span class="string">&#x27;0&#x27;</span> + rnd.nextInt(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">vrcode</span> <span class="operator">=</span> generateVRCode(<span class="number">6</span>);</span><br><span class="line">    System.out.println(vrcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>密码由数字、字母、特殊符号组成，以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPECIAL_CHARS</span> <span class="operator">=</span> <span class="string">&quot;!@#$%^&amp;*_=+-/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">nextChar</span><span class="params">(Random rnd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> rnd.nextInt(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">char</span>) (<span class="string">&#x27;0&#x27;</span> + rnd.nextInt(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + rnd.nextInt(<span class="number">26</span>));</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">char</span>) (<span class="string">&#x27;A&#x27;</span> + rnd.nextInt(<span class="number">26</span>));</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> SPECIAL_CHARS.charAt(rnd.nextInt(SPECIAL_CHARS.length()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generatePwd</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        chars[i] = nextChar(rnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> generatePwd(<span class="number">8</span>);</span><br><span class="line">    System.out.println(pwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于一些复杂的密码要求至少一位大写字母、小写字母、特殊符号、数字，其它的随机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPECIAL_CHARS</span> <span class="operator">=</span> <span class="string">&quot;!@#$%^&amp;*_=+-/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机返回一个没有内容的下标</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">char</span>[] chars, Random rnd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] idxes = <span class="keyword">new</span> <span class="title class_">int</span>[chars.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chars[i] &gt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        idxes[n++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idxes[rnd.nextInt(n)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">nextNumber</span><span class="params">(Random rnd)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>) (<span class="string">&#x27;0&#x27;</span> + rnd.nextInt(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">nextLowerLetter</span><span class="params">(Random rnd)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + rnd.nextInt(<span class="number">26</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">nextUpperLetter</span><span class="params">(Random rnd)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>) (<span class="string">&#x27;A&#x27;</span> + rnd.nextInt(<span class="number">26</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">nextSpecialChar</span><span class="params">(Random rnd)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SPECIAL_CHARS.charAt(rnd.nextInt(SPECIAL_CHARS.length()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">nextChar</span><span class="params">(Random rnd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> rnd.nextInt(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span> -&gt; nextNumber(rnd);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> -&gt; nextLowerLetter(rnd);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span> -&gt; nextUpperLetter(rnd);</span><br><span class="line">        <span class="keyword">default</span> -&gt; nextSpecialChar(rnd);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generatePwd</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    chars[nextIndex(chars, rnd)] = nextNumber(rnd);</span><br><span class="line">    chars[nextIndex(chars, rnd)] = nextLowerLetter(rnd);</span><br><span class="line">    chars[nextIndex(chars, rnd)] = nextUpperLetter(rnd);</span><br><span class="line">    chars[nextIndex(chars, rnd)] = nextSpecialChar(rnd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chars[i] &gt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        chars[i] = nextChar(rnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> generatePwd(<span class="number">8</span>);</span><br><span class="line">    System.out.println(pwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="洗牌"><a href="#洗牌" class="headerlink" title="洗牌"></a>洗牌</h6><p>洗牌就是将数组里面的元素打乱顺序，看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">int</span>[] nums, Random rnd)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> rnd.nextInt(i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[idx];</span><br><span class="line">        nums[idx] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    shuffle(nums, rnd);</span><br><span class="line">    System.out.println(Arrays.toString(nums));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>洗牌的基本思路就是从后往前每个元素与它前面的随机一个元素交换。</p>
<h6 id="带权重的随机"><a href="#带权重的随机" class="headerlink" title="带权重的随机"></a>带权重的随机</h6><p>实际场景中，带权重随机还是比较常见的。比如抽奖有一、二、三等奖这三种奖项，它们抽中的概率分别是 10%、20%、70%。我们实现的基本思路是使用累积分布概率，这个例子里面我们随机一个<code>[0,1)</code>的小数<code>n</code>，看它的范围：</p>
<ul>
<li><code>n∈[0, 10%)</code>就是一等奖；</li>
<li><code>n∈[10%, 30%)</code>就是二等奖；</li>
<li><code>n∈[30%, 1)</code>就是三等奖；</li>
</ul>
<p>我们首先定义一个类<code>Pair</code>表示奖品和奖品对应的权重：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object item;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(Object item, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = item;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getItem</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们定义一个带权随机类<code>WeightRandom</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WeightRandom</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Pair[] options;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span>[] cmPro;  <span class="comment">//cumulativeProbabilities;</span></span><br><span class="line">    <span class="keyword">private</span> Random rnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeightRandom</span><span class="params">(Pair[] options)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rnd = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="built_in">this</span>.options = options;</span><br><span class="line">        initCumulativeProbabilities();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initCumulativeProbabilities</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">weights</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Pair option : options) &#123;</span><br><span class="line">            weights += option.getWeight();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.cmPro = <span class="keyword">new</span> <span class="title class_">double</span>[options.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; options.length; ++i) &#123;</span><br><span class="line">            sum += options[i].getWeight();</span><br><span class="line">            cmPro[i] = sum / weights;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">nextItem</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">n</span> <span class="operator">=</span> rnd.nextDouble();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> Arrays.binarySearch(cmPro, n);</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            idx = -idx - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> options[idx].getItem();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>nextItem</code>方法里面可以使用循环从前到后寻找，我们给定的寻找方案是使用二分查找。因为概率累积数组本就是递增的，而且就算找不到函数的返回值表示应该插入在哪个位置。</p>
<h6 id="抢红包算法"><a href="#抢红包算法" class="headerlink" title="抢红包算法"></a>抢红包算法</h6><p>给定一个钱数和人数，设计一个抢红包算法，每个人最少 0.01 元。我们有如下思路：<br>每次分配金额的时候，根据人数和钱数计算出平均金额<code>avg</code>。然后每个人的红包金额在范围<code>[0.01, 2 * avg)</code>，除此之外还有一些特殊情况需要考虑：</p>
<ol>
<li>只剩最后一个人时，这个人获得所有金钱。</li>
<li>每次金额随机出来时，我们至少要确保剩下的人每人都还能分得 0.01。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomPacket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;</span><br><span class="line">    <span class="keyword">private</span> Random rnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RandomPacket</span><span class="params">(<span class="type">int</span> num, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (money &lt; num * <span class="number">0.01</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;money &lt; num * 0.01&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">        <span class="built_in">this</span>.rnd = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">double</span> m;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            m = money;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> money / num * <span class="number">2</span>;</span><br><span class="line">            m = rnd.nextDouble() * max;</span><br><span class="line">            m = Math.round(m * <span class="number">100</span>) / <span class="number">100.0</span>;</span><br><span class="line">            System.err.println(m);</span><br><span class="line">            m = Math.max(m, <span class="number">0.01</span>);</span><br><span class="line">            m = Math.min(m, money - (num - <span class="number">1</span>) * <span class="number">0.01</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.num--;</span><br><span class="line">        <span class="built_in">this</span>.money -= m;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p><code>**Random**</code><strong>类是线程安全的</strong>，但在并发很高的情况下会产生竞争，此时建议考虑<code>ThreadLocalRandom</code>类。除此之外，<code>SecureRandom</code>类可以产生安全性更高、随机性更强的随机数，用于安全加密等领域。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/18/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8802%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/03/18/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8802%EF%BC%89/" itemprop="url">Java 基础系列（02）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-03-18T12:03:52+08:00">
                2023-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="类的扩展"><a href="#类的扩展" class="headerlink" title="类的扩展"></a>类的扩展</h3><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>我们在日常生活中，很多时候我们更关注能力而不是对象本身。比如我想要拍照，我关注的是“拍照”这个能力，至于使用什么设备并不重要。再比如比较的能力，同一个类对象之间甚至不同类对象之间都有可能进行比较，比如手机和平板都可以拍照，那谁拍照更厉害点？</p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>接下来我们假设有手机、平板若干，想要从这些设备里面选出拍照能力最强的设备。不同类别设备之间比较可以写方法来实现，但是类别较多的时候得写多少方法？下面看看使用接口的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PhotoAble</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">takePhoto</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">photoAbility</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(PhotoAble o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们使用<code>interface</code>关键字定义了接口<code>PhotoAble</code>，这个接口定义了一些方法分别表示：拍照行为、计算设备拍照能力值、拍照设备之间比较。<br>比较的对象仍然是可拍照设备。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">PhotoAble</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Phone</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takePhoto</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;拍照&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">photoAbility</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 复杂的拍照能力逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(PhotoAble o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> photoAbility() - o.photoAbility();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pad</span> <span class="keyword">implements</span> <span class="title class_">PhotoAble</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pad</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takePhoto</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;平板拍照&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">photoAbility</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 复杂的拍照能力逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(PhotoAble o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> photoAbility() - o.photoAbility();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们定义了手机和平板类，它们都实现（implements）可拍照接口。<code>compareTo</code>方法返回一个整数，用这个整数的符号表示两个对象的大小关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Pad</span> <span class="variable">pad</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pad</span>(<span class="string">&quot;平板&quot;</span>);</span><br><span class="line">    <span class="type">Phone</span> <span class="variable">phone1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>(<span class="string">&quot;手机1&quot;</span>);</span><br><span class="line">    <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>(<span class="string">&quot;手机2&quot;</span>);</span><br><span class="line">    PhotoAble[] devices = <span class="keyword">new</span> <span class="title class_">PhotoAble</span>[]&#123;pad, phone1, phone2&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">PhotoAble</span> <span class="variable">max</span> <span class="operator">=</span> devices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (PhotoAble pa : devices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max.compareTo(pa) &lt; <span class="number">0</span>) max = pa;</span><br><span class="line">    &#125;</span><br><span class="line">    max.takePhoto();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试方法里面把一堆设备放到<code>PhotoAble</code>数组中，然后找出能力值最强的设备，并使用这个设备拍照。</p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ol>
<li>Java 使用<code>interface</code>关键字定义接口，使用<code>implements</code>关键字实现接口。</li>
<li>接口内可以声明一些方法，接口方法不需要加修饰符，默认都是<code>public abstract</code>。在 Java8 之前，接口内不能实现方法。</li>
<li>Java 继承只能是单继承，但是实现的接口可以是多个，表明这个类有多项能力。</li>
</ol>
<h5 id="接口的细节"><a href="#接口的细节" class="headerlink" title="接口的细节"></a>接口的细节</h5><ol>
<li>接口中是可以定义变量的，修饰符可以省略。省不省略修饰符都是<code>public static final</code>。</li>
<li>接口之间是可以继承的，而且接口的继承可以是多继承，也是使用<code>extends</code>关键字。当类实现接口的时候必须把该接口及其父接口的所有方法都实现一遍。</li>
<li>类可以同时继承父类与实现接口，但若是同时存在继承必须在前面，例如<code>class A extends B implements C, D &#123;&#125;</code>。</li>
<li>我们一样可以使用<code>instanceof</code>关键字来判断某对象是否实现了接口，例如<code>p instanceof A</code>。</li>
</ol>
<h5 id="使用接口替代继承"><a href="#使用接口替代继承" class="headerlink" title="使用接口替代继承"></a>使用接口替代继承</h5><p>记得上面的“添加数字求和”案例，之前使用继承会破坏代码的封装性。于是后面说使用组合，在<code>Child</code>类中引用<code>Base</code>类对象，这样就可以保护封装性。但这样<code>Base</code>与<code>Child</code>就没有办法统一处理。现在，为了解决这个问题，就可以定义接口来做到统一处理。于是最后就变成<code>组合+接口</code>替换继承。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IAdd</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> number)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] numbers)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">implements</span> <span class="title class_">IAdd</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> number)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">implements</span> <span class="title class_">IAdd</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> number)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="接口增强"><a href="#接口增强" class="headerlink" title="接口增强"></a>接口增强</h5><p>Java8 之前，接口中的方法都是抽象方法，不能有实现。Java8 则对接口做了一些增强，允许接口里面定义静态方法和默认方法。看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IAdd</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 默认方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> number)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] numbers)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态方法和默认方法都有方法体，静态方法可以通过接口名直接调用，例如<code>IAdd.test()</code>。默认方法使用关键字<code>default</code>关键字修饰，实现类可以选择不实现默认方法，直接使用默认的实现。引入默认方法的原因是某些接口已经被人实现，那么此时我需要往接口里面添加方法，那么所有的实现类都必须做适配处理，比较麻烦。<br>Java8 中静态方法和默认方法都必须是<code>public</code>，Java9 去除了这个限制，可以使用<code>private</code>。静态方法直接把修饰符从<code>public</code>改为<code>private</code>即可；但对于默认方法而言，<code>private</code>和<code>default</code>两个关键字不同一起使用，可以直接定义私有方法，例如<code>private void test() &#123;&#125;</code>。允许定义私有方法主要方便公开的方法复用代码。</p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类就是抽象的类，抽象类不能创建对象，它一般用于表达抽象的概念。例如圆形是具体的类，但图形是抽象的；苹果是具体的，水果就是抽象的等等。<br>之前说的<code>Shape</code>类，里面有一个<code>draw</code>方法。但对于图形来说，绘制是一件不知道如何实现的方法，只有具体的子类才能绘制。因此<code>Shape</code>就可以定义成抽象类，<code>draw</code>可以定义为抽象方法。抽象方法就是只有申明而没有实现的方法，接口里面的方法基本都是抽象的。抽象使用关键字<code>abstract</code>来表示，有抽象方法的类一定是抽象类，但抽象类不一定有抽象方法。<br>从形式上看，抽象类和接口很相似，有冗余的嫌疑。但实际上抽象类往往和接口互相配合，接口声明能力，抽象类提供默认实现。那有人问，接口有默认方法来提供默认实现，那么抽象类是不是就不需要了？并不是这样，首先抽象类是类，也就是说我们可以在抽象类里面正常定义实例变量之类的，这是接口做不到的。<br>对于实现接口的类来说，它可以选择自己实现接口或者选择继承抽象类。继承抽象类主要好处就是代码复用，但如果这个类已经有父类了，那么只能选择实现接口，因为 Java 类之间是单继承的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IAdd</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> number)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] numbers)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAdder</span> <span class="keyword">implements</span> <span class="title class_">IAdd</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">            add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span> <span class="keyword">extends</span> <span class="title class_">AbstractAdder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_NUM</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[MAX_NUM];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= MAX_NUM) <span class="keyword">return</span>;</span><br><span class="line">        numbers[count++] = number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>定义在一个类内部的类称为内部类，包含它的类称为外部类。内部类可以很方便访问外部类的私有变量，并且内部类本身可以定义为私有，这样就可以对外隐藏。但实际上，内部类只是编译器的概念，对 Java 虚拟机来说没有这样的概念，每一个内部类最后都会被编译成独立的类。内部类主要分为：</p>
<ol>
<li>静态内部类；</li>
<li>成员内部类；</li>
<li>方法内部类；</li>
<li>匿名内部类；</li>
</ol>
<p>下面我们一一讨论这些内部类。</p>
<h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5><p>静态内部类和静态变量、静态方法定义的位置是一样的，只不过定义的是类。看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">shared</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            shared++;</span><br><span class="line">            System.out.println(<span class="string">&quot;inner: &quot;</span> + shared);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;outer: &quot;</span> + shared);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态内部类与独立的类差别不大，可以有静态变量、静态方法、实例变量、实例方法、构造方法等。静态内部类可以访问外部类的<strong>静态变量</strong>与<strong>静态方法</strong>（私有的也能访问），但不可访问外部类的实例变量与实例方法。当内部类与外部类有变量同名的时候，需要使用<code>外部类.变量名</code>的方式使用。<br>外部类里面使用静态内部类，直接使用<code>new StaticInner()</code>即可。非私有的静态内部类可以被其它类访问，需要使用<code>外部类.静态内部类</code>的方式使用。看下面位于一个独立的类中的测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">    Outer.<span class="type">StaticInner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticInner();</span><br><span class="line">    outer.show();</span><br><span class="line">    inner.test();</span><br><span class="line">    outer.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们说，外部类和内部类最后都会被编译成两个独立的类。那么独立出来是怎么访问外部类的私有静态变量的？我们看看具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">shared</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Outer$StaticInner</span> <span class="variable">si</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer$StaticInner</span>();</span><br><span class="line">        si.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> access$<span class="number">0</span>()&#123;</span><br><span class="line">    	<span class="keyword">return</span> shared;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部类的名字会加上外部类名的前缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer$StaticInner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;inner &quot;</span> + Outer.access$<span class="number">0</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了让内部类访问到外部类的私有静态变量或私有静态方法，单独为外部类添加帮忙访问的静态方法。<br>静态内部类主要的使用场景：当我们类内部需要某种数据结构，而又不依赖外部类的具体实例，就可以使用静态内部类。比如外部类有一个方法需要返回数组里的最大值和最小值，那么我们可以定义一个静态内部类<code>Pair</code>用来存储最大值和最小值。之所以不把<code>Pair</code>分离成一个独立的类，是因为这个名字比较普遍，若是其他人也需要定义类似名字的变量比较麻烦。<br>Java API 中<code>LinkedList</code>类中就有一个私有静态内部类<code>Node</code>表示链表的节点。</p>
<h5 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h5><p>从形式上说，今天内部类和成员内部类的区别仅仅是没有<code>static</code>关键字修饰。但两者实际差距很大，看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">shared</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            Outer.shared++;</span><br><span class="line">            show();</span><br><span class="line">            System.out.printf(<span class="string">&quot;inner:%d, %d\n&quot;</span>, a, Outer.<span class="built_in">this</span>.a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;outer:%d, %d\n&quot;</span>, a, shared);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与静态内部类不同，成员内部类除了可以访问外部类的静态变量与静态方法还能访问外部类的成员变量与成员方法（不管是否私有都可以）。内外两个类存在变量或方法重名的时候，可以使用<code>外部类.变量名</code>的方式访问外部类的静态变量或静态方法，也可以使用<code>外部类.this.变量名</code>的方式访问外部类的实例变量或实例方法。<br>在外部类里面想要使用成员内部类，直接使用<code>new Inner()</code>即可。非私有的成员内部类可以被其它类访问，但不能直接通过外部类名来访问，而是需要借助外部类的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">    Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    inner.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要在其它类里面创建成员内部类对象需要使用<code>外部类对象.new 内部类()</code>的方式。<br>具体的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;action&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Outer$Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer$Inner</span>(<span class="built_in">this</span>);</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> access$<span class="number">0</span>(Outer outer) &#123;</span><br><span class="line">    	<span class="keyword">return</span> outer.a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> access$<span class="number">1</span>(Outer outer) &#123;</span><br><span class="line">    	outer.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer$Inner</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Outer outer;</span><br><span class="line">    <span class="keyword">public</span> Outer$Inner(Outer outer)&#123;</span><br><span class="line">    	ths.outer = outer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;outer a &quot;</span> + Outer.access$<span class="number">0</span>(outer));</span><br><span class="line">        Outer.access$<span class="number">1</span>(outer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员内部类在创建的时候会得到一个外部类的实例的引用，后期便可以通过它来访问实例变量与实例方法。应用场景：当内部类与外部类关系密切，需要使用外部类的实例变量或实例方法，那么定义为成员内部类比较合适。</p>
<h5 id="方法内部类"><a href="#方法内部类" class="headerlink" title="方法内部类"></a>方法内部类</h5><p>定义在方法体里面的内部类称为方法内部类，看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">shared</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> param)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;HH&quot;</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">                a++;</span><br><span class="line">                shared++;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(shared);</span><br><span class="line">                System.out.println(param);</span><br><span class="line">                System.out.println(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部类<code>Inner</code>定义在方法体里面，这个类只有在该方法内部可以使用。如果外部方法是静态的，那么内部类仅可以访问外部类的静态变量与静态方法；如果外部方法是实例方法，那么内部类可以访问外部类的静态变量、静态方法、实例变量、实例方法。不论外部方法是不是静态的，内部类都可以访问方法的参数与局部变量，前提是该参数或变量是<code>final</code>的或实际上是<code>final</code>的（没有修改）。<br>方法内部类访问外部类的成员变量的方式与上面其它内部类是一样，那局部变量或参数是怎么访问的呢？为什么要加上只能<code>final</code>的限制呢？<br>答：实际上，方法内部类在实例化的时候会把用到的参数与局部变量作为参数传到内部类里面。因此实际上，内部类访问到的局部变量和参数都是副本，根本和外部方法里面的变量不是同一个。所以你在内部类修改局部变量是不影响外面的，为了防止出现误解，故要求能访问的参数或局部变量必须要<code>final</code>的或者实际<code>final</code>的。你实在想在方法内部类里面修改外面的局部变量，那么就传一个数组进去，然后修改数组元素。</p>
<h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><p>匿名内部类没有单独的类定义，它是在创建对象的同时定义类。语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类(构造列表) &#123;</span><br><span class="line">	<span class="comment">// 内部实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父接口() &#123;</span><br><span class="line">    <span class="comment">// 内部实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一个以<code>Point</code>类为父类的匿名内部类的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>, y = <span class="number">1</span>;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> distance(<span class="keyword">new</span> <span class="title class_">Point</span>(x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(p.distance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们这边创建了一个匿名内部类，其父类是<code>Point</code>。这个内部类重写了<code>distance</code>方法，并在方法里访问了外部方法的局部变量。<br>匿名内部类只能使用一次，创建一个对象。它没有名字，没有构造，可以调用对应的父类构造。它可以定义实例变量与实例方法，也可以有初始化代码块。与其它内部类相似，它可以访问外部类所有的变量与方法，同时也可以访问外部方法的<code>final</code>局部变量与参数。<br>这个例子的内部实现类似于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer$1</span> <span class="keyword">extends</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x2;</span><br><span class="line">    <span class="type">int</span> y2;</span><br><span class="line">    Outer outer;</span><br><span class="line">    Outer$<span class="number">1</span>(Outer outer, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)&#123;</span><br><span class="line">        <span class="built_in">super</span>(x1,y1);</span><br><span class="line">        <span class="built_in">this</span>.outer = outer;</span><br><span class="line">        <span class="built_in">this</span>.x2 = x2;</span><br><span class="line">        <span class="built_in">this</span>.y2 = y2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> distance(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="built_in">this</span>.x2, y2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很多方法调用的时候有个参数是接口类型，此时匿名内部类使用也较多。比如比较方法里面需要一个参数是<code>Comparator</code>类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">        <span class="comment">// 比较逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>枚举是一种特殊的类型，它的取值是有限的。比如一周七天，一年四季。枚举的定义和使用很简单，下面使用表示大小的枚举来举例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    SMALL, MEDIUM, BIG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子定义了一个枚举类，名字叫<code>Size</code>。它有三种取值，分别是：<code>SMALL</code>、<code>MEDIUM</code>、<code>BIG</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Size</span> <span class="variable">size</span> <span class="operator">=</span> Size.SMALL;</span><br><span class="line">System.out.println(size.name());</span><br><span class="line">System.out.println(size.toString());</span><br></pre></td></tr></table></figure>
<p>要取枚举类里面定义的值来给枚举变量赋值。我们可以使用<code>name</code>和<code>toString</code>方法返回枚举值的字面量，这边返回字符串<code>SMALL</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(size == Size.BIG);</span><br><span class="line">println(size.equals(Size.BIG));</span><br></pre></td></tr></table></figure>
<p>枚举变量之间可以进行比较，可以使用<code>equals</code>方法也可以直接使用<code>==</code>进行比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(size.ordinal());</span><br></pre></td></tr></table></figure>
<p>调用<code>ordinal</code>方法可以返回枚举量的序号（从 0 开始编号）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(size.compareTo(Size.BIG));</span><br></pre></td></tr></table></figure>
<p>枚举类型都实现了<code>Comparable</code>接口，因此可以调用<code>compareTo</code>方法返回两个变量的大小关系，比较的依据是两个变量的序号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (size) &#123;</span><br><span class="line">    <span class="keyword">case</span> SMALL:</span><br><span class="line">        println(<span class="string">&quot;SMALL&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类型可以使用<code>switch</code>语句，但是在<code>case</code>里面直接写值即可，不需要添加类名前缀。例如可以写<code>case BIG</code>而不是<code>case Size.BIG</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Size</span> <span class="variable">s</span> <span class="operator">=</span> Size.valueOf(<span class="string">&quot;SMALL&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Size s : Size.values()) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类有静态方法：</p>
<ul>
<li><code>valueOf</code>方法根据字面量返回枚举类型。</li>
<li><code>values</code>方法按序返回所有的枚举值。</li>
</ul>
<p>上面普通枚举类型将会被编译器转换成具体的类，转换后的代码大致如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Size</span> <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;Size&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Size</span> <span class="variable">SMALL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Size</span>(<span class="string">&quot;SMALL&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Size</span> <span class="variable">MEDIUM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Size</span>(<span class="string">&quot;MEDIUM&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Size</span> <span class="variable">LARGE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Size</span>(<span class="string">&quot;LARGE&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Size[] VALUES = <span class="keyword">new</span> <span class="title class_">Size</span>[]&#123;SMALL,MEDIUM,LARGE&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Size</span><span class="params">(String name, <span class="type">int</span> ordinal)</span>&#123;</span><br><span class="line">    	<span class="built_in">super</span>(name, ordinal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Size[] values()&#123;</span><br><span class="line">        Size[] values = <span class="keyword">new</span> <span class="title class_">Size</span>[VALUES.length];</span><br><span class="line">        System.arraycopy(VALUES, <span class="number">0</span>, values, <span class="number">0</span>, VALUES.length);</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Size <span class="title function_">valueOf</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> Enum.valueOf(Size.class, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个类将会继承于<code>Enum</code>类，<code>Enum</code>类有两个实例变量<code>name</code>和<code>ordinal</code>，在构造里需要传递。<code>Enum</code>类的<code>name()、toString()、ordinal()、compareTo()、equals()</code>都是基于这两个变量实现的。<br>上面我们只是介绍了最简单的枚举应用，在日常使用中，枚举值很可能有缩写或其它的别名。此时代码可以改成下面的样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    SMALL(<span class="string">&quot;S&quot;</span>, <span class="string">&quot;小号&quot;</span>),</span><br><span class="line">    MEDIUM(<span class="string">&quot;M&quot;</span>, <span class="string">&quot;中号&quot;</span>),</span><br><span class="line">    BIG(<span class="string">&quot;L&quot;</span>, <span class="string">&quot;大号&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String abbr;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    Size(String abbr, String title) &#123;</span><br><span class="line">        <span class="built_in">this</span>.abbr = abbr;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Size <span class="title function_">fromAbbr</span><span class="params">(String abbr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Size size : values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (size.abbr.equals(abbr)) <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAbbr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> abbr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们给枚举类型添加了两个属性<code>abbr</code>和<code>title</code>，它们分别表示缩写和中文名称。</li>
<li>把这两个属性加到构造方法里面，注意：因为枚举变量的值是固定的，所以这个构造只能是私有的，不能被外人调用，<code>private</code>修饰符可以省略。</li>
<li>为了方便，我们定义了一个根据缩写返回对应枚举值的静态方法。</li>
<li>此时，我们在定义枚举值的时候需要：<ul>
<li>枚举值必须定义在类的最上面。</li>
<li>枚举值定义的时候，需要以构造的方式传参。</li>
</ul>
</li>
<li>使用还是老样子<code>Size s = Size.BIG;</code>或者<code>Size s = Size.fromAbbr(&quot;L&quot;);</code>。</li>
</ul>
<p>这种情况下编译器转换的源码大致如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Size</span> <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;Size&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Size</span> <span class="variable">SMALL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Size</span>(<span class="string">&quot;SMALL&quot;</span>,<span class="number">0</span>, <span class="string">&quot;S&quot;</span>, <span class="string">&quot;小号&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Size</span> <span class="variable">MEDIUM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Size</span>(<span class="string">&quot;MEDIUM&quot;</span>,<span class="number">1</span>,<span class="string">&quot;M&quot;</span>,<span class="string">&quot;中号&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Size</span> <span class="variable">LARGE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Size</span>(<span class="string">&quot;LARGE&quot;</span>,<span class="number">2</span>,<span class="string">&quot;L&quot;</span>,<span class="string">&quot;大号&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> String abbr;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Size</span><span class="params">(String name, <span class="type">int</span> ordinal, String abbr, String title)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name, ordinal);</span><br><span class="line">        <span class="built_in">this</span>.abbr = abbr;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下，每个枚举值都会关联一个<code>id</code>值。一个自然的想法是使用<code>ordinal</code>，如果这样写会有一个隐患：如果枚举变量的<code>id</code>已经被存储到了其它地方（例如数据库），我们这时准备再添加一个枚举值，那么就有可能改变枚举值的<code>ordinal</code>，那么存储的<code>id</code>就可能对应错误的枚举值。合理的做法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    XSMALL(<span class="number">10</span>), SMALL(<span class="number">20</span>), MEDIUM(<span class="number">30</span>), LARGE(<span class="number">40</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Size</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">    	<span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>程序运行过程中会遇到许许多多的问题，比如内存耗尽、网络异常、使用未初始化的变量等。这些非正常的情况，在 Java 里面都认作异常。</p>
<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p>下面的案例，我们在字符串<code>s</code>为空的情况下调用方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    s.indexOf(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果类似于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException:</span><br><span class="line">	at com.luyan.Main.main(Main.java:<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>这个输出告诉我们<code>Main</code>类的<code>main</code>方法里面第 6 行出问题了。主要是<code>null</code>不能调用方法，所以程序没法继续执行下去了。这时就启动异常处理机制：</p>
<ol>
<li>首先创建异常对象<code>NullPointerException</code>（空指针异常）。</li>
<li>然后查看谁能处理这个异常，没有人处理就启用默认机制。</li>
<li>默认打印异常栈并结束程序，因为是结束程序，所以出错代码后面的代码是运行不到的。</li>
</ol>
<p>很多时候默认的处理机制我们并不满意，我们可以使用<code>try/catch</code>来捕获异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        s.indexOf(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串为 null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用<code>try</code>块将可能出异常的代码块括起来，然后使用<code>catch</code>块捕获异常。当程序抛出<code>NullPointerException</code>异常的时候会被捕获，然后执行<code>catch</code>内部的代码。因为异常被处理了，所以不会启用默认机制，因此程序也不会退出，后面的代码也能继续执行。</p>
<h4 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h4><p>Java 里定义了许多异常类，例如上面见到的<code>NullPointerException</code>。所有的异常类都继承于<code>Throwable</code>，下面我们一一介绍。</p>
<h5 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h5><p><code>Throwable</code>是所有异常类的父类，它有 4 个公开的构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Throwable</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Throwable</span><span class="params">(String message)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Throwable</span><span class="params">(String message, Throwable cause)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Throwable</span><span class="params">(Throwable cause)</span></span><br></pre></td></tr></table></figure>
<p>构造的参数主要有两个：一个是<code>message</code>，表示异常信息；一个是<code>cause</code>，表示触发该异常的其它异常。异常可以构成一个异常链，上层异常由底层异常触发，<code>cause</code>就表示底层异常。除了构造方法外，<code>Throwable</code>还有一个方法<code>Throwable initCause(Throwable cause)</code>来设置<code>cause</code>，这个方法最多给<strong>调用一次</strong>。<br><code>Throwable</code>类有一个很重要的方法<code>fillInStackTrace()</code>，这个方法会在所有的构造里面调用，它表示将异常信息保存，这是我们能看到异常栈的关键。除此之外，<code>Throwable</code>还有一些查看异常信息的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printStackTrace</span><span class="params">()</span>  <span class="comment">// 打印异常栈信息到标准错误输出流</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印异常栈信息到指定的流</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printStackTrace</span><span class="params">(PrintStream s)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printStackTrace</span><span class="params">(PrintWriter s)</span></span><br><span class="line"></span><br><span class="line">String <span class="title function_">getMessage</span><span class="params">()</span>  <span class="comment">// 获取异常 message</span></span><br><span class="line">Throwable <span class="title function_">getCause</span><span class="params">()</span>  <span class="comment">//឴ 获取异常 cause</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取异常栈每层的信息，每层信息包含文件名、类名、方法名、行号等信息</span></span><br><span class="line">StackTraceElement[] getStackTrace()</span><br></pre></td></tr></table></figure>
<h5 id="异常类体系"><a href="#异常类体系" class="headerlink" title="异常类体系"></a>异常类体系</h5><p>以<code>Throwable</code>为根，Java 定义了很多异常，部分异常如下图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1701430751923-2528ef15-0a29-48fc-8343-d808ef6299cc.png#averageHue=%23f0f0f0&clientId=u3e04a724-c595-4&from=paste&height=504&id=u52f6475f&originHeight=504&originWidth=958&originalType=binary&ratio=1&rotation=0&showTitle=false&size=152499&status=done&style=none&taskId=udfd5eb72-f315-4ca3-b1da-80a54b31bfb&title=&width=958" alt="image.png"><br><code>Throwable</code>有两个直接子类：<code>Error</code>和<code>Exception</code>。其中<code>Error</code>表示系统错误或资源耗尽，应用层不应该抛出或处理这样的异常。<code>Exception</code>表示应用程序错误，我们可以继承它或它的子类来自定义异常。<br><code>RuntimeException</code>叫做运行时异常，这个名字比较有误导性，因为其它的异常也都是运行时产生的。准确的说<code>RuntimeException</code>是未受检异常，所谓受检异常指的是强制要求程序员处理的异常，未受检异常则不强制。相比而言，<code>Exception</code>其它子类和它本身都是受检异常，所有<code>Error</code>则是未受检异常。<br>如此多的异常类相比<code>Throwable</code>这个基类而言并没有添加多少属性和方法，定义这么多异常，主要为了名字不同。因为异常的名字包含了错误的关键信息，取合适的名字可以增加代码的可读性。</p>
<h5 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h5><p>自定义异常只需要取一个合适的名字，然后选择一个合适的父类异常进行继承即可。自定义异常的受检性和其父类一致，一般来说自定义的异常我们也不会添加什么属性方法，只会写几个构造里面调用父类构造即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SelfException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SelfException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SelfException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SelfException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SelfException</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="catch-匹配"><a href="#catch-匹配" class="headerlink" title="catch 匹配"></a>catch 匹配</h5><p>我们在案例里面简单看了异常的捕获，实际上<code>catch</code>块可以有多个，表示捕获多种异常，看例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">// 可能出异常代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;not valid number&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(RuntimeException e)&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;runtime exception &quot;</span>+e.getMessage());</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当代码出异常的时候会查找能捕获的第一个<code>catch</code>块并执行里面的代码，其它<code>catch</code>里面的代码是不执行的。如果找不到能捕获的，此时后面的代码不会执行，会直接跳到上一层调用中继续查找，到最后都找不到就执行默认机制。<br>捕获异常的时候，若异常之间如有继承关系，则范围小的异常应该在上面，否则会报错的（因为大异常在上面，就没下面小异常的事情了）。这个例子里面使用了<code>e.getMessage()</code>和<code>e.printStackTrace()</code>获取&#x2F;输出异常信息。在实际应用中，我们会将异常信息保存在专门的日志文件里面而不是直接控制台输出。<br>当我们多种异常的处理方案是一样的时候，Java7 之后给我们提供了简化的语法<code>|</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 可能出异常代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionA | ExceptionB e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="重新抛出异常"><a href="#重新抛出异常" class="headerlink" title="重新抛出异常"></a>重新抛出异常</h5><p>在<code>catch</code>块里面处理完异常后，我们可以重新再抛出异常，可以抛出原来的，也可以抛出新建的异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">// 可能出异常代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;not valid number&quot;</span>);</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AppException</span>(<span class="string">&quot;输入格式不对&quot;</span>, e);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抛出新异常的时候，把当前异常作为<code>cause</code>传递给新异常。这样就形成一个异常链，调用者可以使用<code>getCause</code>方法获取到原来的异常。<br>为什么要重新抛出？因为当前代码不能完全处理这个异常，需要调用者进一步处理。<br>为什么抛出新异常？抛出新异常可能是因为当前异常不合适或者需要补充新信息。</p>
<h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><p><code>finally</code>是异常机制中重要的一部分，它可以跟在<code>catch</code>后面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">// 可能出异常代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">	<span class="comment">// 异常捕获</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="comment">// 无论有无异常都会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>若无异常发生，<code>finally</code>代码块在<code>try</code>块结束之后执行。</li>
<li>异常被捕获，则<code>finally</code>块在<code>catch</code>块之后执行。</li>
<li>有异常但没被捕获，<code>finally</code>块在异常抛给上层之前执行。</li>
</ol>
<p>因为这些特性，<code>finally</code>块一般用来释放资源，如数据库连接、文件流等。<br>在实际操作的时候，<code>catch</code>块可以没有，只有<code>try/finally</code>块，这表示出现异常时直接上抛，但<code>finally</code>里面的代码在出现异常的时候也要执行。<br>有个小细节，当我们在<code>try/catch</code>块里面返回变量<code>ret</code>的值时，此时我们在<code>finally</code>里面改变<code>ret</code>的值会怎样？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ret = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终还是返回 0，返回肯定还是在<code>finally</code>执行完毕之后才返回的。<br>原因是之前讲的，当遇到<code>return</code>之后，会先把返回值存起来，然后调用方获取存的值。<br>因此<code>finally</code>只是修改变量<code>ret</code>的值而不是返回值。<br>那如果<code>finally</code>里面有<code>return</code>呢？那么会返回<code>finally</code>里面的值。不仅如此，<code>finally</code>有返回值时还会掩盖掉上抛的异常，就像没有异常一样。除此之外，如果在<code>finally</code>里面抛出异常，原来的异常会被顶替掉，就消失了。基于此，我们应该避免在<code>finally</code>里面返回值或抛出异常。</p>
<h5 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h5><p>对于需要使用资源的场景，经典流程是在<code>finally</code>里面释放资源。Java7 支持了一种新语法，这称为<code>try-with-resources</code>，它能够自动关闭要释放的资源。这种语法针对实现了<code>AutoCloseable</code>接口的类对象。这个接口定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>try-with-resources</code>语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="type">AutoCloseable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Hello&quot;</span>)) &#123;</span><br><span class="line">	<span class="comment">// 使用资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>资源的定义放在<code>try</code>语句里面，我们无需在<code>finally</code>里面手动释放。系统会在执行完<code>try</code>之后自动调用对象的<code>close</code>方法。如果有多个资源，那么在<code>try</code>语句里面定义多个，使用<code>;</code>隔开。<br>Java9 之后可以把资源定义在外面，但要求资源是<code>final</code>或实际上是<code>final</code>的，如下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AutoCloseable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">AutoCloseable</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">try</span>(r; r2) &#123;</span><br><span class="line">	<span class="comment">// 使用资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h5><p>异常机制中有一个关键字<code>throw</code>，这个关键字用于代码抛出异常，例如<code>throw new IllegalArgumentException();</code>。<br>还有一个<code>throws</code>关键字与之很像，它用于声明一个方法可能抛出的异常。语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, NumberFormatException &#123;</span><br><span class="line">	<span class="comment">//主体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>throws</code>可以声明多个异常，异常间使用逗号隔开。它表示这个方法可能会抛出哪些异常，这些异常在方法内无法完全处理，需要调用者继续处理。但具体什么情况抛异常未知，因此我们应该将这些信息用注释的方式标注出来。<br>对于未受检异常不要求使用<code>throws</code>声明，但是受检异常必须声明然后才能抛出。受检异常声明之后可以不抛出，但抛出必须有声明。<br>若一个方法 A 调用了另一个有<strong>受检异常</strong>声明的方法 B，那么 A 必须要处理声明的受检异常（不受检异常不做要求）。处理的方式包括：</p>
<ol>
<li>使用<code>catch</code>捕获异常。</li>
<li>继续使用<code>throws</code>往上抛出。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/01/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8801%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/03/01/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8801%EF%BC%89/" itemprop="url">Java 基础系列（01）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-03-01T11:59:52+08:00">
                2023-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Java 语言有以下 4 类基本数据类型：</p>
<ol>
<li>整数类型：有 4 种整型<code>byte/short/int/long</code>，分别有不同的取值范围。</li>
<li>小数类型：有 2 种小数类型<code>float/double</code>，分别有不同的取值范围和精度。</li>
<li>字符类型：<code>char</code>类型，表示单个字符。</li>
<li>真假类型：<code>boolean</code>类型，表示逻辑真假。</li>
</ol>
<h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>整数类型有<code>byte/short/int/long</code>四种，它们分别占据<code>1/2/4/8</code>个字节，取值范围如下表所示：</p>
<table>
<thead>
<tr>
<th><strong>类型名</strong></th>
<th><strong>字节数</strong></th>
<th><strong>取值范围</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>byte</code></td>
<td>1</td>
<td>$-2^7\sim2^7-1$</td>
</tr>
<tr>
<td><code>short</code></td>
<td>2</td>
<td>$-2^{15}\sim2^{15}-1$</td>
</tr>
<tr>
<td><code>int</code></td>
<td>4</td>
<td>$-2^{31}\sim2^{31}-1$</td>
</tr>
<tr>
<td><code>long</code></td>
<td>8</td>
<td>$-2^{63}\sim2^{63}-1$</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">333</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">3232343433L</span>;</span><br></pre></td></tr></table></figure>
<p>给整数类型变量赋值直接使用<code>=</code>就好，有一点需要注意，当给<code>long</code>类型变量赋值时若常量的值超过了<code>int</code>的范围需要在后面加上字母<code>l</code>或<code>L</code>，因为整型常量的默认类型是<code>int</code>，会溢出。</p>
<h4 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h4><p>小数类型有<code>float/double</code>四种，它们分别占据<code>4/8</code>个字节，取值范围如下表所示：</p>
<table>
<thead>
<tr>
<th>类型名</th>
<th>字节数</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td><code>float</code></td>
<td>4</td>
<td>-3.4E+38<del>-1.4E-45 ∪ 1.4E-45</del>3.4E+38</td>
</tr>
<tr>
<td><code>double</code></td>
<td>8</td>
<td>-1.7E+308<del>-4.9E-324 ∪ 4.9E-324</del>1.7E+308</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">333.33</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">333.33F</span>;</span><br></pre></td></tr></table></figure>

<p>使用<code>=</code>直接给变量赋值，需要注意因为浮点数常量默认是<code>double</code>类型，所以给<code>float</code>类型赋值的时候若是常量越界了需要在后面加上<code>f</code>或<code>F</code>。</p>
<h4 id="真假类型"><a href="#真假类型" class="headerlink" title="真假类型"></a>真假类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">b = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>真假类型使用关键字<code>boolean</code>，我们直接使用<code>true</code>或<code>false</code>来赋值。</p>
<h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">z</span> <span class="operator">=</span> <span class="string">&#x27;学&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>字符类型使用<code>char</code>关键字，一个字符占 2 个字节，所以 Java 的字符变量里面即可以存英文字符也可以存中文字符。</p>
<h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>数组类型的三种初始化形式：</p>
<ol>
<li><code>int[] arr = &#123;1, 2, 3&#125;;``[]</code>表示数组类型，我们直接使用<code>&#123;&#125;</code>给初值。</li>
<li><code>int[] arr = new int[]&#123;1, 2, 3&#125;;</code>这种写法是上一种的完整版本。</li>
<li><code>int[] arr = new int[3];</code> 定义长度为 3 的整型数组，不给初值。</li>
</ol>
<p>前两种初值方法下，数组的长度由初值的个数决定，不能手动指定长度。最后一种方法只指定了数组长度，但并没有给初值，那么数组元素会有默认值：数字类型为 0，<code>boolean</code>类型为 false，字符类型为空字符。<br>和 C 不同，我们在定义数组的时候，数组长度可以使用变量指定：<code>int n = 10; int[] arr = new int[n];</code>。我们定义了一个数组，系统会为我们分配两段内存，一块是数组空间（存储数组元素的地方），一块是数组名所对应的空间（存储着数组空间的首地址）。所以本质上说，数组名存储的就是数组空间的首地址，也就是说我只要改变这个地址就可以让数组名指向另一段数组空间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> [] b = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">a = b;</span><br></pre></td></tr></table></figure>
<p>使用<code>a = b</code>将<code>a</code>指向<code>b</code>的数组空间即<code>&#123;4, 5, 6, 7&#125;</code>，也就是说此时<code>a</code>与<code>b</code>的指向是一样。而原来<code>a</code>的数组空间要是没人引用就会被垃圾回收。<br>因此我们可以发现，一个数组名可以指向各种各样长度的数组空间。</p>
<h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><p>Java 里面算术运算包含<code>+, -, *, /, %</code>，除此之外也有<code>++, --</code>。和 C 类似：</p>
<ol>
<li><code>/</code>在整数之间表示整除（向 0 取整、舍弃小数位），有浮点数参与运算的时候才会表示精确除法。</li>
<li><code>%</code>只能用在整型或字符型之间，即小数不能进行除法。</li>
<li><code>++, --</code>可以用在变量的前面或后面，主要体现在返回值不同。<code>++</code>在前就先<code>+1</code>再返回；<code>++</code>在后就先返回再<code>+1</code>。</li>
</ol>
<p>一些运算的注意事项：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果太大了，int 无法存下</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2147483647</span> * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// long 可以存下，但下面代码还是不对</span></span><br><span class="line"><span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2147483647</span> * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面才是正确的写法</span></span><br><span class="line"><span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2147483647</span> * <span class="number">2L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了避免整除，我们使用浮点操作数</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">4.0</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>给变量赋值的时候不应该越界存储。</li>
<li>如左边第二种情况，变量类型<code>long</code>可以存下运算结果，但最终结果仍然不对。因为右边两个操作数全是<code>int</code>，所以计算的时候会将结果当做<code>int</code>，这个时候结果已经越界了，所以赋值给变量 a 的结果是越界后的结果。</li>
<li>因此我们使用<code>2L</code>作为操作数，这样结果就是<code>long</code>类型了。</li>
</ol>
<h4 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h4><p>Java 里比较运算包括<code>&gt;, &gt;=, &lt;, &lt;=, ==, !=</code>，所有数值和字符之间的比较规则和 C 是一样的。<br>数组类型进行比较，比较的当然是两者存储的地址。只有当两个数组变量指向同一块数组空间的时候才会返回<code>true</code>，否则都是返回<code>false</code>。想要比较两个数组存储的元素是否全都一样只能使用循环自行比较。<br>所有的比较运算返回值类型都是<code>boolean</code>，和 C 不一样的是 Java 只能使用<code>true</code>和<code>false</code>表示真假，不能使用数字。</p>
<h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>逻辑运算的运算对象只能是<code>boolean</code>类型，结果也是<code>boolean</code>类型。Java 的逻辑运算符有：</p>
<ol>
<li>与<code>&amp;</code>：有假则假，不会短路。</li>
<li>或<code>|</code>：有真则真，不会短路。</li>
<li>非<code>!</code>：真假取反。</li>
<li>异或<code>^</code>：两者不同为<code>true</code>，两种相同为<code>false</code>。</li>
<li>短路与<code>&amp;&amp;</code>：有假则假，会短路。</li>
<li>短路或<code>||</code>：有真则真，会短路。</li>
</ol>
<h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><h4 id="if分支"><a href="#if分支" class="headerlink" title="if分支"></a><code>if</code>分支</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件<span class="number">1</span>) &#123;</span><br><span class="line">    语句块<span class="number">1</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件<span class="number">2</span>) &#123;</span><br><span class="line">    语句块<span class="number">2</span></span><br><span class="line">&#125; </span><br><span class="line">... </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    语句块n    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>n 个分支的<code>if</code>选择结构执行流程：</p>
<ol>
<li>自上而下判断条件，若判定为真则执行对应的语句块，整个流程结束。</li>
<li>若没有条件为真，则执行<code>else</code>代码块内容。</li>
<li><code>else if</code>和<code>else</code>块可以省略掉。</li>
<li>语句块里只有一条语句的时候，可以省略大括号（不建议）。</li>
</ol>
<p>对于简单的<code>if else</code>条件分支可以使用<code>?:</code>运算符来简写：<code>逻辑表达式 ? 表达式1: 表达式2</code>。这边逻辑表达式为真时会执行表达式1，否则执行表达式2。</p>
<h4 id="switch分支"><a href="#switch分支" class="headerlink" title="switch分支"></a><code>switch</code>分支</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        代码块<span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>, 值<span class="number">3</span>:</span><br><span class="line">        代码块<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> 值n-<span class="number">1</span>:</span><br><span class="line">        代码块n-<span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        代码块n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>n 个分支的<code>switch</code>选择结构执行流程：</p>
<ol>
<li>表达式的类型须为：byte、short、int、char、枚举和 String。</li>
<li>找到值与表达式值相同的<code>case</code>，执行这个<code>case</code>及之后的所有<code>case</code>。</li>
<li>没有匹配的就执行<code>default</code>及其后面所有<code>case</code>。</li>
<li>多个<code>case</code>对应同一个代码块的时候，可以合并成一个<code>case</code>，后面多个值使用逗号隔开。</li>
<li>可以使用<code>break</code>提前退出。</li>
</ol>
<p>一般来说使用<code>switch</code>效率比<code>if</code>要高，因为<code>if</code>条件是从上到下一一进行判断，而<code>switch</code>使用跳跃表能够减少判定的次数。每一种<code>case</code>都是一个整数，<code>String</code>会被哈希成整数，我们会创建一个数组将所有的<code>case</code>值排序后存进去，然后查找的时候使用二分查找提高查找效率。如果<code>case</code>值是连续的或者近似连续的，那么优化后直接根据下标查找更快。</p>
<h4 id="增强switch"><a href="#增强switch" class="headerlink" title="增强switch"></a>增强<code>switch</code></h4><p>传统<code>switch</code>具有穿透性质，每次都要使用<code>break</code>很不方便。增强的<code>switch</code>使用函数式编程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="keyword">switch</span> (dayOfWeek) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> -&gt; <span class="string">&quot;星期一&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span> -&gt; <span class="string">&quot;星期二&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span> -&gt; <span class="string">&quot;星期三&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span> -&gt; <span class="string">&quot;星期四&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span> -&gt; <span class="string">&quot;星期五&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span> -&gt; <span class="string">&quot;星期六&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span> -&gt; <span class="string">&quot;星期七&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(name);</span><br></pre></td></tr></table></figure>

<ol>
<li>每一个<code>case</code>后面使用箭头，箭头后面使用一条语句或一个语句块。</li>
<li>增强的<code>switch</code>可以作为一个语句存在，此时它有返回值，可以定义变量接受。</li>
<li>增强<code>switch</code>没有穿透特性，对应分支执行完之后直接退出<code>switch</code>。</li>
</ol>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>Java 有四种循环，分别是<code>while</code>、<code>do...while</code>、<code>for</code>和<code>foreach</code>循环。前面三种和 C 是类似的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; nums.length) &#123;</span><br><span class="line">    System.out.println(nums[i++]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(nums[i++]);</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; nums.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// for 循环初始化表达式部分可以定义循环变量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">    System.out.println(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们需要遍历数组或集合元素的时候，往往使用<code>foreach</code>循环更简洁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>foreach</code>并不是关键字。</li>
<li>冒号前面的变量每次能取到一个元素直到所有元素都遍历结束。</li>
<li>冒号前面的变量必须在里面定义。</li>
</ol>
<p>除了循环外，Java 也支持<code>continue</code>和<code>break</code>进行循环控制。<code>break</code>表示直接退出循环，<code>continue</code>表示跳过本轮循环。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p>Java 函数要放在类里面，没有面向过程编程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类，类名随意</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// Java 的入口函数 main</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 函数调用。我们可以定义和函数名一样的变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的函数 sum，public static 是修饰符，其余和 C 一样</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组参数"><a href="#数组参数" class="headerlink" title="数组参数"></a>数组参数</h4><p>函数的参数可以是一个数组，数组传递的时候传的是什么呢？很显然，数组名里面装的是什么就传什么，因此参数传递的是数组空间的首地址，从而在函数内部修改数组元素，外部是可见的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] sum = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    change(sum);</span><br><span class="line">    <span class="comment">// 输出 9</span></span><br><span class="line">    System.out.println(sum[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    nums[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h4><p>除此之外，Java 还支持可变长参数，可变长参数的语法是在参数类型后面加<code>...</code>。一个函数最多只能有一个可变长参数，且只能放在参数列表的末尾。实际上，会把可变长参数转变为一个数组，因此在函数内使用可变长参数和使用数组没有区别。使用可变长参数主要能简化代码书写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b 是可变长参数，在函数里面的使用和普通数组没区别，其实本质上就是数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>... b)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : b) a = n &gt; a ? n : a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数，相当于调用了 max(3, new int[]&#123;1, 2, 4&#125;)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> max(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>Java 也是使用<code>return</code>关键字返回，返回值的类型需和函数类型一致，最多可以低精度转高精度，不会高精度转低精度。也就是说，函数类型是<code>int</code>，返回值类型是<code>double</code>是会报错的。函数内部可以有多个<code>return</code>，返回类型是<code>void</code>的也可以使用<code>return;</code>直接返回。<br>函数的返回值最多只有一个，但有时候我们需要返回多个值怎么办？例如传进去一个数组，返回数组里面最大值和最小值。</p>
<ol>
<li>一种是使用成员变量返回（类似于 C 的全局变量）。</li>
<li>另一种方案是在函数内部创建一个数组，将要返回的值放到数组里面然后返回。</li>
</ol>
<p>第二种方案要求变量的类型是一致的，而且和 C 不同的是函数内部创建的数组在退出函数的时候只会销毁数组名的空间，而数组空间不会销毁（没人引用会被垃圾回收），因此直接返回数组空间地址是可以的。<br>对于复杂的数据类型，我们可以创建类对象来返回。</p>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>Java 一个类中可以有多个同名的函数，但是这些函数的参数不能完全一致，要么至少一个参数类型有不同，要么参数数量不同。如下 Java 的Math 库里面就定义了下面 4 个求最大值函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">max</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">max</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span></span><br></pre></td></tr></table></figure>
<p>在函数重载的情况下，我调用这个函数，那么会匹配到哪一个呢？<br>答：会匹配到最接近的。例如我调用上面求最大值函数，参数是两个<code>char</code>，那么会优先匹配到参数是<code>int</code>的函数，其次是<code>long</code>、<code>float</code>、<code>double</code>。注意，匹配到时候只会上升精度匹配，不可能降低精度匹配。也就是说函数参数类型是<code>int</code>，实参是<code>double</code>将会无法匹配。说到底，就是系统不会做将高精度转低精度的强转，但这样的强转我们可以手动做<code>(int) 3.14</code>。</p>
<h4 id="函数执行原理"><a href="#函数执行原理" class="headerlink" title="函数执行原理"></a>函数执行原理</h4><p>程序从<code>main</code>函数开始执行，遇到函数调用就跳转到被调函数的代码处继续执行，执行完毕后重新回到主调函数的下一条语句处执行。在这个过程中，有以下几个问题：</p>
<ol>
<li>函数调用的参数是怎么传递的？</li>
<li>被调函数是如何知道执行完毕之后该回到哪里去的？</li>
<li>被调函数通过<code>return</code>返回值是怎么给到主调函数的？</li>
</ol>
<p>我们首先要知道计算机里面存储分为：栈、堆、返回值存储区（这个区域比较复杂，我们暂且认为就是一块存储返回值的内存）。栈里面主要存储函数里面定义的局部变量、形参等，堆主要存储数组空间以及对象空间（对象和数组类似将内存分两个部分，一个是变量名存储对象空间所在地址，一个就是对象空间存储对象里面的数据内容），返回值存储区临时存储函数的返回值。<br>我们使用一个例子感受一下函数调用时栈的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> Main.sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个简单的例子，我们下面阐述一下流程：</p>
<ol>
<li>主函数执行函数<code>sum</code>之前会为形参<code>args</code>和局部变量<code>d</code>在栈里分配内存，如图1-1。</li>
<li>函数<code>sum</code>被执行期间，先为形参<code>a</code>和<code>b</code>在栈里分配内存。</li>
<li>紧接着就是将主调函数的下一条指令地址存进栈里，然后为局部变量<code>c</code>分配内存并计算结果存进去。</li>
<li>遇到<code>return</code>语句，先将返回内容<code>c</code>的值存进返回值存储区，整个栈图如图1-2。</li>
<li>被调函数的内容全部出栈（销毁），然后根据指令地址转到主调函数，从返回值存储区读取返回值赋值给变量<code>d</code>。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1700636984479-6a588a7d-af3a-4039-831a-e8c5772b152e.png#averageHue=%23dadada&clientId=u90079b71-4238-4&from=paste&height=180&id=qaRRS&originHeight=276&originWidth=477&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40086&status=done&style=none&taskId=ua4da6d58-8719-4966-b26e-688a27aa73d&title=&width=311" alt="image.png"><br>图1-1<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1700637006893-2f02fed0-a984-4ea0-bffd-630044622d15.png#averageHue=%23dcdcdc&clientId=u90079b71-4238-4&from=paste&height=180&id=kewYY&originHeight=371&originWidth=839&originalType=binary&ratio=1&rotation=0&showTitle=false&size=92803&status=done&style=none&taskId=ua19f37a1-61d4-49e8-aaf0-c2681e2985e&title=&width=407" alt="image.png"><br>图1-2<br>从流程我们发现，对于返回值我们会将其存到一个专门的地方，然后给到主调函数。这样做是因为变量<code>c</code>在函数结束的时候就被销毁掉了，没办法取值，所以找了一个中间商。<br>这样就会产生一个问题：我们知道异常处理的时候<code>finally</code>块一定会执行。假设有<code>c = 1</code>，函数里面有<code>return c;</code>，又在<code>finally</code>里面执行了<code>c++;</code>那么最终返回结果是什么？<br>答：返回 <strong>1</strong>，因为遇到<code>return</code>的时候会将<code>c</code>变量的值备份到返回值存储区，接着执行<code>c++</code>影响不到返回值。<br>当我们将数组作为参数的时候，传递数组空间的首地址。看下面的案例（对应栈图1-3）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> min;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a: arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &gt; max) max = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> []arr = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> max(<span class="number">0</span>, arr);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1700639527392-2eba7830-b0e6-4225-b554-d8d4e1f5b74a.png#averageHue=%23dddddd&clientId=u90079b71-4238-4&from=paste&height=384&id=u2363e7eb&originHeight=384&originWidth=929&originalType=binary&ratio=1&rotation=0&showTitle=false&size=115196&status=done&style=none&taskId=ua88f2d83-9f41-434b-b511-5a1d8237581&title=&width=929" alt="image.png"><br>图1-3<br>最后提一句，函数栈的存储是从高位往低位存储的，即栈底在高位的内存，栈顶在低位内存（简记为从右到左存储）。</p>
<h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p>Java 整数有<code>byte/short/int/long</code>四种，这 4 种整数的性质完全一样，只是可表示范围不一样，我们使用<code>byte</code>举例子。一个<code>byte</code>有 8 位，每位有<code>0</code>和<code>1</code>两种取值，其中最高位（最左边位）表示符号位，取值<code>1</code>表负数，取值<code>0</code>表正数。</p>
<ol>
<li>正数使用原码表示法，即二进制正数$0i_1i_2i_3i_4i_5i_6i_7$与以下十进制数是等价的：</li>
</ol>
<p>$i_7\times2^0+i_6\times2^1+i_5\times2^2+i_4\times2^3+i_3\times2^4+i_2\times2^5+i_1\times2^6$<br>例如：<code>0111</code>表示十进制数<code>7</code>，<code>010</code>表示十进制数<code>2</code>。</p>
<ol start="2">
<li>负数使用补码表示法，即先得出对应的正数的原码，接着对原码所有位取反，最后再<code>+1</code>。</li>
</ol>
<p>这样做的原因也很简单，我们知道相对的两个正数、负数之和为<code>0</code>。我们得出正数的原码，那什么数与之相加和为<code>0</code>呢？先对原码取反（0 变 1，1 变 0），这样两者之和所有位全部是<code>1</code>，在此基础上只要再<code>+1</code>就会变成全<code>0</code>。因此正数对应的负数是对原码<code>取反再+1</code>，那么同样的逻辑负数想变成对应的正数也做一样的操作<code>取反再+1</code>。<br>于是很经典的一幕来了：<code>127 + 1 = -128</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>  --&gt; <span class="number">01111111</span></span><br><span class="line"><span class="number">1</span>    --&gt; <span class="number">00000001</span></span><br><span class="line">+ ----------------</span><br><span class="line">-<span class="number">128</span> --&gt; <span class="number">10000000</span></span><br></pre></td></tr></table></figure>
<p>不难看出，最大的正数加一之后会变成最小的负数。闭环了有没有？<br>除了二进制，比较常用的进制还有十六进制。二进制转十六进制很简单，直接 4 位一组转成十六进制即可。例如<code>-128 = 0b10000000 = 0x80</code>，其中<code>0b &lt;=&gt; 0B</code>表示二进制常量的前缀，<code>0x &lt;=&gt; 0X</code>是十六进制常量的前缀。在 Java 里面我们可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String Integer.toBinaryString(int a)  // int 转二进制字符串</span><br><span class="line">String Integer.toHexString(int a)  // int 转十六进制字符串</span><br><span class="line">String Long.toBinaryString(long a)  // long 转二进制字符串</span><br><span class="line">String Long.toHexString(long a)  // long 转十六进制字符串</span><br></pre></td></tr></table></figure>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>位运算有移位运算和逻辑运算，分别见下面：</p>
<ol>
<li><code>&amp;</code>按位与 AND，有 0 则 0。</li>
<li><code>|</code>按位或 OR，有 1 则 1。</li>
<li><code>~</code>表示按位取反，0 变 1，1 变 0。</li>
<li><code>^</code>表示异或，两者不一样的为 1，否则为 0。</li>
<li><code>&gt;&gt;&gt;</code>无符号右移，使用 0 填补左边空位。</li>
<li><code>&gt;&gt;</code>有符号右移，使用符号位填补左边空位，算术上<code>x&gt;&gt;n</code>等价于$\frac{x}{2^n}$，这边的除法表示整除。</li>
<li><code>&lt;&lt;</code>左移，左移时用 0 填补右边空位，算术上<code>x&lt;&lt;n</code>等价于$x\times2^n$。</li>
</ol>
<p>下面程序展示了使用<code>byte</code>作为位集的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整数转二进制输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printb</span><span class="params">(<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	System.out.println(Integer.toBinaryString(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">1</span> | <span class="number">1</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">1</span> | <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    printb(x);  <span class="comment">// &quot;00100010&quot; 集合 &#123;1, 5&#125;</span></span><br><span class="line">    printb(y);  <span class="comment">// &quot;00000110&quot; 集合 &#123;1, 2&#125;</span></span><br><span class="line">    printb(~x);  <span class="comment">// &quot;11011101&quot; 取补集 1 - x = &#123;0, 2, 3, 4, 6, 7&#125;</span></span><br><span class="line">    printb(x &amp; y);  <span class="comment">// &quot;00000010&quot; 取交集 x ∩ y = &#123;1&#125;</span></span><br><span class="line">    printb(x | y);  <span class="comment">// &quot;00100110&quot; 取并集 x ∪ y = &#123;1, 2, 5&#125;</span></span><br><span class="line">    printb(x ^ y);  <span class="comment">// &quot;00100100&quot; 取对称差 x + y - xy = &#123;2, 5&#125;</span></span><br><span class="line">    printb(x &amp; ~y);  <span class="comment">// &quot;00100000&quot; 取差集 x - y = &#123;5&#125;</span></span><br><span class="line">    printb(x &lt;&lt; <span class="number">1</span>);  <span class="comment">// &quot;01000100&quot; 集合 &#123;2, 6&#125;</span></span><br><span class="line">    printb(x &gt;&gt;&gt; <span class="number">1</span>);  <span class="comment">// &quot;00010001&quot; 集合 &#123;0, 4&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 x 哪些位是 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((x &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>)</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d&quot;</span>, i);  <span class="comment">// 15</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h4><p>浮点数在计算机的存储是按照科学记数法存储的，只不过底数为 2。也就是所有浮点数都会转为$m\times2^e$的形式，这边 m 称为尾数，e 称为指数。很多小数没法表示成这样的写法，所以会导致结果不精确。<br>了解了浮点数在内存的存储形式，那么具体存储方案是什么呢？</p>
<ol>
<li>对于 32 位浮点数（float），1 位表示正负，23 位表示尾数，8 位表示指数。</li>
<li>对于 64 位浮点数（double），1 位表示正负，52 位表示尾数，11 位表示指数。</li>
</ol>
<h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><p>字符使用<code>char</code>关键字，本质上<code>char</code>就是占据两个字节的无符号正整数。这个正整数对应<code>Unicode</code>编码，这是兼容<code>ASCII</code>编码的。因为两个字节能表示只有 65536 以内的字符，所以编码超出的字符需要其它方式表示。不过好在大多数常用汉字在表示的范围内。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;卢&#x27;</span>;  <span class="comment">// 直接赋值字符常量</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">21346</span>;  <span class="comment">// 使用十进制编码赋值</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0x5362</span>;  <span class="comment">// 使用十六进制编码赋值</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;\u5362&#x27;</span>;  <span class="comment">// 使用 Unicode 方式赋值</span></span><br></pre></td></tr></table></figure>
<h3 id="类基础"><a href="#类基础" class="headerlink" title="类基础"></a>类基础</h3><p>我们将类看做自定义数据类型，类由属性和操作（方法）两部分组成。其中属性分为类属性和实例属性，方法分为类方法和实例方法。因此数据类型由下面四个部分组成：</p>
<ol>
<li>类型本身具备的属性，通过类变量体现。</li>
<li>类型本身可以进行的操作，通过类方法体现。</li>
<li>类型实例具备的属性，通过实例变量体现。</li>
<li>类型实例可以进行的操作，通过实例方法体现。</li>
</ol>
<p>类变量和实例变量可以统称为成员变量，类方法和实例方法可以统称为成员方法。类变量可以称为静态变量，类方法还可以称为静态方法。</p>
<h4 id="变量、方法"><a href="#变量、方法" class="headerlink" title="变量、方法"></a>变量、方法</h4><p><strong>类方法</strong>就是在定义的时候加上<code>static</code>关键字修饰的方法，这样的方法别人可以直接使用<code>类名.方法名()</code>的形式调用。<br><strong>类变量</strong>主要描述类型本身具备的属性，一般用来定义类型中的常量。例如<code>Math</code>类里面就定义了一个常量<code>PI</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.141592653589793</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>public</code>修饰符表示这个变量是公开的，所有人都可以访问。</li>
<li><code>static</code>修饰符表示这是一个静态变量，别人可以通过<code>类名.变量名</code>的方式访问。</li>
<li><code>final</code>修饰符表示这是一个常量，无法修改。</li>
</ul>
<p><strong>实例变量</strong>表示具体实例具有的变量，<strong>实例方法</strong>表示具体实例可以进行的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(x * x + y * y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是一个简单的类的例子，定义了一个名叫<code>Point</code>的类。类里定义了两个实例变量<code>x</code>和<code>y</code>，还定义了一个实例方法<code>distance</code>，这个方法计算并返回该点到原点的距离。可以发现在实例方法里面可以直接使用实例变量。实际上：</p>
<ul>
<li>静态方法里面只能调用调用方法，只能访问静态变量。</li>
<li>实例方法里面没有要求，既可以访问实例变量和方法，也可以访问静态变量和方法。</li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>下面我们简单使用一下定义的<code>Point</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>();  <span class="comment">// 创建 Point 类的对象 p</span></span><br><span class="line">p.x = <span class="number">1</span>;  <span class="comment">// 给实例变量 x 赋值</span></span><br><span class="line">p.y = <span class="number">2</span>;  <span class="comment">// 给实例变量 y 赋值</span></span><br><span class="line">System.out.println(p.distance());  <span class="comment">// 调用实例方法</span></span><br></pre></td></tr></table></figure>
<p>这个例子比较简单，但是有一点。对象的创建和数组定义类似，变量名<code>p</code>里面存储着对象空间的地址，默认为<code>null</code>，代码里面我们通过<code>new Point()</code>分配对象空间并将地址赋给变量<code>p</code>。注意，所有的成员变量没有初值都会给默认的初值，数值类型初值都是 0，<code>boolean</code>类型默认初值是 false，<code>char</code>类型默认初值也是 0。<br><strong>Tip：</strong>实例变量一般不设为<code>public</code>，即我们一般不允许直接访问这个实例变量。而是使用<code>private</code>修饰实例变量，然后提供对应的<code>getter</code>和<code>setter</code>。这样做的好处是能够有效避免异常值的出现。举个例子，实例变量的含义是考试成绩，如果赋值<code>-1</code>进去怎么办？</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>我们说所有成员变量都会有一个默认的初值，但如果我想改变这个初值怎么办？<br><strong>对于实例变量</strong>，可以直接在定义的时候给初值或者使用代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 定义变量的时候直接赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">&#123;  <span class="comment">// 使用代码块进行实例变量的初始化</span></span><br><span class="line">    y = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于实例变量的初始化，有以下注意点：</p>
<ol>
<li>不论是直接赋值还是使用代码块赋值都可以使用方法返回值来给变量赋值，所有成员方法均可调用。</li>
<li>实例变量的初始化在每一个对象创建时、构造方法执行前进行的。</li>
<li>代码块初始化的好处是能够应付比较复杂的初值情况，比如涉及条件判断等情况。</li>
</ol>
<p><strong>对于静态变量</strong>，可以直接定义的时候指定或使用静态代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 定义变量的时候直接赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> v2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;  <span class="comment">// 使用静态代码块初始化</span></span><br><span class="line">    v2 = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于静态变量的初始化，有以下注意点：</p>
<ol>
<li>给静态变量初始化调用方法只能调用静态方法，因为此时实例方法还没加载。</li>
<li>静态变量初始化于类加载的时候，这早于任何对象的创建，且只会执行一次。</li>
<li>静态代码块里面可以书写复杂的初始化逻辑，但是不能使用实例变量，因为实例变量此时还没加载。</li>
</ol>
<p>问：普通初始化代码块里面能不能对静态变量初始化？<br>答：可以。只不过这样的初始化每次对象的创建都会执行，里面可以使用实例方法或实例变量给静态变量初始化，因为此时实例方法和变量都已经存在。</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>上面介绍了初始化成员变量的方法，其实还可以通过构造方法来做这个事情。我们使用<code>new</code>创建一个对象的时候需要做：1. 申请内存。2. 做实例变量的初始化操作，包括执行代码块的内容。3. 调用构造方法。<br>构造方法必须与类名相同，且不能有返回值类型，见下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Point</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 调用下面的构造方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参构造，参数没有要求，按需设立</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;  <span class="comment">// 给成员变量 x 赋值</span></span><br><span class="line">    <span class="built_in">this</span>.y = y;  <span class="comment">// 给成员变量 y 赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看以看出我们使用到了关键字<code>this</code>，它表示当前实例，有两个作用：</p>
<ol>
<li>调用其它构造方法，必须放在第一行。</li>
<li>获取成员变量，例子中存在局部变量<code>x</code>，所以直接访问<code>x</code>实际上是在访问局部变量。使用<code>this</code>表明要给成员变量<code>x</code>赋值。</li>
</ol>
<p>有了构造方法之后，我们可以在创建对象的时候可以直接使用<code>Point p = new Point(1, 2);</code>。<br>Java 有<strong>默认的构造方法</strong>，这个默认的构造方法里面什么都不做，也没有参数。但只有我们没有手动定义构造方法的时候这个默认构造才会存在，一旦我们定义了构造，那么默认构造就不存在了。基于此，若是我们自己定义的构造都是带参数的，那么创建对象的时候<code>new Point()</code>就会报错了，因为我们有自定义构造，所以默认无参构造就没有了，此时在这么调用就不对了。<br>构造方法不一定非要<code>public</code>，还可以定义<code>private</code>的构造方法，一般使用<strong>私有构造</strong>的场景：</p>
<ol>
<li>不允许创建类的实例，类只能被静态访问，例如<code>Math</code>类。</li>
<li>单例模式的类，不允许外人创建类的实例，实例只能通过本类的静态方法获取。当需要类实例的时候，调用对应静态方法获取，方法内会判断若实例已经创建就直接返回否则就创建并返回。</li>
<li>这个私有构造是专门给其它构造调用使用的，便于减少代码冗余。</li>
</ol>
<h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>为解决类命名冲突的问题，我们引入包的概念。包相当于一个路径，各部分使用<code>.</code>分隔。带有包路径的类名称为完全限定名。定义类的时候应该先使用<code>package</code>关键字声明报名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.luyan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包名要和文件目录结构匹配，假设源文件的根目录是<code>&lt;?&gt;/src</code>，那么类<code>Demo</code>的源文件路径应该是<code>&lt;?&gt;/src/com/luyan/Demo.java</code>。建议包名使用域名的反写，以避免包名冲突。<br>类之间引用有以下注意点：</p>
<ol>
<li>同一个包下的类可以直接使用。</li>
<li>想要使用的类在其它包下：<ol>
<li>使用完全限定名来使用这个类。</li>
<li>将要使用的类引入当前类，只有<code>java.lang</code>包是例外（不需要引入也可以使用）。</li>
</ol>
</li>
</ol>
<p>例如我想用<code>Arrays</code>类里面的<code>sort</code>方法，有以下两种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">java.util.Arrays.sort(arr);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line">Arrays.sort(arr);</span><br></pre></td></tr></table></figure>
<p>Java 使用<code>import</code>关键字来导包，导包的时候还可以使用<code>*</code>来导入包下的所有类：<code>import java.util.*;</code>表示导入<code>java.util</code>下面所有类。但是要注意这不会递归导包，也就是说<code>util</code>子包下面的类是无法导入的。Java 没办法同时导入两个同名的类，遇到这样的情况只能导入一个，另一个使用完全限定名。除此之外，Java 可以使用静态导入的方式导入类公开的静态方法和静态变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;  <span class="comment">// 导入静态变量 out</span></span><br><span class="line">out.println(<span class="string">&quot;Hello&quot;</span>);  <span class="comment">// 直接使用 out</span></span><br></pre></td></tr></table></figure>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性分为<code>public、private、默认（不写）、protected</code>，它们可见范围：</p>
<ol>
<li><code>public</code>表示所有人可以访问。</li>
<li><code>private</code>表示只有类内部可以访问。</li>
<li><code>默认</code>表示包内可访问，包外不可访问（包内指的是同一级目录，子包也不可访问）。</li>
<li><code>protected</code>表示包内或子类可访问。</li>
</ol>
<p>根据可见性小到大排序有：<code>private &lt; 默认 &lt; protected &lt; public</code>。</p>
<h4 id="jar-包"><a href="#jar-包" class="headerlink" title="jar 包"></a>jar 包</h4><p>导出<code>jar</code>包的时候导出的是字节码文件，而不是源文件。假设字节码文件的目录是<code>E:\bin\com\luyan\Demo.class</code>，那么导包步骤是：</p>
<ol>
<li>切换到<code>E:\bin</code>目录下。</li>
<li>运行指令<code>jar -cvf &lt;文件名&gt;.jar &lt;最上层包名&gt;</code>，这个例子就是<code>jar -cvf demo.jar com</code>。</li>
</ol>
<p>实际上<code>jar</code>包就是一个压缩包，我们完全可以解压缩看到里面的内容。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>自然界的类之间天然存在继承关系，例如动物类和狗类，狗属于动物，因此动物类是父类，狗类是子类。Java 里面也有继承的关系，父类又可以称为基类，子类又可以称为派生类。<br>之所以叫继承，是因为子类会继承父类的属性和行为，同时子类还可以拓展自己的属性和行为。使用继承有许多好处：</p>
<ol>
<li>不同子类的对象可以很方便的统一处理。</li>
<li>可以复用代码，许多公共的属性和行为可以放到父类里面，子类只需要关注自己特有的属性行为。</li>
</ol>
<h4 id="根父类"><a href="#根父类" class="headerlink" title="根父类"></a>根父类</h4><p>Java 里即使没有给类指明父类，其也会有一个隐含的父类<code>Object</code>，<code>Object</code>是所有类或直接或间接的父类。<code>Object</code>类没有定义属性，但是定义了一些方法：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1700813123098-078b449d-6d3b-4211-b8ee-564dc3674872.png#averageHue=%23e0e0e0&clientId=u8b1ac003-cd14-4&from=paste&height=361&id=ub5a188b8&originHeight=361&originWidth=597&originalType=binary&ratio=1&rotation=0&showTitle=false&size=131669&status=done&style=none&taskId=uf31e57e7-aacf-4ab3-a2de-725ddf7b067&title=&width=597" alt="image.png"><br>我们主要看看<code>toString()</code>方法，这个方法目的是返回对象的文本描述。一般情况下，直接打印对象的时候会默认打印这个函数的输出。这个方法的默认实现是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此默认情况下，打印一个对象打印出来的是类似于<code>com.luyan.Point@28a418fc</code>这样的字符串，字符串前半部分是类的完全限定名，后半部分是对象的哈希值（一般是对象的十六进制地址）。</p>
<h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>上面的<code>toString()</code>方法一般来说是不够用的，我们想要描述一个对象可能涉及到这个对象的一些属性。但是父类并不能提前知晓子类的属性，这个时候我们就可以在子类重写<code>toString()</code>方法以达到自定义的目的。下面的例子是<code>Point</code>类重写的<code>toString()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + x + <span class="string">&#x27;,&#x27;</span> + y + <span class="string">&quot;)&quot;</span>;  <span class="comment">// 按照格式返回横纵坐标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>@Override</code>表示这个方法是重写的父类的方法，不写也可以，但写一下真假可读性。</p>
<h4 id="图形类的继承体系"><a href="#图形类的继承体系" class="headerlink" title="图形类的继承体系"></a>图形类的继承体系</h4><p>我们接下来使用图形类来展示继承体系，首先我们打算设计“圆、线段、箭头”这三个图形类。</p>
<h5 id="Shape-类"><a href="#Shape-类" class="headerlink" title="Shape 类"></a>Shape 类</h5><p>这三个类都具有颜色这个属性，也都具有<code>draw</code>这个行为，那么我们就可以抽象一个父类<code>Shape</code>来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_COLOR</span> <span class="operator">=</span> <span class="string">&quot;black&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(DEFAULT_COLOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Draw Shape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类比较简单，实例变量<code>color</code>表示图形的颜色。类里定义了静态常量<code>DEFAULT_COLOR</code>表示默认颜色。定义<code>draw()</code>方法实现图形的绘制，这边就是简单的一句输出。</p>
<h5 id="Circle-类"><a href="#Circle-类" class="headerlink" title="Circle 类"></a>Circle 类</h5><p>接下来设计“圆”这个类，圆新增了圆心和半径两个属性，还新增了<code>area()</code>方法用来计算面积。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Point center;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(Point center, <span class="type">double</span> r)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.center = center;</span><br><span class="line">        <span class="built_in">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Draw Circle at %s with r %f, using color %s.&quot;</span>, </span><br><span class="line">                center, r, getColor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * r * r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Point <span class="title function_">getCenter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> center;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCenter</span><span class="params">(Point center)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.center = center;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getR</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setR</span><span class="params">(<span class="type">double</span> r)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类重写了父类<code>draw()</code>方法，并自定义一个求面积的方法。对于这个例子有以下几个注意点：</p>
<ol>
<li>Java 使用<code>extends</code>关键字表示继承，这边<code>Circle</code>继承于<code>Shape</code>。</li>
<li>子类不能直接访问父类私有的属性和方法，因此代码里使用<code>getColor()</code>方法获取图形的颜色。</li>
<li><code>new</code>的时候，在调用子类构造之前，一定会先调用父类的构造。如果没有明确写调用父类哪个构造，那么将会调用父类的无参构造，若这种情况下父类没有无参构造是会报错的。上面的例子，没有显式调用父类构造，所以默认调用了父类的无参构造，因此图形颜色是默认的<code>black</code>。</li>
</ol>
<h5 id="Line-类"><a href="#Line-类" class="headerlink" title="Line 类"></a>Line 类</h5><p>接下来我们设计“线段”类，这个类新增了两个端点以及一个计算长度的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Point start;</span><br><span class="line">    <span class="keyword">private</span> Point end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Line</span><span class="params">(Point start, Point end, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(color);</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">length</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> start.distance(end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Draw Line from %s to %s, using color %s.&quot;</span>, </span><br><span class="line">                start, end, getColor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Point <span class="title function_">getStart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStart</span><span class="params">(Point start)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Point <span class="title function_">getEnd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEnd</span><span class="params">(Point end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子主要出现了一个关键字<code>super</code>，这个关键字和<code>this</code>有些像，它的作用：</p>
<ol>
<li>通过<code>super</code>关键字指定调用父类的哪一个构造方法，必须放在构造的第一行。这个例子里面指定调用父类带参的构造。</li>
<li>使用<code>super</code>可以访问父类非私有的成员变量，这个主要当父类和子类有同名变量的时候用作区分。</li>
<li>使用<code>super</code>可以调用父类的非私有方法，这个用的比较多。因为子类在重写完父类某方法之后，调用的就是子类重写后的方法了，这时候想要调用原来的方法，可以使用<code>super</code>关键字。</li>
</ol>
<p><code>super</code>和<code>this</code>看起来是很像的，一个表示父类，一个表示自己。但是两者有很大的不同：</p>
<ul>
<li><code>this</code>引用一个对象，是实实在在的，是可以作为参数和返回值存在的。</li>
<li><code>super</code>只是一个关键字，并不能作为参数之类的存在，它的作用只是告诉编译器将要访问父类的相关属性方法。</li>
</ul>
<h5 id="ArrowLine-类"><a href="#ArrowLine-类" class="headerlink" title="ArrowLine 类"></a>ArrowLine 类</h5><p>接下来我们设计“箭头”类，箭头相比于线段多了两个表示是否存在两端箭头的属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrowLine</span> <span class="keyword">extends</span> <span class="title class_">Line</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> startArrow;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> endArrow;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrowLine</span><span class="params">(Point start, Point end, String color,</span></span><br><span class="line"><span class="params">                     <span class="type">boolean</span> startArrow, <span class="type">boolean</span> endArrow)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(start, end, color);</span><br><span class="line">        <span class="built_in">this</span>.startArrow = startArrow;</span><br><span class="line">        <span class="built_in">this</span>.endArrow = endArrow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.draw();</span><br><span class="line">        <span class="keyword">if</span> (startArrow)</span><br><span class="line">            System.out.println(<span class="string">&quot;Draw start arrow.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (endArrow)</span><br><span class="line">            System.out.println(<span class="string">&quot;Draw end arrow.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStartArrow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> startArrow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStartArrow</span><span class="params">(<span class="type">boolean</span> startArrow)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.startArrow = startArrow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEndArrow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> endArrow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEndArrow</span><span class="params">(<span class="type">boolean</span> endArrow)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.endArrow = endArrow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类实现有两个地方需要注意：</p>
<ol>
<li>因为其父类<code>Line</code>没有无参构造，所以在本类的构造方法里面需要显式调用父类的构造。</li>
<li><code>draw()</code>方法里面使用<code>super</code>关键字是因为想要调用父类的<code>draw</code>方法。</li>
</ol>
<h5 id="ShapeManager-类"><a href="#ShapeManager-类" class="headerlink" title="ShapeManager 类"></a>ShapeManager 类</h5><p>使用继承就是方便管理多个不同的子类，下面我们设计一个图形管理器，用于添加图形以及对维护的图形进行绘制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_NUM</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> Shape[] shapes = <span class="keyword">new</span> <span class="title class_">Shape</span>[MAX_NUM];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">shapeNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addShape</span><span class="params">(Shape shape)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (shapeNum &gt;= MAX_NUM) <span class="keyword">return</span>;</span><br><span class="line">        shapes[shapeNum++] = shape;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; shapeNum; ++i) &#123;</span><br><span class="line">            shapes[i].draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类主要维护一个<code>Shape</code>数组，具备添加图形和绘制所有图形的功能。</p>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ShapeManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapeManager</span>();</span><br><span class="line">    manager.addShape(<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">3</span>), <span class="number">1</span>));</span><br><span class="line">    manager.addShape(<span class="keyword">new</span> <span class="title class_">Line</span>(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">2</span>), <span class="string">&quot;green&quot;</span>));</span><br><span class="line">    manager.addShape(<span class="keyword">new</span> <span class="title class_">ArrowLine</span>(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">3</span>), <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">4</span>, <span class="number">5</span>), </span><br><span class="line">            <span class="string">&quot;red&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>));</span><br><span class="line">    manager.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面写了一段测试代码，创建了一个圆、一条直线和一个箭头。我们将这些图形添加到管理器里面并统一绘制出来。<br><code>Circle</code>明明表示圆，但是我们把它看做一个图形是没有问题的。因此使用<code>Shape</code>类型变量来引用圆对象是合理的，这个叫做<strong>向上转型</strong>。<code>Shape</code>类型的对象可以引用任意一个子类的对象，这叫做<strong>多态</strong>，即一种类型的变量可以实际引用多种类型的对象。对于一个变量<code>Shape shape;</code>来说，我们称<code>Shape</code>是它的<strong>静态类型</strong>，<code>Circle/Line/ArrowLine</code>是它的<strong>动态类型</strong>。我们使用<code>shape.draw()</code>调用的是动态类型的方法，这叫做<strong>动态绑定</strong>。</p>
<h4 id="继承的细节"><a href="#继承的细节" class="headerlink" title="继承的细节"></a>继承的细节</h4><h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><p>第一个问题之前提过，创建子类对象的时候，在调用子类构造之前会先调用父类构造。如果没有手动指定调用父类哪个构造，那么就会默认调用父类无参构造，若此时恰巧父类没有无参构造，那就会报错了。<br>第二个问题是在父类的构造函数里面调用可被重写的成员方法时可能遇到的问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span> &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">c.test();</span><br></pre></td></tr></table></figure>
<p>上面的代码运行会输出什么？<br>答：<code>0</code>和<code>123</code>。<br>下面主要谈谈为什么第一次输出<code>0</code>。</p>
<ol>
<li>首先父类的构造调用在子类之前，因此会在父类构造里面执行<code>test</code>函数。</li>
<li>因为是从子类上去的，所以将会执行子类的<code>test</code>函数，输出变量<code>a</code>的值。</li>
<li>此时子类的初始化还没开始，因此变量<code>a</code>的值为<code>0</code>，故而输出<code>0</code>。</li>
</ol>
<p>从这个例子可以看出，父类构造中调用能被子类重写的方法是不太好的。因此我们平时编程的时候建议只在父类构造里面调用私有方法，因为私有方法不能被重写。</p>
<h5 id="重名"><a href="#重名" class="headerlink" title="重名"></a>重名</h5><p>之前说过，子类能够重写父类非私有的实例方法，调用的时候会动态绑定，最终会执行子类的方法。那么对于实例变量、静态变量、静态方法而言，若是子类也有同名的变量方法，怎么执行？<br>首先，重名（子类和父类同时具有名字一样的属性或方法）是可以的。具体怎么执行分情况：</p>
<ol>
<li><p>私有的变量或方法。这种变量或方法只能在类内部进行访问，这种情况下当然各访问各的，子类访问子类的，父类访问父类的，互不影响。</p>
</li>
<li><p>非私有的变量或方法，这样变量或方法在类内或类外都可以访问：</p>
<ol>
<li>类内部访问，也是各访问各的，互不干扰。</li>
<li>类外部访问，静态类型是谁就访问谁的，看下面的代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;base&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;static_base&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;base_&quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;child&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;static_child&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;child_&quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> c;</span><br><span class="line">System.out.println(c.a);</span><br><span class="line">System.out.println(c.b);</span><br><span class="line">c.test();</span><br><span class="line"></span><br><span class="line">System.out.println(b.a);</span><br><span class="line">System.out.println(b.b);</span><br><span class="line">b.test();</span><br></pre></td></tr></table></figure>
执行上面的代码输出：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">child</span><br><span class="line">static_child</span><br><span class="line">child_static_child</span><br><span class="line">base</span><br><span class="line">static_base</span><br><span class="line">base_static_base</span><br></pre></td></tr></table></figure>
根据变量的静态类型确定访问变量或方法的行为称为静态绑定，静态绑定在编译阶段即可决定，动态绑定要到程序运行是才能确定。实例变量、静态变量、静态方法和私有方法都是采用静态绑定。<br>上面说的是父类和子类两者都有的情况。下面我们总结访问变量或方法时各种情况下的访问结果（不考虑私有变量方法和成员方法，因为私有的只有类内部可以访问，成员方法是动态绑定）：</li>
</ol>
</li>
<li><p>父类子类都没有对应的变量方法，谁访问都是报错。</p>
</li>
<li><p>访问子类特有的变量或方法只能使用静态类型是子类的变量访问，父类去访问会报错。</p>
</li>
<li><p>访问父类定义而子类没重复定义的变量方法，那静态类型是父类和子类的都能访问，访问的是父类对应的变量方法。</p>
</li>
<li><p>访问父类子类都有的变量方法，那就根据静态类型各访问各的，互不影响。</p>
</li>
</ol>
<h5 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h5><p>重载是指方法的名称相同但参数的签名不同（参数个数、类型或顺序不同），重写是指子类重新定义和父类参数签名相同的方法。我们在调用函数的时候，实参和形参不要求完全一致，只要实参精度不高于形参精度就可以。例如函数形参是<code>long</code>类型，实参是<code>int</code>类型也能调用。<br>假设父类和子类都有名为<code>sum</code>的函数：</p>
<ol>
<li>静态类型是父类的变量调用<code>sum</code>函数，只会在父类里面寻找参数类型匹配的函数调用，找不到报错。</li>
<li>静态类型是子类的变量调用<code>sum</code>函数，依据参数类型情况：<ol>
<li>优先调用参数匹配度高的函数，父类高就调用父类的函数。</li>
<li>匹配度一样的高的，子类的函数优先。</li>
</ol>
</li>
</ol>
<h5 id="父子类型转换"><a href="#父子类型转换" class="headerlink" title="父子类型转换"></a>父子类型转换</h5><p>子类型对象完全可以赋值给父类型的变量，这叫向上转型。那父类型的变量能不能赋值给子类型的变量呢？我们可以使用强转来尝试转换，如果类型是匹配的就可以，否则不行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> c;</span><br><span class="line">c = (Child) b;  <span class="comment">// 成功，因为此时的 b 本质上就是 Child</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br><span class="line"><span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> (Child) b;  <span class="comment">// 失败，因为此时 b 并不是 Child 类型的</span></span><br></pre></td></tr></table></figure>
<p>如果确实需要向下转型，但是又怕出错。可以使用<code>instanceof</code>关键字判断能否转型，例如使用<code>b instanceof Child</code>可以返回变量<code>b</code>引用的对象是否是<code>Child</code>类或其子类的对象。</p>
<h5 id="可见性重写和防止继承"><a href="#可见性重写和防止继承" class="headerlink" title="可见性重写和防止继承"></a>可见性重写和防止继承</h5><p>当我们使用子类重写父类的方法时，重写的方法不能降低可见性，可以提高。也就是说父类有个方法的可见性是<code>protected</code>，那么子类重写时可见性必须大于等于<code>protected</code>。<br>有时我们不希望某些非私有的方法被重写，我们在定义方法时候加上<code>final</code>关键字即可。类似的，我们可以在定义类的时候加上<code>final</code>关键字，这样这个类就是不可继承的。</p>
<h4 id="继承的基本原理"><a href="#继承的基本原理" class="headerlink" title="继承的基本原理"></a>继承的基本原理</h4><h5 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h5><p>所谓类加载是指将类相关的信息加载到内存之中的<strong>方法区</strong>。Java 的类是动态加载的，即第一次使用到这个类的时候才回去加载它，类加载只会进行一次。<br>首先我们要知道一个类包含哪些信息：</p>
<ol>
<li>类变量。</li>
<li>类初始化代码，这包含：<ul>
<li>定义静态变量时的赋值语句。</li>
<li>静态初始化代码块。</li>
</ul>
</li>
<li>类方法。</li>
<li>实例变量。</li>
<li>实例初始化代码，这包含：<ul>
<li>定义实例变量时的赋值语句。</li>
<li>实例初始化代码块。</li>
<li><strong>构造方法。</strong></li>
</ul>
</li>
<li>实例方法。</li>
<li>父类的信息引用。</li>
</ol>
<p>类加载的过程和顺序是这样的：</p>
<ol>
<li>分配内存保存类信息（上面列出的信息）。</li>
<li>给类变量赋默认值（数值类型是<code>0</code>，boolean 类型是<code>false</code>，引用类型是<code>null</code>）。</li>
<li>加载父类。</li>
<li>设置父子关系。</li>
<li>执行类初始化代码。</li>
</ol>
<p>从流程可以看出，加载父类的时候子类的所有信息都已经在内存之中了，类初始化代码也是父类先执行，然后是子类。</p>
<h5 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h5><p>一个类的多个对象之间互不干涉对方的实例变量，也就是说每个对象的实例变量都是独立的。那么每次创建的对象内存里面都包含着属于自己的实例变量。静态变量和成员方法都是共享的。<br>对象的创建过程如下：</p>
<ol>
<li>分配内存，内存里主要有：<ul>
<li>自己的所有实例变量。</li>
<li>父类的所有实例变量。</li>
<li>当前类信息的地址。</li>
</ul>
</li>
<li>对所有实例变量赋默认值（包含自己的和父类的）。</li>
<li>执行实例初始化代码，先执行父类的实例初始化代码，再执行自己的。</li>
</ol>
<p>我们假设基类是<code>Base</code>，子类是<code>Child</code>。这两个类都有实例变量<code>a</code>，那么我们执行<code>Child c = new Child(); Base b = c;</code>之后的内存图是这样的：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1700896542735-e50850b5-008b-46a1-a96a-6cc55d169d37.png#averageHue=%23e5e5e5&clientId=u1a25505d-4922-4&from=paste&height=663&id=u4e3fa6a9&originHeight=663&originWidth=947&originalType=binary&ratio=1&rotation=0&showTitle=false&size=166370&status=done&style=none&taskId=u391ac8cf-d7f9-48cd-a758-c3006d38ffe&title=&width=947" alt="image.png"><br>不要搞混，变量是存在<strong>栈</strong>里面的，对象的内容是存在<strong>堆</strong>里面的，类相关信息是存在<strong>方法区</strong>的。</p>
<h5 id="方法的调用过程"><a href="#方法的调用过程" class="headerlink" title="方法的调用过程"></a>方法的调用过程</h5><p>在<code>Child c = new Child(); Base b = c;</code>例子中，变量<code>b</code>和<code>c</code>的静态类型不一样。但实际上<code>b</code>和<code>c</code>指向同一个对象，若此时<code>b</code>调用<code>action</code>方法，肯定是从类<code>Child</code>里面寻找，找不到会到父类<code>Base</code>里面寻找，而这也是动态绑定的原因。<br>对于一些继承关系比较深的时候，层层寻找方法效率比较低下。所以很多实现都会在类加载的时候为每一个类创建一个虚方法表：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1700899733595-00ab9137-f4b0-499f-a76c-0099e4406e77.png#averageHue=%23f0f0f0&clientId=u1a25505d-4922-4&from=paste&height=633&id=u2f9854ea&originHeight=633&originWidth=967&originalType=binary&ratio=1&rotation=0&showTitle=false&size=170717&status=done&style=none&taskId=uc61da8c8-e844-4414-9374-101c6b6645d&title=&width=967" alt="image.png"></p>
<h4 id="双刃剑继承"><a href="#双刃剑继承" class="headerlink" title="双刃剑继承"></a>双刃剑继承</h4><p>继承功能很强大，但是随之也有一个很严重的问题——破坏封装性。所谓封装就是隐藏实现细节，提供简化接口即使用者只需要关注怎么用而不需要关注怎么实现。下面使用一个例子简单阐述继承是如何破坏封装性的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_NUM</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[MAX_NUM];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        arr[count++] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">            <span class="built_in">this</span>.arr[count++] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.add(n);</span><br><span class="line">        sum += n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.addAll(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">            sum += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基类的功能就是添加元素，添加分为一个个添加和批量添加。子类的功能是想在添加的基础上能够对添加的元素求和。表面上，父类实现的功能只管添加，子类重写方法时添加求和的功能即可。但实际上，父类方法的实现细节关乎子类的功能是否正常。例如，我把父类的<code>addAll</code>方法重写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">        add(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样改完之后，我们使用子类批量添加功能时，所有元素求和都会多求和一次。<br>此时，我们必须修改子类的实现，这就破坏了封装性。<br>正是因为继承的这个缺点，所以我们要尽可能的避免使用继承：</p>
<h5 id="使用final"><a href="#使用final" class="headerlink" title="使用final"></a>使用<code>final</code></h5><p>使用<code>final</code>修饰类，这个类直接不可继承；<code>final</code>修饰方法，这个方法不可被重写。</p>
<h5 id="使用组合"><a href="#使用组合" class="headerlink" title="使用组合"></a>使用组合</h5><p>我们看一下对于上面的例子改成组合之后是怎么实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Base base;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">()</span> &#123;</span><br><span class="line">        base = <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        base.add(n);</span><br><span class="line">        sum += n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        base.addAll(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">            sum += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个例子可以看出，使用组合之后，Base 类的实现就不重要了，我只需要关注我自己的功能即可。但这就带来了另一个问题——<code>Child</code>的对象就不能当做<code>Base</code>类进行统一处理了。这个问题我们只需要使用接口就可以解决。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/index.html">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lu Yan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
