<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java,后端," />










<meta name="description" content="并发基础线程基本概念线程表示一条单独的执行流，它有自己的程序执行计数器，有自己的栈。 创建线程创建线程有两个方式，一种是继承Thread类，一种是实现Runnable接口。 继承 Thread一个类继承Thread类并实现run方法来实现一个线程： 123456class HelloThread extends Thread &#123;    @Override    public void r">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 基础系列（09）">
<meta property="og:url" content="http://example.com/2023/06/20/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8809%EF%BC%89/index.html">
<meta property="og:site_name" content="Luyan&#39;s Bolg">
<meta property="og:description" content="并发基础线程基本概念线程表示一条单独的执行流，它有自己的程序执行计数器，有自己的栈。 创建线程创建线程有两个方式，一种是继承Thread类，一种是实现Runnable接口。 继承 Thread一个类继承Thread类并实现run方法来实现一个线程： 123456class HelloThread extends Thread &#123;    @Override    public void r">
<meta property="og:locale">
<meta property="article:published_time" content="2023-06-20T04:09:54.000Z">
<meta property="article:modified_time" content="2024-08-02T04:16:10.138Z">
<meta property="article:author" content="Lu Yan">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="后端">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2023/06/20/Java-基础系列（09）/"/>





  <title>Java 基础系列（09） | Luyan's Bolg</title>
  








<meta name="generator" content="Hexo 7.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Luyan's Bolg</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不积跬步，无以至千里；不积小流，无以成江海。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/index.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/20/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8809%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java 基础系列（09）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-06-20T12:09:54+08:00">
                2023-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h3><h4 id="线程基本概念"><a href="#线程基本概念" class="headerlink" title="线程基本概念"></a>线程基本概念</h4><p>线程表示一条单独的执行流，它有自己的程序执行计数器，有自己的栈。</p>
<h5 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h5><p>创建线程有两个方式，一种是继承<code>Thread</code>类，一种是实现<code>Runnable</code>接口。</p>
<h6 id="继承-Thread"><a href="#继承-Thread" class="headerlink" title="继承 Thread"></a>继承 Thread</h6><p>一个类继承<code>Thread</code>类并实现<code>run</code>方法来实现一个线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>run</code>方法类似于单线程下的<code>main</code>方法，线程从<code>run</code>的第一条语句开始执行直到结束。<br>线程想要执行需要先创建线程对象，再调用对象的<code>start</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HelloThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
<p>为什么重写<code>run</code>方法却需要调用<code>start</code>方法？因为<code>start</code>是启动线程方法，可以使线程成为一条独立的执行流，操作系统也会为其分配必要的资源。而<code>run</code>方法则定义线程要做的事情。<br>如果我不调用<code>start</code>而是直接调用<code>run</code>会怎样？其实从本质讲<code>run</code>就是一个普通的方法，直接调用<code>run</code>方法并不会新开线程，而是在本线程执行这个方法。<br><code>Thread</code>有一个静态方法可以获取当前在哪个线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title function_">currentThread</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>而每一个线程都有一个 id 和 name，可以使用下面的方法获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p><strong>Java 中会等所有的线程都执行结束然后整个程序结束，并不是 main 结束了，就不管其它线程了。</strong></p>
<h6 id="实现-Runnable"><a href="#实现-Runnable" class="headerlink" title="实现 Runnable"></a>实现 Runnable</h6><p>Java 只能单继承，所以有时候继承<code>Thread</code>就不方便了。此时我们可以实现<code>Runnable</code>接口，接口的定义很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面只有一个<code>run</code>方法，我们需要实现它，例如上面的例子可以改成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 展示一下当前在哪个线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello!&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们想要启动线程还是需要创建一个<code>Thread</code>对象，然后调用其<code>start</code>方法，不过此时创建对象的时候需要传递一个<code>Runnable</code>进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">HelloRunnable</span>());</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
<h5 id="线程基本属性和方法"><a href="#线程基本属性和方法" class="headerlink" title="线程基本属性和方法"></a>线程基本属性和方法</h5><p>线程有一些基本属性和方法，包含 id、name、优先级、状态、是否 daemon 线程、sleep 方法、yield 方法、join 方法以及一些过时的方法。</p>
<h6 id="id-name"><a href="#id-name" class="headerlink" title="id &amp; name"></a>id &amp; name</h6><p>正如上面所说，每个线程都有一个<code>id</code>和<code>name</code>。<code>id</code>是一个递增整数，每创建一个线程就<code>+1</code>。<br><code>name</code>的默认值是<code>Thread-</code>再跟上编号。<code>name</code>属性可以在<code>Thread</code>的构造方法里面指定，也可以调用<code>setName</code>方法进行设定。给线程起一个友好的名字可以方便我们的调试。</p>
<h6 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h6><p>线程有一个优先级的概念，Java 中优先级从 1 到 10，默认为 5，相关方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getPriority</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setPriority</span><span class="params">(<span class="type">int</span> newPriority)</span></span><br></pre></td></tr></table></figure>
<p>这个优先级会映射到操作系统的线程优先级，但是注意：优先级对操作系统只是一种建议，并非强制。因此我们不应过度依赖优先级。</p>
<h6 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h6><p>线程都有一个状态，我们可以使用下面的方法获取线程当前的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> State <span class="title function_">getState</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>返回值是<code>Thread.State</code>类型，是一种枚举类型，有以下取值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>NEW</code>，没调用过<code>start</code>的线程状态为<code>NEW</code></li>
<li><code>TERMINATED</code>，线程执行结束后的状态为<code>TERMINATED</code></li>
<li><code>RUNNABLE</code>，线程在执行<code>run</code>方法且没有阻塞的情况下状态为<code>RUNNABLE</code>；但这不等于线程正在执行，有可能线程在等待时间片。</li>
<li><code>BLOCKED</code>、<code>WAITING</code>、<code>TIMED_WAITING</code>都表示线程被阻塞，区别后面讲</li>
</ul>
<p><code>Thread</code>还有一个方法可以返回线程是否还活着：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>线程被启动后，直到<code>run</code>方法运行结束前返回值都是<code>true</code>。</p>
<h6 id="是否-daemon-线程"><a href="#是否-daemon-线程" class="headerlink" title="是否 daemon 线程"></a>是否 daemon 线程</h6><p><code>daemon</code>线程是辅助线程，一般为其它线程打辅助，相关方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isDaemon</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setDaemon</span><span class="params">(<span class="type">boolean</span> on)</span></span><br></pre></td></tr></table></figure>
<p>之前说 Java 会等所有线程运行结束才结束程序，但实际上 Java 不会等<code>daemon</code>线程。也就是说如果剩下的都是<code>daemon</code>线程，那么整个程序也是直接结束，毕竟主线程都运行结束了，这些辅助线程也就没有存在的必要了。<br>例如我们运行一个 Java 程序，除了主线程外，还会有一些诸如垃圾回收线程的辅助线程，主线程一结束，这些辅助线程也会直接退出。</p>
<h6 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h6><p><code>Thread</code>有一个静态的<code>sleep</code>方法，调用该方法能让线程睡眠指定时间，单位毫秒：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>
<p>睡眠期间线程会让出 CPU，且可以被中断，中断时会抛出<code>InterruptedException</code>异常。</p>
<h6 id="join"><a href="#join" class="headerlink" title="join"></a>join</h6><p>Java 中多个线程执行并不会互相等待，该执行完就执行完。此时就需要<code>join</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限定等待时长，设为 0 表示无限等待</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure>
<p>线程在等待过程中可以被中断，中断仍然会抛<code>InterruptedException</code>异常。<br>如果我们想让主线程在所有子线程执行完毕后再结束可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">thread.start();</span><br><span class="line">thread.join();</span><br><span class="line">System.out.println(<span class="string">&quot;主线程结束&quot;</span>);</span><br></pre></td></tr></table></figure>
<h6 id="过时方法"><a href="#过时方法" class="headerlink" title="过时方法"></a>过时方法</h6><p><code>Thread</code>中有一些看似可以控制线程生命周期的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">suspend</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resume</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>这些方法都被标记为过时，我们不应使用它们。</p>
<h5 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h5><p>对于不同线程来说，方法里面的参数及局部变量都是各有一份。但线程之间也是可以共享内存的，不同线程可以访问操作同一个对象。我们看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        counter++;</span><br><span class="line">        list.add(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">t1.list = t2.list = list;</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">System.out.println(MyThread.counter);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<p>2<br>[Thread-0, Thread-1]<br>大多数情况下程序输出如左所示，可以看出两个线程确实共享了内存。</p>
<h6 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h6><p>竞态条件指的是多个线程访问操作一个对象时，最终的执行结果与执行时序有关，可能正确有可能不正确，看例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">System.out.println(MyThread.counter);</span><br></pre></td></tr></table></figure>
<p>这个例子中，每个线程都会将某一个静态变量自增 1000，一共两个线程。预期结果应该是 2000，多测执行后发现结果可能是 2000，也有可能会出现小于 2000 的其它数字。出现这个问题的原因和<code>count++</code>的执行流程有关，流程如下：</p>
<ol>
<li>取变量<code>count</code>的值</li>
<li>在当前值的基础上<code>+1</code></li>
<li>将新值赋值给变量<code>count</code></li>
</ol>
<p>多线程运行的时候，可能在某一刻同时执行第一步，取到了相同的值，所以出现了漏加的问题。<br>解决这样问题的方式有很多 ，例如：</p>
<ol>
<li>使用<code>synchronized</code>关键字</li>
<li>使用显示锁</li>
<li>使用原子变量</li>
</ol>
<p>后面会对这些方法做详细介绍。</p>
<h6 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h6><p>多个线程可以访问操作同一个变量，但一个线程对共享变量的操作，另一个线程不一定能马上看到，甚至永远也看不到，看例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        MyThread.shutdown = <span class="literal">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Exit Main&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">shutdown</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!shutdown) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Exit Child!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据直觉，子线程会做死循环，直到 1 秒后主线程修改了变量<code>shutdown</code>，最终两个线程都会圆满结束。实际上，主线程会正常退出，但子线程会一直执行。下面阐述一下原因：<br>因为是死循环，所以一开始子线程会频繁访问变量<code>shutdown</code>，于是这个变量会缓存到寄存器里。接下来主线程修改了变量<code>shutdown</code>，但子线程压根不从内存读取这个变量，而是在寄存器缓存里面读取，所以这个修改子线程根本看不到，于是就会一直死循环。解决这个问题的方案可以：</p>
<ol>
<li>使用<code>volatile</code>关键字；</li>
<li>使用<code>synchronized</code>关键字或显示锁同步；</li>
</ol>
<p>这些方法在后面也会详细介绍。</p>
<h5 id="线程的优点及成本"><a href="#线程的优点及成本" class="headerlink" title="线程的优点及成本"></a>线程的优点及成本</h5><p>多线程的优点主要有：</p>
<ol>
<li>充分利用多 CPU 的计算能力；</li>
<li>充分利用硬件资源，CPU 与 IO 或磁盘操作完全是可以同时进行，此时就比较适合使用多线程来操作；</li>
<li>在存在用户界面的程序中，界面和后台任务通常使用不同的线程，否则在处理后台任务时，界面会一直不响应，体验很差；</li>
</ol>
<p>但我们需要知道，使用线程是有成本的。首先创建线程需要消耗操作系统的资源，操作系统会为每一个线程创建必要的数据结构、栈、程序计数器等，且创建线程本身也需要一定的时间。此外线程的调度和切换也是有成本的，当有大量线程的时候，操作系统会忙于调度，而每一次切换线程都需要保存当前线程的上下文状态，并恢复将要执行线程的上下文状态，整个过程称为上下文切换。<br>一般来说，对于 CPU 密集型的任务就不适合创建多于 CPU 数量的线程。</p>
<h4 id="理解-synchronized"><a href="#理解-synchronized" class="headerlink" title="理解 synchronized"></a>理解 synchronized</h4><h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><p><code>synchronized</code>关键字可以修饰实例方法、静态方法和代码块，我们依次介绍。</p>
<h6 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h6><p>上面介绍的计数器在多个线程并发执行<code>counter++</code>会出现问题，而原因就是这条语句不是原子操作，这个问题可以使用<code>synchronized</code>关键字解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Counter counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(Counter counter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.counter = counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">            counter.incr();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(counter);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(counter);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line"><span class="comment">// 这边一定会输出 2000</span></span><br><span class="line">System.out.println(counter.getCounter());</span><br></pre></td></tr></table></figure>
<p><code>Counter</code>是一个简单的计数器类，里面的<code>incr</code>和<code>getCounter</code>方法都被<code>synchronized</code>关键字修饰。事实上就是加锁，每个对象都有一个锁和等待队列，锁只能被一个线程持有，其它试图获取锁的线程需要等待。执行<code>synchronized</code>实例方法的过程大致如下：</p>
<ol>
<li>尝试获取锁，成功获取进行下一步，否则阻塞并加入等待队列；</li>
<li>执行实例方法体；</li>
<li>释放锁，如果等待队列里有线程，则从中选一个唤醒；若有多个等待的线程，唤醒哪一个是不一定的，不能保证公平性。</li>
</ol>
<p>当前线程不能获取锁而加入等待队列的时候状态会变为<code>BLOCKED</code>。<br>一个对象里所有的<code>synchronized</code>方法同一时刻只能被一个线程访问，这个例子里面如果一个线程正在访问<code>incr</code>方法，那么另一个线程即使想要访问的是<code>getCounter</code>方法也会被阻塞。注意，我们限制的是同一个对象中的加锁实例方法，具体的说<code>synchronized</code>实例方法保护的是当前对象即<code>this</code>。<strong>总结来说就是同一个对象的加锁方法之间不能并发访问，加锁方法与非加锁方法之间不限制。</strong>所以需要保护一个变量的时候，我们会给所有访问该变量的方法加上<code>synchronized</code>关键字。</p>
<h6 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h6><p><code>synchronized</code>关键字也可以用于静态方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前就介绍过，不同对象的实例方法都是独立的，但静态方法是共享的。因为静态方法属于类而不是对象，上面说的<code>synchronized</code>实例方法保护的是<code>this</code>，那么<code>synchronized</code>静态方法保护的是<code>StaticCounter.class</code>。<br>正是因为<code>synchronized</code>静态方法和实例方法保护的不是同一个对象，所以不同线程可以同时访问加锁静态方法与加锁实例方法。</p>
<h6 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h6><p><code>synchronized</code>关键字除了可以修饰方法，还可以修饰代码块。例如下面的写法就和<code>Counter</code>类等价：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> counter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>synchronized</code>关键字后面小括号中写需要保护的对象，我们这边写<code>this</code>就表示保护当前对象。我们也可以使用一样的方法改造静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (StaticCounter.class) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (StaticCounter.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> counter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上考虑一下本质，所谓的保护对象就是每次访问的时候获取这个对象的锁，能获取到才会执行方法体。而每一个对象都有一个锁，所以可以下出下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">return</span> counter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个代码里面可以看出，我们每次会获取对象<code>lock</code>的锁。这个和使用<code>this</code>相比更灵活，我们可以自己配置不同的锁来适应不同的运用场景。</p>
<h5 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h5><p>了解完<code>synchronized</code>关键字的基本用法之后，我们再从可重入性、内存可见性、死锁的角度进一步介绍。</p>
<h6 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h6><p>可重入性指线程获取锁之后，在方法中调用其它需要同一种锁的代码时可以直接调用。这是一种很自然的性质，之所以强调是因为有其它锁是不可重入的。<br>可重入性的实现是记录锁的持有线程及持有数量，在调用被<code>synchronized</code>保护的代码时首先检查对象是否已被锁，如果是再检查是否被当前线程锁定，如果是增加持有数量；如果不是被当前线程锁定则等待；释放锁时减少持有数量，数量变为 0 时才算是释放整个锁。</p>
<h6 id="内存可见性-1"><a href="#内存可见性-1" class="headerlink" title="内存可见性"></a>内存可见性</h6><p><code>synchronized</code>关键字的主要作用是保证操作的原子性，那如果一个操作本身就是原子操作，那么是否还需要使用<code>synchronized</code>关键字？例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Switcher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> on;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOn</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> on;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOn</span><span class="params">(<span class="type">boolean</span> on)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.on = on;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>long</code>和<code>double</code>在 32 位 JVM 上的读写不是原子性的，而在 64 位 JVM 上是原子性的；<br>引用的读写无论是 32 位还是 64 位都是原子性的，因为引用本质上就是指针，指针大小跟位数是一致的；<br>从原子性的角度讲确实不需要使用<code>synchronized</code>关键字，但还有一个内存可见性。子线程在频繁访问某变量的时候，不一定会从内存读取这个变量的值，也有可能从寄存器之类的缓存读写。使用<code>synchronized</code>关键字在获取或释放锁时一定会操作内存。<br>不过为了内存可见性而使用<code>synchronized</code>关键字成本就太高了。有更轻量级的实现是使用<code>volatile</code>关键字修饰变量如<code>private volatile boolean on;</code>也能保证读写的是最新的内存内容。</p>
<h6 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h6><p>死锁是类似这样的现象：a 线程持有锁 A 在等待锁 B，b 线程持有锁 B 在等待锁 A，a 与 b 互相等待，最终两者都无法执行。我们应该怎么解决死锁问题呢？<br>首先，我们应该避免在持有一个锁的同时去申请另一个锁；如果确实需要多个锁，所有代码应该按照相同的顺序去申请锁，例如上面的例子中线程 a 与 b 都先申请锁 A 再申请锁 B；不过在复杂的应用场景下这种约定很难实现，我们可以使用后续介绍的显式锁接口，它支持尝试获取锁和带时间限制的获取锁，使用这些方法可以在获取不到锁的时候释放已经持有的锁，然后再次尝试获取锁或干脆放弃以避免死锁。</p>
<h5 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h5><p> <code>Collections</code>类中有一些方法可以返回线程安全的容器，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">synchronizedCollection</span><span class="params">(Collection&lt;T&gt; c)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title function_">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span></span><br></pre></td></tr></table></figure>
<p>返回的这些容器都是给方法加上<code>synchronized</code>关键字实现的，其部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SynchronizedCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Collection&lt;E&gt; c; <span class="comment">//Backing Collection</span></span><br><span class="line">    <span class="keyword">final</span> Object mutex; <span class="comment">//Object on which to synchronize</span></span><br><span class="line">    SynchronizedCollection(Collection&lt;E&gt; c) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">        mutex = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.size();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.add(e);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.remove(o);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为全部加上了<code>synchronized</code>关键字，所以容器里的所有操作相当于原子操作。但是客户端在调用的时候还是有可能出现问题的，至少有复合操作、伪同步、迭代这几种情况需要注意。</p>
<h6 id="复合操作"><a href="#复合操作" class="headerlink" title="复合操作"></a>复合操作</h6><p>我们知道同步容器的单个操作都是原子操作，但多个操作组合在一起就不一定了。看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">EnhancedMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;K, V&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EnhancedMap</span><span class="params">(Map&lt;K, V&gt; map)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = Collections.synchronizedMap(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="literal">null</span>) <span class="keyword">return</span> old;</span><br><span class="line">        <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们实现了一个增强版的 Map，里面主要添加了一个<code>putIfAbsent</code>方法，这个方法只有在键不存在的时候才会执行插入。<br>多线程执行<code>putIfAbsent</code>方法时，可能在某一时刻有多个线程执行<code>map.get</code>方法且都返回<code>null</code>，于是这些线程又都执行了<code>map.put</code>，这很显然与我们的设计相悖。</p>
<h6 id="伪同步"><a href="#伪同步" class="headerlink" title="伪同步"></a>伪同步</h6><p>基于上面的案例，我们将<code>putIfAbsent</code>方法修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    <span class="keyword">if</span> (old != <span class="literal">null</span>) <span class="keyword">return</span> old;</span><br><span class="line">    <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们仅仅是给<code>putIfAbsent</code>加上<code>synchronized</code>关键字修饰，是否能够解决上面提出的问题？<br>答案是否定的，因为同步错了对象。<code>EnhancedMap</code>中<code>putIfAbsent</code>和<code>put</code>方法可以被多线程同时调用，这就可能出现一种情况：<code>putIfAbsent</code>方法中判定的时候发现键不存在，然后执行插入的时候发现这个键已经被<code>put</code>方法插入进去了，此时又与我们的设计相悖。<br>想要解决这个问题，所有方法必须使用相同的锁。即可以是<code>EnhancedMap</code>对象的锁，也可以是内部<code>map</code>对象的锁。</p>
<ul>
<li>如果使用<code>EnhancedMap</code>对象的锁，那么<code>EnhancedMap</code>里所有方法都需要加<code>synchronized</code>关键字修饰。</li>
<li>如果使用内部<code>map</code>对象的锁，<code>putIfAbsent</code>方法就可以改为：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(map)&#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(old != <span class="literal">null</span>) <span class="keyword">return</span> old;</span><br><span class="line">        <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h6><p>对于同步容器对象的单个操作是安全的，但是迭代并不安全，也就是说迭代和其它方法可以并发运行。<br>这种情况下，如果一个线程修改容器，另一个线程遍历容器，那么遍历的时候很可能抛异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure>
<p>解决方案可以在遍历的时候对容器加锁。</p>
<h5 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h5><p>同步容器使用<code>synchronized</code>关键字，效率较低。Java 还有许多专为并发设计的容器类：</p>
<ul>
<li>CopyOnWriteArrayList</li>
<li>ConcurrentHashMap</li>
<li>ConcurrentLinkedQueue</li>
<li>ConcurrentSkipListSet</li>
</ul>
<p>这些容器都没有使用<code>synchronized</code>关键字但线程安全，具体后续章节介绍。</p>
<h4 id="线程的基本协作机制"><a href="#线程的基本协作机制" class="headerlink" title="线程的基本协作机制"></a>线程的基本协作机制</h4><p>线程之间除了互相竞争资源外，还经常需要互相协作。线程间协作的基本机制是<code>wait/notify</code>，我们下面详细讨论。</p>
<h5 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait&#x2F;notify"></a>wait&#x2F;notify</h5><p>Java 在<code>Object</code>类而不是<code>Thread</code>类里面定义了一些线程协作方法，这使得每一个对象都可以调用这些方法。这些方法分为两类，一类是<code>wait</code>，一类是<code>notify</code>。<br>一共有两个<code>wait</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>
<p>带参数的表示最多等待时长，单位是毫秒，传入 0 表示无限期等待。不带参数的<code>wait</code>方法实际上是调用<code>wait(0)</code>表示无限期等待。线程在等待期间可以被中断，中断时会抛异常<code>InterruptedException</code>。<br>我们之前说每个对象都有锁和等待队列，如果线程获取锁失败会将线程加入到等待队列里面，这个等待队列称为<strong>锁的等待队列</strong>。除此之外，每个对象还有一个等待队列，表示条件队列，我们使用这个队列进行线程间的协作。调用<code>wait</code>方法会将线程加入到条件队列，表示它需要某些条件，这个条件往往由其它线程提供。所需条件满足后，其它线程可以调用阻塞线程的<code>notify</code>方法将其唤醒：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p><code>notify</code>方法会从条件队列里选一个线程，将其从队列里删除并唤醒。<code>notifyAll</code>则是从队列里删除并唤醒所有线程。看一个案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WaitThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;FINISH&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">wake</span><span class="params">()</span> &#123;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">WaitThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t.wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子有两个线程：主线程和子线程。子线程运行后会陷入等待，主线程 1 秒后会唤醒子线程。<br>这里面有个注意点，<code>wait</code>和<code>notify</code>的方法调用需要写在同步代码块里，即调用谁的<code>wait/notify</code>方法，就需要获取谁的锁。如果调用两者的时候没有获取到锁，会抛异常<code>java.lang.IllegalMonitorStateException</code>。<br>那么你可能会疑惑，调用<code>wait</code>方法的时候需要持有锁，然后线程陷入等待，此时其它线程还怎么获取锁调用<code>notify</code>？这我们就要详细了解一下<code>wait</code>方法，调用<code>wait</code>之后：</p>
<ol>
<li>将当前线程放入条件等待队列，<strong>释放对象锁</strong>，线程状态变为<code>WAITING</code>或<code>TIMED_WAITING</code>；</li>
<li>等待时间到或被其它线程调用<code>notify</code>唤醒后，需要重新竞争对象锁（代码写在同步代码块中当然需要锁）：<ul>
<li>获取到了对象锁，线程状态置为<code>RUNNABLE</code>，代码从<code>wait</code>里返回；</li>
<li>没获取到锁，将线程放入锁的等待队列，线程状态置为<code>BLOCKED</code>；直到获取到锁才会从<code>wait</code>里返回。</li>
</ul>
</li>
</ol>
<p>在多线程协作中，设线程 A 需要线程 B 与 C 先做完某些操作然后再执行 A 里的代码。在 B 与 C 结束前 A 应该陷入等待，若 B 提前完成任务调用<code>notify</code>通知了 A，我们知道此时 A 是不能唤醒的，因为 A 还需要等待 C。因此我们往往这么写代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;  <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">while</span>(等待条件不成立)  <span class="comment">// 每次从 wait 返回后继续进行判定</span></span><br><span class="line">        obj.wait();</span><br><span class="line">    <span class="comment">// 满足条件后的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>调用<code>wait</code>会释放锁，而调用<code>notify</code>并不会释放。而想要从<code>wait</code>方法返回需要获取到锁，因此只有等包含<code>notify</code>的同步块里代码全部执行完毕，等待的线程才会从<code>wait</code>调用里返回。</p>
<h5 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h5><p>生产者与消费者问题是典型的线程协作案例，生产者与消费共享一个队列，每次生产者往队列添加一个元素，消费者从队列获取一个元素，队列满时生产者进行等待，队列空时消费者等待。生产者和消费者的协作变量是一个队列，用于存放物品的队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyBlockQueue</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;E&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBlockQueue</span><span class="params">(<span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">        <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.size() == limit) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(e);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先设计一个阻塞队列，<code>limit</code>表示队列的最大长度。每次取或放东西时会根据队列状态令线程陷入等待，每次取或放东西成功之后使用<code>notifyAll</code>方法通知所有等待的线程。这个地方使用<code>notify</code>行不行？答案是不行，因为生产者和消费者共用一个条件队列，唤醒时没法指定唤醒谁，所以需要调用<code>notifyAll</code>来唤醒全部。<br>生产者和消费者线程定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyBlockQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(MyBlockQueue&lt;String&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">task</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">                queue.put(task);</span><br><span class="line">                System.out.println(<span class="string">&quot;Produce: &quot;</span> + task);</span><br><span class="line">                Thread.sleep((<span class="type">int</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyBlockQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(MyBlockQueue&lt;String&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">task</span> <span class="operator">=</span> queue.take();</span><br><span class="line">                System.out.println(<span class="string">&quot;Consume: &quot;</span> + task);</span><br><span class="line">                Thread.sleep((<span class="type">int</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主程序代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    MyBlockQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">MyBlockQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Producer</span>(queue).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Consumer</span>(queue).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们实现的阻塞队列只是为了演示，Java 提供了专门的阻塞队列实现，包括：</p>
<ol>
<li>接口<code>BlockingQueue</code>和<code>BlockingDeque</code></li>
<li>基于数组的实现类<code>ArrayBlockingQueue</code></li>
<li>基于链表的实现类<code>LinkedBlockingQueue</code>和<code>LinkedBlockingDeque</code></li>
<li>基于堆的实现类<code>PriorityBlockingQueue</code></li>
</ol>
<p>我们应该优先选择这些类而不是自己实现。</p>
<h5 id="同时开始"><a href="#同时开始" class="headerlink" title="同时开始"></a>同时开始</h5><p>类似于运动员比赛，所有运动员在听到枪响之后统一开始行动。下面我们模拟这个过程，我们将会有一个主线程和 N 个子线程，每个子线程表示一个运动员，主线程表示裁判。它们的协作变量是一个开始信号，所以我们先定义一个类<code>FireFlag</code>表示协作变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FireFlag</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">fire</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">waitForFire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (!fire) wait();  <span class="comment">// 为防止误唤醒，我们一般套个循环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span> &#123;</span><br><span class="line">        fire = <span class="literal">true</span>;</span><br><span class="line">        notifyAll();  <span class="comment">// 通知所有线程开始</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们下面将设计运动员类，所有运动员都将持有同一个<code>FireFlag</code>对象并调用<code>waitForFire</code>方法等待比赛开始，等所有运动员线程就绪后，我们调用<code>FireFlag</code>对象的<code>fire</code>方法通知比赛开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Racer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> FireFlag flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Racer</span><span class="params">(FireFlag flag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            flag.waitForFire();</span><br><span class="line">            <span class="comment">// 下面是线程要做的工作</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; fire!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主程序代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    Thread[] racers = <span class="keyword">new</span> <span class="title class_">Thread</span>[num];</span><br><span class="line">    <span class="type">FireFlag</span> <span class="variable">fireFlag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FireFlag</span>();  <span class="comment">// 信号枪</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        racers[i] = <span class="keyword">new</span> <span class="title class_">Racer</span>(fireFlag);</span><br><span class="line">        racers[i].start();  <span class="comment">// 线程一创建完成就直接启动，反正会陷入等待</span></span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    fireFlag.fire();  <span class="comment">// 通知所有线程开始工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="等待结束"><a href="#等待结束" class="headerlink" title="等待结束"></a>等待结束</h5><p>之前我们想让主线程等所有子线程结束再结束，我们会在主线程调用所有子线程的<code>join</code>方法。而<code>join</code>的主要实现是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，只要子线程还活着，就将主线程阻塞。当线程运行结束的时候，Java 系统会调用<code>notifyAll</code>来通知等待的线程。<br><strong>总结：</strong>哪个线程调用<code>wait</code>就是哪个线程阻塞，调用的是谁的<code>wait</code>就使用谁的条件队列。<br>线程多的时候需要逐一调用<code>join</code>方法，比较麻烦。我们介绍一种新的实现，主线程与子线程的协作变量是一个数，这个数初始表示子线程的个数，主线程一直等待直到这个数为 0，而每一个子线程结束运行的时候将这个数<code>-1</code>。我们设计一个类<code>MyLatch</code>表示协作对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLatch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;  <span class="comment">// 初始化为子线程个数</span></span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;  <span class="comment">// 只要子线程还存在就让主线程等待</span></span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">cutDown</span><span class="params">()</span> &#123;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;  <span class="comment">// 没有子线程了就通知主线程</span></span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是子线程类实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyLatch myLatch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(MyLatch myLatch)</span> &#123;  <span class="comment">// 所有子线程共享一个 MyLatch</span></span><br><span class="line">        <span class="built_in">this</span>.myLatch = myLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            Thread.sleep((<span class="type">int</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">            myLatch.cutDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">MyLatch</span> <span class="variable">myLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLatch</span>(num);</span><br><span class="line">    Thread[] children = <span class="keyword">new</span> <span class="title class_">Thread</span>[num];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        children[i] = <span class="keyword">new</span> <span class="title class_">Worker</span>(myLatch);</span><br><span class="line">        children[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">    myLatch.await();</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MyLatch</code>只是一种演示，Java 里面有专门的同步协作工具类<code>CountDownLatch</code>后面介绍。<br><code>MyLatch</code>是一种比较通用的工具类，我们可以借助它实现上面“同时开始”的功能。首先将<code>count</code>设为 1，所有子线程创建出来时调用<code>await</code>进行阻塞，当所有子线程都创建完毕，主线程调用<code>cutDown</code>方法通知所有子线程开始。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Racer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyLatch myLatch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Racer</span><span class="params">(MyLatch myLatch)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myLatch = myLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            myLatch.await();</span><br><span class="line">            <span class="comment">// 子线程的工作</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 工作&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">MyLatch</span> <span class="variable">myLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLatch</span>(<span class="number">1</span>);</span><br><span class="line">    Thread[] children = <span class="keyword">new</span> <span class="title class_">Thread</span>[num];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        children[i] = <span class="keyword">new</span> <span class="title class_">Racer</span>(myLatch);</span><br><span class="line">        children[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    myLatch.cutDown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="异步结果"><a href="#异步结果" class="headerlink" title="异步结果"></a>异步结果</h5><p>在主从模式中，子线程做耗时任务，主线程获取计算结果。手动维护子线程的创建及其与主线程的协作是很麻烦的事情，于是我们可以设计一套框架来自动做这些事情。<br>Java 中表示任务的接口是<code>Callable</code>，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了表示异步调用的结果，我们定义一个接口<code>MyFuture</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFuture</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口中<code>get</code>方法会返回真正的计算结果，若还没计算结束就阻塞直到结束。<br>为了避免手动创建并维护子线程，我们定义一个<code>MyExecutor</code>类，里面定义一个<code>execute</code>方法。方法会执行操作并返回异步结果，之所以不直接返回同步结果是因为我们不想调用<code>execute</code>会立刻陷入阻塞，方法声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;V&gt; MyFuture&lt;V&gt; <span class="title function_">execute</span><span class="params">(<span class="keyword">final</span> Callable&lt;V&gt; task)</span></span><br></pre></td></tr></table></figure>
<p>这样在主线程我们就可以写下面的代码进行异步调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">MyExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyExecutor</span>();</span><br><span class="line">    <span class="comment">// 需要子线程做的任务</span></span><br><span class="line">    Callable&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mills</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * <span class="number">1000</span>);</span><br><span class="line">            <span class="comment">// 模拟耗时任务</span></span><br><span class="line">            Thread.sleep(mills);</span><br><span class="line">            <span class="keyword">return</span> mills;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 调用 MyExecutor 的 execute 方法返回异步结果</span></span><br><span class="line">    MyFuture&lt;Integer&gt; future = executor.execute(task);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 get 方法时才会实际阻塞主线程</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封装好的子线程定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExecuteThread</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">V</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Exception</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">done</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; task;</span><br><span class="line">    <span class="keyword">private</span> Object lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExecuteThread</span><span class="params">(Callable&lt;V&gt; task, Object lock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.task = task;</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = task.call();  <span class="comment">// 执行任务</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            exception = e;  <span class="comment">// 保存异常信息</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                done = <span class="literal">true</span>;  <span class="comment">// 子线程成功执行完毕</span></span><br><span class="line">                lock.notifyAll();  <span class="comment">// 通知所有等待的线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Exception <span class="title function_">getException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MyExecutor</code>定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyExecutor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;V&gt; MyFuture&lt;V&gt; <span class="title function_">execute</span><span class="params">(<span class="keyword">final</span> Callable&lt;V&gt; task)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        ExecuteThread&lt;V&gt; thread = <span class="keyword">new</span> <span class="title class_">ExecuteThread</span>&lt;&gt;(task, lock);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyFuture</span>&lt;V&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!thread.isDone()) &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (thread.getException() != <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">throw</span> thread.getException();</span><br><span class="line">                    <span class="keyword">return</span> thread.getResult();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义的<code>MyExecutor</code>和<code>MyFuture</code>都是为了演示原理，实际上 Java 包含一套完整的框架：</p>
<ol>
<li>表示异步结果的接口<code>Future</code>和<code>FutureTask</code></li>
<li>执行异步任务的接口<code>Executor</code>以及包含更多功能的子接口<code>ExecutorService</code></li>
<li>用于创建<code>Executor</code>和<code>ExecutorService</code>的工厂类<code>Executors</code></li>
</ol>
<p>我们会在后续介绍这套框架。</p>
<h5 id="集合点"><a href="#集合点" class="headerlink" title="集合点"></a>集合点</h5><p>这类似于旅游，所有游客先自由活动，然后所有人在一个点集合。这些线程的协作变量就是这个集合点，我们定义<code>AssemblePoint</code>类描述这个点，类中定义变量<code>count</code>表示未到线程的个数，初始等于总线程数，每到一个线程就<code>count--</code>，当<code>count</code>变为 0 时表示所有线程到齐了，最后一个到的线程发通知。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AssemblePoint</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AssemblePoint</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;  <span class="comment">// 所有线程到齐了就通知大家</span></span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 否则陷入等待</span></span><br><span class="line">            <span class="keyword">while</span> (count != <span class="number">0</span>) wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tourist</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AssemblePoint ap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tourist</span><span class="params">(AssemblePoint ap)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ap = ap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="type">int</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 到场&quot;</span>);</span><br><span class="line">            ap.await();  <span class="comment">// 任务做完就去集合</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[num];</span><br><span class="line">    <span class="type">AssemblePoint</span> <span class="variable">ap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AssemblePoint</span>(num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        threads[i] = <span class="keyword">new</span> <span class="title class_">Tourist</span>(ap);</span><br><span class="line">        threads[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h4><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>线程开始运行后会执行<code>run</code>方法，<code>run</code>运行结束后线程就会退出。一般来说结束线程有以下场景：</p>
<ol>
<li>很多线程的执行任务是死循环，因此我们需要一种方式来关闭这种线程；</li>
<li>在图形界面程序中，许多线程是用户开启的，例如点击按钮开始下载，在下载过程中用户可能想要取消这个任务；</li>
<li>在一些场景下，程序会向服务器请求数据，但是超过指定时间就会自动取消这个任务；</li>
<li>有时我们会使用多个线程做同一件事，例如抢火车票，其中任一线程抢到票都需要通知其它线程取消。</li>
</ol>
<h5 id="关闭线程"><a href="#关闭线程" class="headerlink" title="关闭线程"></a>关闭线程</h5><p><code>Thread</code>类定义了<code>stop</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>这个方法看上去可以停止线程，但被标记为过时，我们<strong>不应该使用它</strong>。<br>Java 里停止线程的主要机制是中断，<strong>中断并不是强迫终止一个线程，它是一种协作机制，是给线程传递一个取消信号，由线程决定如何及何时退出</strong>。<code>Thread</code>定义了如下关于中断的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>每个线程都有一个标志位表示该线程是否被中断了，这三个方法分别：</p>
<ol>
<li><code>isInterrupted</code>是实例方法，返回中断标记位是否为<code>true</code>；</li>
<li><code>interrupt</code>是实例方法，表示中断对应的线程；</li>
<li><code>interrupted</code>是静态方法，它实际上会调用<code>Thread.currentThread()</code>操作当前线程。返回当前中断标记位是否为<code>true</code>，同时它还能清空中断标记位。即线程本来被中断了，调用这个方法会返回<code>true</code>，然后将这个标记位置为<code>false</code>。</li>
</ol>
<h5 id="线程对中断的反应"><a href="#线程对中断的反应" class="headerlink" title="线程对中断的反应"></a>线程对中断的反应</h5><p><code>interrupt()</code>对线程的影响与线程的状态及线程正在进行的 IO 操作有关，我们主要考虑线程状态。</p>
<h6 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h6><p>如果线程正在运行态且没有进行 IO 操作，<code>interrupt()</code><strong>只会</strong>设置线程的中断标记位。因此我们设计线程的时候应该在合适的位置检查标记位，看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterruptRunnableDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 检查线程的中断标记位</span></span><br><span class="line">        <span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="comment">// 操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="WAITING-TIMED-WAITING"><a href="#WAITING-TIMED-WAITING" class="headerlink" title="WAITING&#x2F;TIMED_WAITING"></a>WAITING&#x2F;TIMED_WAITING</h6><p>线程调用<code>join/wait/sleep</code>方法后会进入<code>WAITING/TIMED_WAITING</code>状态，在这些状态时，对线程对象调用<code>interrupt()</code>会使该线程抛出<code>InterruptedException</code>异常并将状态变为<code>RUNNABLE</code>。注意抛出异常后，<strong>中断标记位会被清空</strong>而不会设置为<code>true</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> ()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(isInterrupted());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">t.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">t.interrupt();</span><br></pre></td></tr></table></figure>
<p>程序的输出为<code>false</code>，因为出现中断异常会清空标记位。<br>我们一般捕获到<code>InterruptedException</code>表示要结束该线程，大致有两种处理方式：</p>
<ol>
<li>向上传递异常，由调用者处理；</li>
<li>某些情况下不能向上传递异常，例如<code>Thread</code>的<code>run</code>方法，它的声明是固定的，不能抛出受检异常。此时应该做合适的清理操作，清理后一般调用线程的<code>interrupt()</code>方法将标记位置为<code>true</code>，使得其它代码能够知道该线程是否发生了中断。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterruptWaitingDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟任务</span></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 清理操作并重设标记位</span></span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h6><p>如果线程在等待锁，对线程对象调用<code>interrupt()</code>方法只会设置中断标记位，并不会改变<code>BLOCKED</code>的状态。也就是说<code>interrupt()</code>并不能使等待锁的线程真正中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptSynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">            a.start();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            a.interrupt();</span><br><span class="line">            a.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先主线程调用<code>test</code>方法获取了锁<code>lock</code>，然后启动子线程<code>a</code>；<br>而子线程<code>a</code>因为等待锁<code>lock</code>陷入阻塞，此时主线程调用<code>a.interrupt()</code>中断子线程<code>a</code>，但这并不能改变<code>a</code>的阻塞状态；<br>接着主线程调用<code>a.join()</code>进入<code>a</code>的条件队列进行等待，本质上是调用<code>a.wait()</code>，过程中会释放对象<code>a</code>的锁而不是<code>lock</code>；<br>最终，主线程持有锁<code>lock</code>陷入等待，而子线程因为得不到<code>lock</code>也陷入等待，因此这个程序结束不了。</p>
<h6 id="NEW-TERMINATE"><a href="#NEW-TERMINATE" class="headerlink" title="NEW&#x2F;TERMINATE"></a>NEW&#x2F;TERMINATE</h6><p>如果线程还没有启动（NEW）或线程已经运行结束（TERMINATE），此时调用<code>interrupt()</code>对线程没有任何效果，中断标记位也不会进行设置。</p>
<h5 id="正确方式"><a href="#正确方式" class="headerlink" title="正确方式"></a>正确方式</h5><p><code>interrupt</code>不一定能真正中断线程，如果我们不知道线程正在做什么，我们不应该贸然调用<code>interrupt</code>中断它，从而误认为这样可以取消线程。<br>对于以线程提供服务的程序来说，它应该封装取消操作暴露给调用者，调用者应该调用这些封装的方法而不是直接使用<code>interrupt</code>。Java 并发库就提供了单独的取消方法，例如<code>Future</code>提供了如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br></pre></td></tr></table></figure>
<p>再如<code>ExecutorService</code>提供了下面两个关闭的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>这些我们后面再详细探讨。</p>
<h3 id="并发包的基石"><a href="#并发包的基石" class="headerlink" title="并发包的基石"></a>并发包的基石</h3><h4 id="原子变量与CAS"><a href="#原子变量与CAS" class="headerlink" title="原子变量与CAS"></a>原子变量与CAS</h4><p>之前为了保证某些操作的原子性，我们会使用关键字<code>synchronized</code>。但使用关键字<code>synchronized</code>成本太高，在这背景下原子变量就出现了，Java 并发包的基本原子变量类型主要有：</p>
<ul>
<li><code>AtomicBoolean</code>原子<code>Boolean</code>类型，常用来表示一个标志位；</li>
<li><code>AtomicInteger</code>原子<code>Integer</code>类型；</li>
<li><code>AtomicLong</code>原子<code>Long</code>类型，常用来在程序中生成唯一序列号；</li>
<li><code>AtomicReference</code>原子引用类型，以原子方式更新复杂类型。</li>
</ul>
<p>这些类大同小异，我们主要介绍<code>AtomicInteger</code>。<br><code>AtomicInteger</code>有两个构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">(<span class="type">int</span> initialValue)</span></span><br></pre></td></tr></table></figure>
<p>其中无参构造默认使用 0 作为初值。<br>此外我们可以调用下面的方法获取或设置<code>AtomicInteger</code>里面的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> newValue)</span></span><br></pre></td></tr></table></figure>
<p>之所以把<code>AtomicInteger</code>称作原子变量，是因为它里面包含一些以原子方式进行操作的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以原子方式获取旧值并设置新值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span></span><br><span class="line"><span class="comment">// 以原子方式获取旧值并给当前值 +1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 以原子方式获取旧值并给当前值 -1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 以原子方式获取旧值并给当前值 +delta</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span></span><br><span class="line"><span class="comment">// 以原子方式给当前值 +1 并获取新值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 以原子方式给当前值 -1 并获取新值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">decrementAndGet</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 以原子方式给当前值 +delta 并获取新值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">addAndGet</span><span class="params">(<span class="type">int</span> delta)</span></span><br></pre></td></tr></table></figure>
<p>这些方法的实现都依赖于另一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span></span><br></pre></td></tr></table></figure>
<p>这是一个非常重要的方法，比较并设置，我们将其简称为 <strong>CAS</strong>。它有两个参数<code>expect</code>和<code>update</code>，它的功能是：如果当前值是<code>expect</code>那么就将其改为<code>update</code>，否则不做修改，这个方法会返回是否修改成功。多线程操作同一个原子变量总能保证正确性。<br>上面的原子操作实现基本类似，我们看一下<code>incrementAndGet</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路很简单，每次记录当前值，然后设置新值的时候比较当前值是否发生了修改，若没修改自己就修改它，否则若是当前值被其它线程修改了就重复上述操作。<br><code>synchronized</code>是悲观锁，它假定更新很可能出现冲突，于是所有的更新都需要获取到锁才能继续下去。而这边的原子变量是乐观锁，它假定冲突较少，如果检测到冲突就再试一次。<br>我们可以利用原子变量实现类似<code>synchronized</code>的悲观锁效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">status</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!status.compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            Thread.<span class="keyword">yield</span>();  <span class="comment">// 将线程从执行态改为就绪态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        status.compareAndSet(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程访问互斥内容时，先调用<code>lock</code>方法进行锁定。若有多个线程想要访问同一块内容，后来者会陷入<code>lock</code>的循环中直到先来者调用<code>unlock</code>解除锁定。</p>
<h4 id="显式锁"><a href="#显式锁" class="headerlink" title="显式锁"></a>显式锁</h4><p>显式锁主要为了解决<code>synchronized</code>的局限性，相关的接口与类主要有：</p>
<ol>
<li>锁接口<code>Lock</code>，其主要的实现类<code>ReentrantLock</code>；</li>
<li>读写锁接口<code>ReadWriteLock</code>，其主要的实现类<code>ReentrantReadWriteLock</code>。</li>
</ol>
<h5 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h5><p>显式锁接口<code>Lock</code>定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">    Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lock()/unlock()</code>就是普通的申请和释放锁方法，<code>lock</code>会阻塞直到获取到锁；</li>
<li><code>lockInterruptibly() </code>是可以响应中断的申请锁方法，若被其它线程中断会抛出<code>InterruptedException</code>；</li>
<li><code>tryLock()</code>尝试获取锁，获取到锁返回<code>true</code>，获取不到也不会阻塞直接返回<code>false</code>；</li>
<li><code>boolean tryLock(long time, TimeUnit unit)</code>与上面一样也是尝试获取锁，但是未获取到会阻塞一段时间，期间可以被中断，中断会抛出<code>InterruptedException</code>；</li>
<li><code>newCondition()</code>新建一个条件，关于条件后面说。</li>
</ul>
<h5 id="ReentrantLock-类"><a href="#ReentrantLock-类" class="headerlink" title="ReentrantLock 类"></a>ReentrantLock 类</h5><h6 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h6><p><code>ReentrantLock</code>有两个构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span></span><br></pre></td></tr></table></figure>
<p>参数<code>fair</code>表示是否保证公平，公平指的是等待时间最长的线程优先获取锁。因为保证公平会影响效率，所以默认是不保证的，<code>synchronized</code>也是不保证公平的。<br>一般而言一个线程获取到锁之后，即使后面发生异常也应该把锁释放。于是调用<code>lock</code>之后会使用<code>try</code>将后面的代码包裹起来，然后在<code>finally</code>里面释放锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;  <span class="comment">// lock 后面的代码放到 try 里</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  <span class="comment">// finally 里面释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="tryLock-避免死锁"><a href="#tryLock-避免死锁" class="headerlink" title="tryLock 避免死锁"></a>tryLock 避免死锁</h6><p>在持有一个锁去获取另一个锁而不得的时候，放弃已经得到的锁，给其它线程获取锁的机会，然后再尝试获取所有锁。假设有银行账户类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">double</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.money += money;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        add(-money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lock.tryLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Account</code>类里的<code>money</code>表示余额，<code>add</code>与<code>reduce</code>用来操作余额。我们对两个账户进行转账的时候应该将两个账户都锁定，下面我们使用<code>lock</code>进行锁定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccountMgr</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NotEnoughMoneyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account from, Account to, <span class="type">double</span> money)</span> </span><br><span class="line">      <span class="keyword">throws</span> NotEnoughMoneyException &#123;</span><br><span class="line">        from.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            to.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (from.getMoney() &lt; money) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotEnoughMoneyException</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    from.reduce(money);   </span><br><span class="line">                    to.add(money);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                to.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            from.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码看似没有问题，考虑这样的场景：A 与 B 两个账户在同一时刻向对象转账，此时两人都持有自己的锁，且都在等待对方的锁，那么就陷入了死锁。我们不妨模拟死锁场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">accountNum</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    Account[] accounts = <span class="keyword">new</span> <span class="title class_">Account</span>[accountNum];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; accountNum; ++i) &#123;</span><br><span class="line">        accounts[i] = <span class="keyword">new</span> <span class="title class_">Account</span>(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[threadNum];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadNum; ++i) &#123;</span><br><span class="line">        threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">loopNum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; loopNum; ++k) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> random.nextInt(accountNum);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> random.nextInt(accountNum);</span><br><span class="line">                    <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> random.nextInt(<span class="number">10</span>);</span><br><span class="line">                    <span class="keyword">if</span> (m != n) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            AccountMgr.transfer(accounts[m], accounts[n], money);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (AccountMgr.NotEnoughMoneyException e) &#123;&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        threads[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 10 个账户，100 个线程。每个线程随机挑两个账户进行转账，挑 100 次，这个程序大概率能复现死锁。因此我们直到直接使用<code>lock</code>是不行的，我需要使用<code>tryLock</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">tryTransfer</span><span class="params">(Account from, Account to, <span class="type">double</span> money)</span> </span><br><span class="line">  <span class="keyword">throws</span> NotEnoughMoneyException &#123;</span><br><span class="line">    <span class="keyword">if</span> (!from.tryLock()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!to.tryLock()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (from.getMoney() &lt; money) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotEnoughMoneyException</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                from.reduce(money);</span><br><span class="line">                to.add(money);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            to.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        from.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们每次都先尝试获取锁，获取不到就退出函数（同时也会释放获得的锁）。那我们转账的时候可以循环调用<code>tryTransfer</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account from, Account to, <span class="type">double</span> money)</span> </span><br><span class="line">  <span class="keyword">throws</span> NotEnoughMoneyException &#123;</span><br><span class="line">    <span class="keyword">while</span> (!tryTransfer(from, to, money)) Thread.<span class="keyword">yield</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h6><p><code>ReentrantLock</code>的实现需要借助类<code>LockSupport</code>，因此我们先看看这个类。<br><strong>1、LockSupport</strong><br><code>LockSupport</code>类有如下基本方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parkNanos</span><span class="params">(<span class="type">long</span> nanos)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parkUntil</span><span class="params">(<span class="type">long</span> deadline)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Thread thread)</span></span><br></pre></td></tr></table></figure>
<p><code>park</code>方法会使当前线程放弃 CPU，进入等待状态（WAITING）。这种状态下，操作系统不会对它进行调度，直到其它线程对它调用了<code>unpark</code>，此时它会恢复到可运行态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> ()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            LockSupport.park();  <span class="comment">// 主动让出 CPU</span></span><br><span class="line">            System.out.println(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);  <span class="comment">// 主线程延迟 1 秒</span></span><br><span class="line">    LockSupport.unpark(t);  <span class="comment">// 唤醒子线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意区分<code>LockSupport.park()</code>与<code>Thread.yield()</code>，前者会让线程陷入等待态，而后者是让线程进入就绪态。<br>需要说明的是<code>park</code>是响应中断的，有中断发生时<code>park</code>方法会返回并设置线程的中断状态。另外值得一提的是<code>park</code>会无缘无故的返回，因此我们需要循环检查<code>park</code>等待的条件是否满足。<br><code>park</code>方法还有两个变体：</p>
<ul>
<li><code>parkNanos</code>可以指定等待的最长时间，单位是纳秒。</li>
<li><code>parkUntil</code>可以指定最长等待到什么时候，参数是相对纪元时的毫秒数。</li>
</ul>
<p><strong>2、AQS</strong><br>其实有了 CAS 与<code>LockSupport</code>已经可以实现<code>ReentrantLock</code>了，但为了代码的重用性，Java 提供了一个抽象类<code>AbstractQueuedSynchronizer</code>简称 AQS。AQS 整体比较复杂，我们以<code>ReentrantLock</code>为脉络进行梳理。<br>AQS 封装了一个状态，给子类提供了查询和设置状态的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span></span><br></pre></td></tr></table></figure>
<p>使用 AQS 实现锁时，它可以保存锁的当前持有线程，提供如下方法进行查询和设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setExclusiveOwnerThread</span><span class="params">(Thread t)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Thread <span class="title function_">getExclusiveOwnerThread</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p><strong>3、ReentrantLock</strong><br><code>ReentrantLock</code>内部有三个内部类使用了 AQS：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span></span><br></pre></td></tr></table></figure>
<p>见名知义，<code>FairSync</code>与<code>NonfairSync</code>分别是公平与不公平<code>ReentrantLock</code>需要的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();  <span class="comment">// 默认是不公平的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们主要看看<code>ReentrantLock</code>的<code>lock</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();  <span class="comment">// 主要就是调用 sync 的 lock 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sync</code>默认是<code>NonfairSync</code>类型，其<code>lock</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NonfairSync 实现的 lock</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))  <span class="comment">// 没人用锁直接锁定且设置锁定的线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// acquire 是 AQS 实现的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NonfairSync 实现的 tryAcquire</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span>(p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>;  <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync 实现的 nonfairTryAcquire</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">0</span>) &#123;  <span class="comment">// 没锁定直接锁定</span></span><br><span class="line">        <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(current == getExclusiveOwnerThread()) &#123;  <span class="comment">// 可重入性</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span>(nextc &lt; <span class="number">0</span>)  <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些方法里主要<code>acquireQueued</code>方法需要理一下，这个方法主体就是一个死循环。循环里如果发现传入的线程是等待队列里的第一个并且当前能获取锁则将传入的线程从等待队列移除并返回，否则调用<code>shouldParkAfterFailedAcquire</code>（最终会调用<code>park</code>）令线程陷入等待。待线程被唤醒之后使用<code>parkAndCheckInterrupt</code>检查线程是否发生了中断。<br>接下来我们看看<code>ReentrantLock</code>的<code>unlock</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS 定义的 release 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span>(h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>tryRelease</code>方法会释放锁，<code>unparkSuccessor</code>方法会调用<code>LockSupport.unpark</code>方法唤醒第一个等待的线程。</p>
<h5 id="显式条件"><a href="#显式条件" class="headerlink" title="显式条件"></a>显式条件</h5><h6 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h6><p>显式锁与<code>synchronized</code>对应，显式条件则与<code>wait/notify</code>相对应。<code>synchronized</code>与<code>wait/notify</code>配合使用，显式锁与显式条件配合使用。条件与锁相关联，创建条件变量需要通过锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p><code>Condition</code>是一个接口，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的<code>awaitXXX</code>都与 Object 的<code>wait</code>相对应，<code>signal/signalAll</code>则与 Object 的<code>notify/notifyAll</code>相对应，它们的语义也是相同的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置最长等待时长，单位是纳秒。返回 nanosTimeout - 实际等待时长</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 设置最长等待时长，单位自定。等待超时了返回 false，否则返回 true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 设置最多等到什么时候</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>
<p>这些等待方法都是响应中断的，发生中断会抛<code>InterruptedException</code>，但中断标记位会清空。<br>此外还有一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>这个方法是不响应中断的，这个方法返回时如果过程中有中断发生会记录在中断标记位里。<br>在调用<code>await</code>方法之前需要先获取锁，如果没有锁会抛<code>IllegalMonitorStateException</code>，因<code>await</code>进入等待队列之后线程会释放锁。从<code>await</code>返回后不一定满足了条件，所以一般是将<code>await</code>的调用放到一个循环里面。<br><code>signal</code>与<code>notify</code>类似，会挑选一个线程唤醒，<code>signalAll</code>会唤醒所有线程。线程被唤醒后要重新竞争锁，获得锁之后才会从<code>await</code>里面返回。<br>我们使用一个例子看条件的具体用法。我们想让子线程开启后等待主线程命令再执行下去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">fire</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!fire) &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;fired&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.interrupted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fire</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.fire = <span class="literal">true</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">WaitThread</span> <span class="variable">waitThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitThread</span>();</span><br><span class="line">        waitThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;fire&quot;</span>);</span><br><span class="line">        waitThread.fire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="生产者与消费者-1"><a href="#生产者与消费者-1" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h6><p>生产者与消费者问题我们在上面已经看过，但是上面使用<code>wait</code>进行线程阻塞有一个问题，就是生产者与消费者阻塞在一条等待队列里，唤醒时无法指定唤醒谁只能使用<code>notifyAll</code>唤醒全部。本节我们使用显式条件创建两个队列分别用来阻塞生产者与消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyBlockingQueue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;T&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBlockingQueue</span><span class="params">(<span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">        <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == limit) &#123;</span><br><span class="line">                notFull.await();  <span class="comment">// 所有生产者都阻塞在 notFull 里</span></span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(t);</span><br><span class="line">            notEmpty.signal();  <span class="comment">// 每生产一次都会唤醒一个消费者</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                notEmpty.await();  <span class="comment">// 所有消费者都阻塞在 notEmpty 里</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            notFull.signal();  <span class="comment">// 每消费一次都会唤醒一个生产者</span></span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将生产者与消费者分队列阻塞，可以避免很多无谓的唤醒，提升效率。</p>
<h6 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h6><p>接下来我们看看<code>ReentrantLock</code>是怎么实现的显式条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock 的 newCondition 方法</span></span><br><span class="line"><span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sync 的 newCondition 方法</span></span><br><span class="line"><span class="keyword">final</span> ConditionObject <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ConditionObject</code>是定义在 AQS 里的内部类，它内部维护一个条件等待队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队首节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"><span class="comment">// 队尾节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br></pre></td></tr></table></figure>
<p>因为<code>ConditionObject</code>是 AQS 的内部类，因此它可以访问 AQS 内部的锁队列。我们先看<code>ConditionObject.await</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 如果等待前中断标记位被设置直接抛出中断异常</span></span><br><span class="line">    <span class="keyword">if</span>(Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 1. 为当前线程创建节点并加入条件等待队列</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="comment">// 2. 释放持有的锁</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 3. 调用 park 陷入等待，循环有两个退出条件：</span></span><br><span class="line">    <span class="comment">//  3.1 等待过程中遇到中断会直接 break</span></span><br><span class="line">    <span class="comment">//  3.2 当前线程节点从等待队列移到了外层的锁列队，即等待的条件已满足</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span>((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 重新获取锁</span></span><br><span class="line">    <span class="keyword">if</span>(acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span>(node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">    unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">//5. 处理中断，抛出异常或设置中断标记位</span></span><br><span class="line">    <span class="keyword">if</span>(interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再看<code>signal</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果未持有锁直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span>(!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="comment">// 唤醒第一个等待的线程</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span>(first != <span class="literal">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>doSignal</code>做的事情主要有：</p>
<ul>
<li>将节点从等待队列移到外层的锁等待队列；</li>
<li>调用<code>LockSupport.unpark</code>将线程唤醒。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag"># 后端</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2023/06/08/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8808%EF%BC%89/" rel="next" title="Java 基础系列（08）">
                <i class="fa fa-chevron-left"></i> Java 基础系列（08）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2023/06/29/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8810%EF%BC%89/" rel="prev" title="Java 基础系列（10）">
                Java 基础系列（10） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/index.html">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">并发基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">线程基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">创建线程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF-Thread"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">继承 Thread</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-Runnable"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">实现 Runnable</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.2.</span> <span class="nav-text">线程基本属性和方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#id-name"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">id &amp; name</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">优先级</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%8A%B6%E6%80%81"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">状态</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%98%AF%E5%90%A6-daemon-%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">是否 daemon 线程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sleep"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">sleep</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#join"><span class="nav-number">1.1.2.6.</span> <span class="nav-text">join</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%87%E6%97%B6%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.2.7.</span> <span class="nav-text">过时方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">1.1.3.</span> <span class="nav-text">共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">竞态条件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">内存可见性</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%E5%8F%8A%E6%88%90%E6%9C%AC"><span class="nav-number">1.1.4.</span> <span class="nav-text">线程的优点及成本</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%90%86%E8%A7%A3-synchronized"><span class="nav-number">1.2.</span> <span class="nav-text">理解 synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%B3%95"><span class="nav-number">1.2.1.</span> <span class="nav-text">用法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">实例方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">代码块</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6"><span class="nav-number">1.2.2.</span> <span class="nav-text">进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">可重入性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7-1"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">内存可见性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">死锁</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8"><span class="nav-number">1.2.3.</span> <span class="nav-text">同步容器</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">复合操作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BC%AA%E5%90%8C%E6%AD%A5"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">伪同步</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">迭代</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="nav-number">1.2.4.</span> <span class="nav-text">并发容器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%8F%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="nav-number">1.3.</span> <span class="nav-text">线程的基本协作机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#wait-notify"><span class="nav-number">1.3.1.</span> <span class="nav-text">wait&#x2F;notify</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-number">1.3.2.</span> <span class="nav-text">生产者与消费者</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8C%E6%97%B6%E5%BC%80%E5%A7%8B"><span class="nav-number">1.3.3.</span> <span class="nav-text">同时开始</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E7%BB%93%E6%9D%9F"><span class="nav-number">1.3.4.</span> <span class="nav-text">等待结束</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E7%BB%93%E6%9E%9C"><span class="nav-number">1.3.5.</span> <span class="nav-text">异步结果</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%82%B9"><span class="nav-number">1.3.6.</span> <span class="nav-text">集合点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD"><span class="nav-number">1.4.</span> <span class="nav-text">线程中断</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.4.1.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.4.2.</span> <span class="nav-text">关闭线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AF%B9%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8F%8D%E5%BA%94"><span class="nav-number">1.4.3.</span> <span class="nav-text">线程对中断的反应</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#RUNNABLE"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">RUNNABLE</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#WAITING-TIMED-WAITING"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">WAITING&#x2F;TIMED_WAITING</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#BLOCKED"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">BLOCKED</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#NEW-TERMINATE"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">NEW&#x2F;TERMINATE</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.4.</span> <span class="nav-text">正确方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%8C%85%E7%9A%84%E5%9F%BA%E7%9F%B3"><span class="nav-number">2.</span> <span class="nav-text">并发包的基石</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E4%B8%8ECAS"><span class="nav-number">2.1.</span> <span class="nav-text">原子变量与CAS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E9%94%81"><span class="nav-number">2.2.</span> <span class="nav-text">显式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Lock-%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.2.1.</span> <span class="nav-text">Lock 接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ReentrantLock-%E7%B1%BB"><span class="nav-number">2.2.2.</span> <span class="nav-text">ReentrantLock 类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#tryLock-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">tryLock 避免死锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">实现原理</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E6%9D%A1%E4%BB%B6"><span class="nav-number">2.2.3.</span> <span class="nav-text">显式条件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%A8%E6%B3%95-1"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">用法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85-1"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">生产者与消费者</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">实现原理</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lu Yan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
