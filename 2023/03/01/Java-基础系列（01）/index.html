<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java,后端," />










<meta name="description" content="数据类型Java 语言有以下 4 类基本数据类型：  整数类型：有 4 种整型byte&#x2F;short&#x2F;int&#x2F;long，分别有不同的取值范围。 小数类型：有 2 种小数类型float&#x2F;double，分别有不同的取值范围和精度。 字符类型：char类型，表示单个字符。 真假类型：boolean类型，表示逻辑真假。  整数类型整数类型有byte&#x2F;short&#x2F;int&#x2F;long四种，它们分别占据1&#x2F;2&#x2F;4&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 基础系列（01）">
<meta property="og:url" content="http://example.com/2023/03/01/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8801%EF%BC%89/index.html">
<meta property="og:site_name" content="Luyan&#39;s Bolg">
<meta property="og:description" content="数据类型Java 语言有以下 4 类基本数据类型：  整数类型：有 4 种整型byte&#x2F;short&#x2F;int&#x2F;long，分别有不同的取值范围。 小数类型：有 2 种小数类型float&#x2F;double，分别有不同的取值范围和精度。 字符类型：char类型，表示单个字符。 真假类型：boolean类型，表示逻辑真假。  整数类型整数类型有byte&#x2F;short&#x2F;int&#x2F;long四种，它们分别占据1&#x2F;2&#x2F;4&#x2F;">
<meta property="og:locale">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1700636984479-6a588a7d-af3a-4039-831a-e8c5772b152e.png#averageHue=%23dadada&clientId=u90079b71-4238-4&from=paste&height=180&id=qaRRS&originHeight=276&originWidth=477&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40086&status=done&style=none&taskId=ua4da6d58-8719-4966-b26e-688a27aa73d&title=&width=311">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1700637006893-2f02fed0-a984-4ea0-bffd-630044622d15.png#averageHue=%23dcdcdc&clientId=u90079b71-4238-4&from=paste&height=180&id=kewYY&originHeight=371&originWidth=839&originalType=binary&ratio=1&rotation=0&showTitle=false&size=92803&status=done&style=none&taskId=ua19f37a1-61d4-49e8-aaf0-c2681e2985e&title=&width=407">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1700639527392-2eba7830-b0e6-4225-b554-d8d4e1f5b74a.png#averageHue=%23dddddd&clientId=u90079b71-4238-4&from=paste&height=384&id=u2363e7eb&originHeight=384&originWidth=929&originalType=binary&ratio=1&rotation=0&showTitle=false&size=115196&status=done&style=none&taskId=ua88f2d83-9f41-434b-b511-5a1d8237581&title=&width=929">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1700813123098-078b449d-6d3b-4211-b8ee-564dc3674872.png#averageHue=%23e0e0e0&clientId=u8b1ac003-cd14-4&from=paste&height=361&id=ub5a188b8&originHeight=361&originWidth=597&originalType=binary&ratio=1&rotation=0&showTitle=false&size=131669&status=done&style=none&taskId=uf31e57e7-aacf-4ab3-a2de-725ddf7b067&title=&width=597">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1700896542735-e50850b5-008b-46a1-a96a-6cc55d169d37.png#averageHue=%23e5e5e5&clientId=u1a25505d-4922-4&from=paste&height=663&id=u4e3fa6a9&originHeight=663&originWidth=947&originalType=binary&ratio=1&rotation=0&showTitle=false&size=166370&status=done&style=none&taskId=u391ac8cf-d7f9-48cd-a758-c3006d38ffe&title=&width=947">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1700899733595-00ab9137-f4b0-499f-a76c-0099e4406e77.png#averageHue=%23f0f0f0&clientId=u1a25505d-4922-4&from=paste&height=633&id=u2f9854ea&originHeight=633&originWidth=967&originalType=binary&ratio=1&rotation=0&showTitle=false&size=170717&status=done&style=none&taskId=uc61da8c8-e844-4414-9374-101c6b6645d&title=&width=967">
<meta property="article:published_time" content="2023-03-01T03:59:52.000Z">
<meta property="article:modified_time" content="2024-08-02T04:17:34.961Z">
<meta property="article:author" content="Lu Yan">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="后端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1700636984479-6a588a7d-af3a-4039-831a-e8c5772b152e.png#averageHue=%23dadada&clientId=u90079b71-4238-4&from=paste&height=180&id=qaRRS&originHeight=276&originWidth=477&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40086&status=done&style=none&taskId=ua4da6d58-8719-4966-b26e-688a27aa73d&title=&width=311">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2023/03/01/Java-基础系列（01）/"/>





  <title>Java 基础系列（01） | Luyan's Bolg</title>
  








<meta name="generator" content="Hexo 7.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Luyan's Bolg</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不积跬步，无以至千里；不积小流，无以成江海。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/index.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/01/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8801%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java 基础系列（01）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-03-01T11:59:52+08:00">
                2023-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Java 语言有以下 4 类基本数据类型：</p>
<ol>
<li>整数类型：有 4 种整型<code>byte/short/int/long</code>，分别有不同的取值范围。</li>
<li>小数类型：有 2 种小数类型<code>float/double</code>，分别有不同的取值范围和精度。</li>
<li>字符类型：<code>char</code>类型，表示单个字符。</li>
<li>真假类型：<code>boolean</code>类型，表示逻辑真假。</li>
</ol>
<h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>整数类型有<code>byte/short/int/long</code>四种，它们分别占据<code>1/2/4/8</code>个字节，取值范围如下表所示：</p>
<table>
<thead>
<tr>
<th><strong>类型名</strong></th>
<th><strong>字节数</strong></th>
<th><strong>取值范围</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>byte</code></td>
<td>1</td>
<td>$-2^7\sim2^7-1$</td>
</tr>
<tr>
<td><code>short</code></td>
<td>2</td>
<td>$-2^{15}\sim2^{15}-1$</td>
</tr>
<tr>
<td><code>int</code></td>
<td>4</td>
<td>$-2^{31}\sim2^{31}-1$</td>
</tr>
<tr>
<td><code>long</code></td>
<td>8</td>
<td>$-2^{63}\sim2^{63}-1$</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">333</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">3232343433L</span>;</span><br></pre></td></tr></table></figure>
<p>给整数类型变量赋值直接使用<code>=</code>就好，有一点需要注意，当给<code>long</code>类型变量赋值时若常量的值超过了<code>int</code>的范围需要在后面加上字母<code>l</code>或<code>L</code>，因为整型常量的默认类型是<code>int</code>，会溢出。</p>
<h4 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h4><p>小数类型有<code>float/double</code>四种，它们分别占据<code>4/8</code>个字节，取值范围如下表所示：</p>
<table>
<thead>
<tr>
<th>类型名</th>
<th>字节数</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td><code>float</code></td>
<td>4</td>
<td>-3.4E+38<del>-1.4E-45 ∪ 1.4E-45</del>3.4E+38</td>
</tr>
<tr>
<td><code>double</code></td>
<td>8</td>
<td>-1.7E+308<del>-4.9E-324 ∪ 4.9E-324</del>1.7E+308</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">333.33</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">333.33F</span>;</span><br></pre></td></tr></table></figure>

<p>使用<code>=</code>直接给变量赋值，需要注意因为浮点数常量默认是<code>double</code>类型，所以给<code>float</code>类型赋值的时候若是常量越界了需要在后面加上<code>f</code>或<code>F</code>。</p>
<h4 id="真假类型"><a href="#真假类型" class="headerlink" title="真假类型"></a>真假类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">b = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>真假类型使用关键字<code>boolean</code>，我们直接使用<code>true</code>或<code>false</code>来赋值。</p>
<h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">z</span> <span class="operator">=</span> <span class="string">&#x27;学&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>字符类型使用<code>char</code>关键字，一个字符占 2 个字节，所以 Java 的字符变量里面即可以存英文字符也可以存中文字符。</p>
<h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>数组类型的三种初始化形式：</p>
<ol>
<li><code>int[] arr = &#123;1, 2, 3&#125;;``[]</code>表示数组类型，我们直接使用<code>&#123;&#125;</code>给初值。</li>
<li><code>int[] arr = new int[]&#123;1, 2, 3&#125;;</code>这种写法是上一种的完整版本。</li>
<li><code>int[] arr = new int[3];</code> 定义长度为 3 的整型数组，不给初值。</li>
</ol>
<p>前两种初值方法下，数组的长度由初值的个数决定，不能手动指定长度。最后一种方法只指定了数组长度，但并没有给初值，那么数组元素会有默认值：数字类型为 0，<code>boolean</code>类型为 false，字符类型为空字符。<br>和 C 不同，我们在定义数组的时候，数组长度可以使用变量指定：<code>int n = 10; int[] arr = new int[n];</code>。我们定义了一个数组，系统会为我们分配两段内存，一块是数组空间（存储数组元素的地方），一块是数组名所对应的空间（存储着数组空间的首地址）。所以本质上说，数组名存储的就是数组空间的首地址，也就是说我只要改变这个地址就可以让数组名指向另一段数组空间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> [] b = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">a = b;</span><br></pre></td></tr></table></figure>
<p>使用<code>a = b</code>将<code>a</code>指向<code>b</code>的数组空间即<code>&#123;4, 5, 6, 7&#125;</code>，也就是说此时<code>a</code>与<code>b</code>的指向是一样。而原来<code>a</code>的数组空间要是没人引用就会被垃圾回收。<br>因此我们可以发现，一个数组名可以指向各种各样长度的数组空间。</p>
<h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><p>Java 里面算术运算包含<code>+, -, *, /, %</code>，除此之外也有<code>++, --</code>。和 C 类似：</p>
<ol>
<li><code>/</code>在整数之间表示整除（向 0 取整、舍弃小数位），有浮点数参与运算的时候才会表示精确除法。</li>
<li><code>%</code>只能用在整型或字符型之间，即小数不能进行除法。</li>
<li><code>++, --</code>可以用在变量的前面或后面，主要体现在返回值不同。<code>++</code>在前就先<code>+1</code>再返回；<code>++</code>在后就先返回再<code>+1</code>。</li>
</ol>
<p>一些运算的注意事项：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果太大了，int 无法存下</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2147483647</span> * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// long 可以存下，但下面代码还是不对</span></span><br><span class="line"><span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2147483647</span> * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面才是正确的写法</span></span><br><span class="line"><span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2147483647</span> * <span class="number">2L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了避免整除，我们使用浮点操作数</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">4.0</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>给变量赋值的时候不应该越界存储。</li>
<li>如左边第二种情况，变量类型<code>long</code>可以存下运算结果，但最终结果仍然不对。因为右边两个操作数全是<code>int</code>，所以计算的时候会将结果当做<code>int</code>，这个时候结果已经越界了，所以赋值给变量 a 的结果是越界后的结果。</li>
<li>因此我们使用<code>2L</code>作为操作数，这样结果就是<code>long</code>类型了。</li>
</ol>
<h4 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h4><p>Java 里比较运算包括<code>&gt;, &gt;=, &lt;, &lt;=, ==, !=</code>，所有数值和字符之间的比较规则和 C 是一样的。<br>数组类型进行比较，比较的当然是两者存储的地址。只有当两个数组变量指向同一块数组空间的时候才会返回<code>true</code>，否则都是返回<code>false</code>。想要比较两个数组存储的元素是否全都一样只能使用循环自行比较。<br>所有的比较运算返回值类型都是<code>boolean</code>，和 C 不一样的是 Java 只能使用<code>true</code>和<code>false</code>表示真假，不能使用数字。</p>
<h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>逻辑运算的运算对象只能是<code>boolean</code>类型，结果也是<code>boolean</code>类型。Java 的逻辑运算符有：</p>
<ol>
<li>与<code>&amp;</code>：有假则假，不会短路。</li>
<li>或<code>|</code>：有真则真，不会短路。</li>
<li>非<code>!</code>：真假取反。</li>
<li>异或<code>^</code>：两者不同为<code>true</code>，两种相同为<code>false</code>。</li>
<li>短路与<code>&amp;&amp;</code>：有假则假，会短路。</li>
<li>短路或<code>||</code>：有真则真，会短路。</li>
</ol>
<h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><h4 id="if分支"><a href="#if分支" class="headerlink" title="if分支"></a><code>if</code>分支</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件<span class="number">1</span>) &#123;</span><br><span class="line">    语句块<span class="number">1</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件<span class="number">2</span>) &#123;</span><br><span class="line">    语句块<span class="number">2</span></span><br><span class="line">&#125; </span><br><span class="line">... </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    语句块n    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>n 个分支的<code>if</code>选择结构执行流程：</p>
<ol>
<li>自上而下判断条件，若判定为真则执行对应的语句块，整个流程结束。</li>
<li>若没有条件为真，则执行<code>else</code>代码块内容。</li>
<li><code>else if</code>和<code>else</code>块可以省略掉。</li>
<li>语句块里只有一条语句的时候，可以省略大括号（不建议）。</li>
</ol>
<p>对于简单的<code>if else</code>条件分支可以使用<code>?:</code>运算符来简写：<code>逻辑表达式 ? 表达式1: 表达式2</code>。这边逻辑表达式为真时会执行表达式1，否则执行表达式2。</p>
<h4 id="switch分支"><a href="#switch分支" class="headerlink" title="switch分支"></a><code>switch</code>分支</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        代码块<span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>, 值<span class="number">3</span>:</span><br><span class="line">        代码块<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> 值n-<span class="number">1</span>:</span><br><span class="line">        代码块n-<span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        代码块n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>n 个分支的<code>switch</code>选择结构执行流程：</p>
<ol>
<li>表达式的类型须为：byte、short、int、char、枚举和 String。</li>
<li>找到值与表达式值相同的<code>case</code>，执行这个<code>case</code>及之后的所有<code>case</code>。</li>
<li>没有匹配的就执行<code>default</code>及其后面所有<code>case</code>。</li>
<li>多个<code>case</code>对应同一个代码块的时候，可以合并成一个<code>case</code>，后面多个值使用逗号隔开。</li>
<li>可以使用<code>break</code>提前退出。</li>
</ol>
<p>一般来说使用<code>switch</code>效率比<code>if</code>要高，因为<code>if</code>条件是从上到下一一进行判断，而<code>switch</code>使用跳跃表能够减少判定的次数。每一种<code>case</code>都是一个整数，<code>String</code>会被哈希成整数，我们会创建一个数组将所有的<code>case</code>值排序后存进去，然后查找的时候使用二分查找提高查找效率。如果<code>case</code>值是连续的或者近似连续的，那么优化后直接根据下标查找更快。</p>
<h4 id="增强switch"><a href="#增强switch" class="headerlink" title="增强switch"></a>增强<code>switch</code></h4><p>传统<code>switch</code>具有穿透性质，每次都要使用<code>break</code>很不方便。增强的<code>switch</code>使用函数式编程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="keyword">switch</span> (dayOfWeek) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> -&gt; <span class="string">&quot;星期一&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span> -&gt; <span class="string">&quot;星期二&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span> -&gt; <span class="string">&quot;星期三&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span> -&gt; <span class="string">&quot;星期四&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span> -&gt; <span class="string">&quot;星期五&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span> -&gt; <span class="string">&quot;星期六&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span> -&gt; <span class="string">&quot;星期七&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(name);</span><br></pre></td></tr></table></figure>

<ol>
<li>每一个<code>case</code>后面使用箭头，箭头后面使用一条语句或一个语句块。</li>
<li>增强的<code>switch</code>可以作为一个语句存在，此时它有返回值，可以定义变量接受。</li>
<li>增强<code>switch</code>没有穿透特性，对应分支执行完之后直接退出<code>switch</code>。</li>
</ol>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>Java 有四种循环，分别是<code>while</code>、<code>do...while</code>、<code>for</code>和<code>foreach</code>循环。前面三种和 C 是类似的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; nums.length) &#123;</span><br><span class="line">    System.out.println(nums[i++]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(nums[i++]);</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; nums.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// for 循环初始化表达式部分可以定义循环变量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">    System.out.println(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们需要遍历数组或集合元素的时候，往往使用<code>foreach</code>循环更简洁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>foreach</code>并不是关键字。</li>
<li>冒号前面的变量每次能取到一个元素直到所有元素都遍历结束。</li>
<li>冒号前面的变量必须在里面定义。</li>
</ol>
<p>除了循环外，Java 也支持<code>continue</code>和<code>break</code>进行循环控制。<code>break</code>表示直接退出循环，<code>continue</code>表示跳过本轮循环。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p>Java 函数要放在类里面，没有面向过程编程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类，类名随意</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// Java 的入口函数 main</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 函数调用。我们可以定义和函数名一样的变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的函数 sum，public static 是修饰符，其余和 C 一样</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数组参数"><a href="#数组参数" class="headerlink" title="数组参数"></a>数组参数</h4><p>函数的参数可以是一个数组，数组传递的时候传的是什么呢？很显然，数组名里面装的是什么就传什么，因此参数传递的是数组空间的首地址，从而在函数内部修改数组元素，外部是可见的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] sum = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    change(sum);</span><br><span class="line">    <span class="comment">// 输出 9</span></span><br><span class="line">    System.out.println(sum[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    nums[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h4><p>除此之外，Java 还支持可变长参数，可变长参数的语法是在参数类型后面加<code>...</code>。一个函数最多只能有一个可变长参数，且只能放在参数列表的末尾。实际上，会把可变长参数转变为一个数组，因此在函数内使用可变长参数和使用数组没有区别。使用可变长参数主要能简化代码书写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b 是可变长参数，在函数里面的使用和普通数组没区别，其实本质上就是数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>... b)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : b) a = n &gt; a ? n : a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数，相当于调用了 max(3, new int[]&#123;1, 2, 4&#125;)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> max(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>Java 也是使用<code>return</code>关键字返回，返回值的类型需和函数类型一致，最多可以低精度转高精度，不会高精度转低精度。也就是说，函数类型是<code>int</code>，返回值类型是<code>double</code>是会报错的。函数内部可以有多个<code>return</code>，返回类型是<code>void</code>的也可以使用<code>return;</code>直接返回。<br>函数的返回值最多只有一个，但有时候我们需要返回多个值怎么办？例如传进去一个数组，返回数组里面最大值和最小值。</p>
<ol>
<li>一种是使用成员变量返回（类似于 C 的全局变量）。</li>
<li>另一种方案是在函数内部创建一个数组，将要返回的值放到数组里面然后返回。</li>
</ol>
<p>第二种方案要求变量的类型是一致的，而且和 C 不同的是函数内部创建的数组在退出函数的时候只会销毁数组名的空间，而数组空间不会销毁（没人引用会被垃圾回收），因此直接返回数组空间地址是可以的。<br>对于复杂的数据类型，我们可以创建类对象来返回。</p>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>Java 一个类中可以有多个同名的函数，但是这些函数的参数不能完全一致，要么至少一个参数类型有不同，要么参数数量不同。如下 Java 的Math 库里面就定义了下面 4 个求最大值函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">max</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">max</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span></span><br></pre></td></tr></table></figure>
<p>在函数重载的情况下，我调用这个函数，那么会匹配到哪一个呢？<br>答：会匹配到最接近的。例如我调用上面求最大值函数，参数是两个<code>char</code>，那么会优先匹配到参数是<code>int</code>的函数，其次是<code>long</code>、<code>float</code>、<code>double</code>。注意，匹配到时候只会上升精度匹配，不可能降低精度匹配。也就是说函数参数类型是<code>int</code>，实参是<code>double</code>将会无法匹配。说到底，就是系统不会做将高精度转低精度的强转，但这样的强转我们可以手动做<code>(int) 3.14</code>。</p>
<h4 id="函数执行原理"><a href="#函数执行原理" class="headerlink" title="函数执行原理"></a>函数执行原理</h4><p>程序从<code>main</code>函数开始执行，遇到函数调用就跳转到被调函数的代码处继续执行，执行完毕后重新回到主调函数的下一条语句处执行。在这个过程中，有以下几个问题：</p>
<ol>
<li>函数调用的参数是怎么传递的？</li>
<li>被调函数是如何知道执行完毕之后该回到哪里去的？</li>
<li>被调函数通过<code>return</code>返回值是怎么给到主调函数的？</li>
</ol>
<p>我们首先要知道计算机里面存储分为：栈、堆、返回值存储区（这个区域比较复杂，我们暂且认为就是一块存储返回值的内存）。栈里面主要存储函数里面定义的局部变量、形参等，堆主要存储数组空间以及对象空间（对象和数组类似将内存分两个部分，一个是变量名存储对象空间所在地址，一个就是对象空间存储对象里面的数据内容），返回值存储区临时存储函数的返回值。<br>我们使用一个例子感受一下函数调用时栈的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> Main.sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个简单的例子，我们下面阐述一下流程：</p>
<ol>
<li>主函数执行函数<code>sum</code>之前会为形参<code>args</code>和局部变量<code>d</code>在栈里分配内存，如图1-1。</li>
<li>函数<code>sum</code>被执行期间，先为形参<code>a</code>和<code>b</code>在栈里分配内存。</li>
<li>紧接着就是将主调函数的下一条指令地址存进栈里，然后为局部变量<code>c</code>分配内存并计算结果存进去。</li>
<li>遇到<code>return</code>语句，先将返回内容<code>c</code>的值存进返回值存储区，整个栈图如图1-2。</li>
<li>被调函数的内容全部出栈（销毁），然后根据指令地址转到主调函数，从返回值存储区读取返回值赋值给变量<code>d</code>。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1700636984479-6a588a7d-af3a-4039-831a-e8c5772b152e.png#averageHue=%23dadada&clientId=u90079b71-4238-4&from=paste&height=180&id=qaRRS&originHeight=276&originWidth=477&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40086&status=done&style=none&taskId=ua4da6d58-8719-4966-b26e-688a27aa73d&title=&width=311" alt="image.png"><br>图1-1<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1700637006893-2f02fed0-a984-4ea0-bffd-630044622d15.png#averageHue=%23dcdcdc&clientId=u90079b71-4238-4&from=paste&height=180&id=kewYY&originHeight=371&originWidth=839&originalType=binary&ratio=1&rotation=0&showTitle=false&size=92803&status=done&style=none&taskId=ua19f37a1-61d4-49e8-aaf0-c2681e2985e&title=&width=407" alt="image.png"><br>图1-2<br>从流程我们发现，对于返回值我们会将其存到一个专门的地方，然后给到主调函数。这样做是因为变量<code>c</code>在函数结束的时候就被销毁掉了，没办法取值，所以找了一个中间商。<br>这样就会产生一个问题：我们知道异常处理的时候<code>finally</code>块一定会执行。假设有<code>c = 1</code>，函数里面有<code>return c;</code>，又在<code>finally</code>里面执行了<code>c++;</code>那么最终返回结果是什么？<br>答：返回 <strong>1</strong>，因为遇到<code>return</code>的时候会将<code>c</code>变量的值备份到返回值存储区，接着执行<code>c++</code>影响不到返回值。<br>当我们将数组作为参数的时候，传递数组空间的首地址。看下面的案例（对应栈图1-3）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> min;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a: arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &gt; max) max = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> []arr = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> max(<span class="number">0</span>, arr);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1700639527392-2eba7830-b0e6-4225-b554-d8d4e1f5b74a.png#averageHue=%23dddddd&clientId=u90079b71-4238-4&from=paste&height=384&id=u2363e7eb&originHeight=384&originWidth=929&originalType=binary&ratio=1&rotation=0&showTitle=false&size=115196&status=done&style=none&taskId=ua88f2d83-9f41-434b-b511-5a1d8237581&title=&width=929" alt="image.png"><br>图1-3<br>最后提一句，函数栈的存储是从高位往低位存储的，即栈底在高位的内存，栈顶在低位内存（简记为从右到左存储）。</p>
<h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p>Java 整数有<code>byte/short/int/long</code>四种，这 4 种整数的性质完全一样，只是可表示范围不一样，我们使用<code>byte</code>举例子。一个<code>byte</code>有 8 位，每位有<code>0</code>和<code>1</code>两种取值，其中最高位（最左边位）表示符号位，取值<code>1</code>表负数，取值<code>0</code>表正数。</p>
<ol>
<li>正数使用原码表示法，即二进制正数$0i_1i_2i_3i_4i_5i_6i_7$与以下十进制数是等价的：</li>
</ol>
<p>$i_7\times2^0+i_6\times2^1+i_5\times2^2+i_4\times2^3+i_3\times2^4+i_2\times2^5+i_1\times2^6$<br>例如：<code>0111</code>表示十进制数<code>7</code>，<code>010</code>表示十进制数<code>2</code>。</p>
<ol start="2">
<li>负数使用补码表示法，即先得出对应的正数的原码，接着对原码所有位取反，最后再<code>+1</code>。</li>
</ol>
<p>这样做的原因也很简单，我们知道相对的两个正数、负数之和为<code>0</code>。我们得出正数的原码，那什么数与之相加和为<code>0</code>呢？先对原码取反（0 变 1，1 变 0），这样两者之和所有位全部是<code>1</code>，在此基础上只要再<code>+1</code>就会变成全<code>0</code>。因此正数对应的负数是对原码<code>取反再+1</code>，那么同样的逻辑负数想变成对应的正数也做一样的操作<code>取反再+1</code>。<br>于是很经典的一幕来了：<code>127 + 1 = -128</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>  --&gt; <span class="number">01111111</span></span><br><span class="line"><span class="number">1</span>    --&gt; <span class="number">00000001</span></span><br><span class="line">+ ----------------</span><br><span class="line">-<span class="number">128</span> --&gt; <span class="number">10000000</span></span><br></pre></td></tr></table></figure>
<p>不难看出，最大的正数加一之后会变成最小的负数。闭环了有没有？<br>除了二进制，比较常用的进制还有十六进制。二进制转十六进制很简单，直接 4 位一组转成十六进制即可。例如<code>-128 = 0b10000000 = 0x80</code>，其中<code>0b &lt;=&gt; 0B</code>表示二进制常量的前缀，<code>0x &lt;=&gt; 0X</code>是十六进制常量的前缀。在 Java 里面我们可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String Integer.toBinaryString(int a)  // int 转二进制字符串</span><br><span class="line">String Integer.toHexString(int a)  // int 转十六进制字符串</span><br><span class="line">String Long.toBinaryString(long a)  // long 转二进制字符串</span><br><span class="line">String Long.toHexString(long a)  // long 转十六进制字符串</span><br></pre></td></tr></table></figure>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>位运算有移位运算和逻辑运算，分别见下面：</p>
<ol>
<li><code>&amp;</code>按位与 AND，有 0 则 0。</li>
<li><code>|</code>按位或 OR，有 1 则 1。</li>
<li><code>~</code>表示按位取反，0 变 1，1 变 0。</li>
<li><code>^</code>表示异或，两者不一样的为 1，否则为 0。</li>
<li><code>&gt;&gt;&gt;</code>无符号右移，使用 0 填补左边空位。</li>
<li><code>&gt;&gt;</code>有符号右移，使用符号位填补左边空位，算术上<code>x&gt;&gt;n</code>等价于$\frac{x}{2^n}$，这边的除法表示整除。</li>
<li><code>&lt;&lt;</code>左移，左移时用 0 填补右边空位，算术上<code>x&lt;&lt;n</code>等价于$x\times2^n$。</li>
</ol>
<p>下面程序展示了使用<code>byte</code>作为位集的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整数转二进制输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printb</span><span class="params">(<span class="type">int</span> b)</span> &#123;</span><br><span class="line">	System.out.println(Integer.toBinaryString(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">1</span> | <span class="number">1</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">1</span> | <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    printb(x);  <span class="comment">// &quot;00100010&quot; 集合 &#123;1, 5&#125;</span></span><br><span class="line">    printb(y);  <span class="comment">// &quot;00000110&quot; 集合 &#123;1, 2&#125;</span></span><br><span class="line">    printb(~x);  <span class="comment">// &quot;11011101&quot; 取补集 1 - x = &#123;0, 2, 3, 4, 6, 7&#125;</span></span><br><span class="line">    printb(x &amp; y);  <span class="comment">// &quot;00000010&quot; 取交集 x ∩ y = &#123;1&#125;</span></span><br><span class="line">    printb(x | y);  <span class="comment">// &quot;00100110&quot; 取并集 x ∪ y = &#123;1, 2, 5&#125;</span></span><br><span class="line">    printb(x ^ y);  <span class="comment">// &quot;00100100&quot; 取对称差 x + y - xy = &#123;2, 5&#125;</span></span><br><span class="line">    printb(x &amp; ~y);  <span class="comment">// &quot;00100000&quot; 取差集 x - y = &#123;5&#125;</span></span><br><span class="line">    printb(x &lt;&lt; <span class="number">1</span>);  <span class="comment">// &quot;01000100&quot; 集合 &#123;2, 6&#125;</span></span><br><span class="line">    printb(x &gt;&gt;&gt; <span class="number">1</span>);  <span class="comment">// &quot;00010001&quot; 集合 &#123;0, 4&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 x 哪些位是 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((x &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>)</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d&quot;</span>, i);  <span class="comment">// 15</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h4><p>浮点数在计算机的存储是按照科学记数法存储的，只不过底数为 2。也就是所有浮点数都会转为$m\times2^e$的形式，这边 m 称为尾数，e 称为指数。很多小数没法表示成这样的写法，所以会导致结果不精确。<br>了解了浮点数在内存的存储形式，那么具体存储方案是什么呢？</p>
<ol>
<li>对于 32 位浮点数（float），1 位表示正负，23 位表示尾数，8 位表示指数。</li>
<li>对于 64 位浮点数（double），1 位表示正负，52 位表示尾数，11 位表示指数。</li>
</ol>
<h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><p>字符使用<code>char</code>关键字，本质上<code>char</code>就是占据两个字节的无符号正整数。这个正整数对应<code>Unicode</code>编码，这是兼容<code>ASCII</code>编码的。因为两个字节能表示只有 65536 以内的字符，所以编码超出的字符需要其它方式表示。不过好在大多数常用汉字在表示的范围内。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;卢&#x27;</span>;  <span class="comment">// 直接赋值字符常量</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">21346</span>;  <span class="comment">// 使用十进制编码赋值</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0x5362</span>;  <span class="comment">// 使用十六进制编码赋值</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;\u5362&#x27;</span>;  <span class="comment">// 使用 Unicode 方式赋值</span></span><br></pre></td></tr></table></figure>
<h3 id="类基础"><a href="#类基础" class="headerlink" title="类基础"></a>类基础</h3><p>我们将类看做自定义数据类型，类由属性和操作（方法）两部分组成。其中属性分为类属性和实例属性，方法分为类方法和实例方法。因此数据类型由下面四个部分组成：</p>
<ol>
<li>类型本身具备的属性，通过类变量体现。</li>
<li>类型本身可以进行的操作，通过类方法体现。</li>
<li>类型实例具备的属性，通过实例变量体现。</li>
<li>类型实例可以进行的操作，通过实例方法体现。</li>
</ol>
<p>类变量和实例变量可以统称为成员变量，类方法和实例方法可以统称为成员方法。类变量可以称为静态变量，类方法还可以称为静态方法。</p>
<h4 id="变量、方法"><a href="#变量、方法" class="headerlink" title="变量、方法"></a>变量、方法</h4><p><strong>类方法</strong>就是在定义的时候加上<code>static</code>关键字修饰的方法，这样的方法别人可以直接使用<code>类名.方法名()</code>的形式调用。<br><strong>类变量</strong>主要描述类型本身具备的属性，一般用来定义类型中的常量。例如<code>Math</code>类里面就定义了一个常量<code>PI</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.141592653589793</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>public</code>修饰符表示这个变量是公开的，所有人都可以访问。</li>
<li><code>static</code>修饰符表示这是一个静态变量，别人可以通过<code>类名.变量名</code>的方式访问。</li>
<li><code>final</code>修饰符表示这是一个常量，无法修改。</li>
</ul>
<p><strong>实例变量</strong>表示具体实例具有的变量，<strong>实例方法</strong>表示具体实例可以进行的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(x * x + y * y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是一个简单的类的例子，定义了一个名叫<code>Point</code>的类。类里定义了两个实例变量<code>x</code>和<code>y</code>，还定义了一个实例方法<code>distance</code>，这个方法计算并返回该点到原点的距离。可以发现在实例方法里面可以直接使用实例变量。实际上：</p>
<ul>
<li>静态方法里面只能调用调用方法，只能访问静态变量。</li>
<li>实例方法里面没有要求，既可以访问实例变量和方法，也可以访问静态变量和方法。</li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>下面我们简单使用一下定义的<code>Point</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>();  <span class="comment">// 创建 Point 类的对象 p</span></span><br><span class="line">p.x = <span class="number">1</span>;  <span class="comment">// 给实例变量 x 赋值</span></span><br><span class="line">p.y = <span class="number">2</span>;  <span class="comment">// 给实例变量 y 赋值</span></span><br><span class="line">System.out.println(p.distance());  <span class="comment">// 调用实例方法</span></span><br></pre></td></tr></table></figure>
<p>这个例子比较简单，但是有一点。对象的创建和数组定义类似，变量名<code>p</code>里面存储着对象空间的地址，默认为<code>null</code>，代码里面我们通过<code>new Point()</code>分配对象空间并将地址赋给变量<code>p</code>。注意，所有的成员变量没有初值都会给默认的初值，数值类型初值都是 0，<code>boolean</code>类型默认初值是 false，<code>char</code>类型默认初值也是 0。<br><strong>Tip：</strong>实例变量一般不设为<code>public</code>，即我们一般不允许直接访问这个实例变量。而是使用<code>private</code>修饰实例变量，然后提供对应的<code>getter</code>和<code>setter</code>。这样做的好处是能够有效避免异常值的出现。举个例子，实例变量的含义是考试成绩，如果赋值<code>-1</code>进去怎么办？</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>我们说所有成员变量都会有一个默认的初值，但如果我想改变这个初值怎么办？<br><strong>对于实例变量</strong>，可以直接在定义的时候给初值或者使用代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 定义变量的时候直接赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">&#123;  <span class="comment">// 使用代码块进行实例变量的初始化</span></span><br><span class="line">    y = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于实例变量的初始化，有以下注意点：</p>
<ol>
<li>不论是直接赋值还是使用代码块赋值都可以使用方法返回值来给变量赋值，所有成员方法均可调用。</li>
<li>实例变量的初始化在每一个对象创建时、构造方法执行前进行的。</li>
<li>代码块初始化的好处是能够应付比较复杂的初值情况，比如涉及条件判断等情况。</li>
</ol>
<p><strong>对于静态变量</strong>，可以直接定义的时候指定或使用静态代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 定义变量的时候直接赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> v2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;  <span class="comment">// 使用静态代码块初始化</span></span><br><span class="line">    v2 = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于静态变量的初始化，有以下注意点：</p>
<ol>
<li>给静态变量初始化调用方法只能调用静态方法，因为此时实例方法还没加载。</li>
<li>静态变量初始化于类加载的时候，这早于任何对象的创建，且只会执行一次。</li>
<li>静态代码块里面可以书写复杂的初始化逻辑，但是不能使用实例变量，因为实例变量此时还没加载。</li>
</ol>
<p>问：普通初始化代码块里面能不能对静态变量初始化？<br>答：可以。只不过这样的初始化每次对象的创建都会执行，里面可以使用实例方法或实例变量给静态变量初始化，因为此时实例方法和变量都已经存在。</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>上面介绍了初始化成员变量的方法，其实还可以通过构造方法来做这个事情。我们使用<code>new</code>创建一个对象的时候需要做：1. 申请内存。2. 做实例变量的初始化操作，包括执行代码块的内容。3. 调用构造方法。<br>构造方法必须与类名相同，且不能有返回值类型，见下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Point</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 调用下面的构造方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参构造，参数没有要求，按需设立</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;  <span class="comment">// 给成员变量 x 赋值</span></span><br><span class="line">    <span class="built_in">this</span>.y = y;  <span class="comment">// 给成员变量 y 赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看以看出我们使用到了关键字<code>this</code>，它表示当前实例，有两个作用：</p>
<ol>
<li>调用其它构造方法，必须放在第一行。</li>
<li>获取成员变量，例子中存在局部变量<code>x</code>，所以直接访问<code>x</code>实际上是在访问局部变量。使用<code>this</code>表明要给成员变量<code>x</code>赋值。</li>
</ol>
<p>有了构造方法之后，我们可以在创建对象的时候可以直接使用<code>Point p = new Point(1, 2);</code>。<br>Java 有<strong>默认的构造方法</strong>，这个默认的构造方法里面什么都不做，也没有参数。但只有我们没有手动定义构造方法的时候这个默认构造才会存在，一旦我们定义了构造，那么默认构造就不存在了。基于此，若是我们自己定义的构造都是带参数的，那么创建对象的时候<code>new Point()</code>就会报错了，因为我们有自定义构造，所以默认无参构造就没有了，此时在这么调用就不对了。<br>构造方法不一定非要<code>public</code>，还可以定义<code>private</code>的构造方法，一般使用<strong>私有构造</strong>的场景：</p>
<ol>
<li>不允许创建类的实例，类只能被静态访问，例如<code>Math</code>类。</li>
<li>单例模式的类，不允许外人创建类的实例，实例只能通过本类的静态方法获取。当需要类实例的时候，调用对应静态方法获取，方法内会判断若实例已经创建就直接返回否则就创建并返回。</li>
<li>这个私有构造是专门给其它构造调用使用的，便于减少代码冗余。</li>
</ol>
<h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>为解决类命名冲突的问题，我们引入包的概念。包相当于一个路径，各部分使用<code>.</code>分隔。带有包路径的类名称为完全限定名。定义类的时候应该先使用<code>package</code>关键字声明报名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.luyan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包名要和文件目录结构匹配，假设源文件的根目录是<code>&lt;?&gt;/src</code>，那么类<code>Demo</code>的源文件路径应该是<code>&lt;?&gt;/src/com/luyan/Demo.java</code>。建议包名使用域名的反写，以避免包名冲突。<br>类之间引用有以下注意点：</p>
<ol>
<li>同一个包下的类可以直接使用。</li>
<li>想要使用的类在其它包下：<ol>
<li>使用完全限定名来使用这个类。</li>
<li>将要使用的类引入当前类，只有<code>java.lang</code>包是例外（不需要引入也可以使用）。</li>
</ol>
</li>
</ol>
<p>例如我想用<code>Arrays</code>类里面的<code>sort</code>方法，有以下两种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">java.util.Arrays.sort(arr);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line">Arrays.sort(arr);</span><br></pre></td></tr></table></figure>
<p>Java 使用<code>import</code>关键字来导包，导包的时候还可以使用<code>*</code>来导入包下的所有类：<code>import java.util.*;</code>表示导入<code>java.util</code>下面所有类。但是要注意这不会递归导包，也就是说<code>util</code>子包下面的类是无法导入的。Java 没办法同时导入两个同名的类，遇到这样的情况只能导入一个，另一个使用完全限定名。除此之外，Java 可以使用静态导入的方式导入类公开的静态方法和静态变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;  <span class="comment">// 导入静态变量 out</span></span><br><span class="line">out.println(<span class="string">&quot;Hello&quot;</span>);  <span class="comment">// 直接使用 out</span></span><br></pre></td></tr></table></figure>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性分为<code>public、private、默认（不写）、protected</code>，它们可见范围：</p>
<ol>
<li><code>public</code>表示所有人可以访问。</li>
<li><code>private</code>表示只有类内部可以访问。</li>
<li><code>默认</code>表示包内可访问，包外不可访问（包内指的是同一级目录，子包也不可访问）。</li>
<li><code>protected</code>表示包内或子类可访问。</li>
</ol>
<p>根据可见性小到大排序有：<code>private &lt; 默认 &lt; protected &lt; public</code>。</p>
<h4 id="jar-包"><a href="#jar-包" class="headerlink" title="jar 包"></a>jar 包</h4><p>导出<code>jar</code>包的时候导出的是字节码文件，而不是源文件。假设字节码文件的目录是<code>E:\bin\com\luyan\Demo.class</code>，那么导包步骤是：</p>
<ol>
<li>切换到<code>E:\bin</code>目录下。</li>
<li>运行指令<code>jar -cvf &lt;文件名&gt;.jar &lt;最上层包名&gt;</code>，这个例子就是<code>jar -cvf demo.jar com</code>。</li>
</ol>
<p>实际上<code>jar</code>包就是一个压缩包，我们完全可以解压缩看到里面的内容。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>自然界的类之间天然存在继承关系，例如动物类和狗类，狗属于动物，因此动物类是父类，狗类是子类。Java 里面也有继承的关系，父类又可以称为基类，子类又可以称为派生类。<br>之所以叫继承，是因为子类会继承父类的属性和行为，同时子类还可以拓展自己的属性和行为。使用继承有许多好处：</p>
<ol>
<li>不同子类的对象可以很方便的统一处理。</li>
<li>可以复用代码，许多公共的属性和行为可以放到父类里面，子类只需要关注自己特有的属性行为。</li>
</ol>
<h4 id="根父类"><a href="#根父类" class="headerlink" title="根父类"></a>根父类</h4><p>Java 里即使没有给类指明父类，其也会有一个隐含的父类<code>Object</code>，<code>Object</code>是所有类或直接或间接的父类。<code>Object</code>类没有定义属性，但是定义了一些方法：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1700813123098-078b449d-6d3b-4211-b8ee-564dc3674872.png#averageHue=%23e0e0e0&clientId=u8b1ac003-cd14-4&from=paste&height=361&id=ub5a188b8&originHeight=361&originWidth=597&originalType=binary&ratio=1&rotation=0&showTitle=false&size=131669&status=done&style=none&taskId=uf31e57e7-aacf-4ab3-a2de-725ddf7b067&title=&width=597" alt="image.png"><br>我们主要看看<code>toString()</code>方法，这个方法目的是返回对象的文本描述。一般情况下，直接打印对象的时候会默认打印这个函数的输出。这个方法的默认实现是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此默认情况下，打印一个对象打印出来的是类似于<code>com.luyan.Point@28a418fc</code>这样的字符串，字符串前半部分是类的完全限定名，后半部分是对象的哈希值（一般是对象的十六进制地址）。</p>
<h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>上面的<code>toString()</code>方法一般来说是不够用的，我们想要描述一个对象可能涉及到这个对象的一些属性。但是父类并不能提前知晓子类的属性，这个时候我们就可以在子类重写<code>toString()</code>方法以达到自定义的目的。下面的例子是<code>Point</code>类重写的<code>toString()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + x + <span class="string">&#x27;,&#x27;</span> + y + <span class="string">&quot;)&quot;</span>;  <span class="comment">// 按照格式返回横纵坐标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>@Override</code>表示这个方法是重写的父类的方法，不写也可以，但写一下真假可读性。</p>
<h4 id="图形类的继承体系"><a href="#图形类的继承体系" class="headerlink" title="图形类的继承体系"></a>图形类的继承体系</h4><p>我们接下来使用图形类来展示继承体系，首先我们打算设计“圆、线段、箭头”这三个图形类。</p>
<h5 id="Shape-类"><a href="#Shape-类" class="headerlink" title="Shape 类"></a>Shape 类</h5><p>这三个类都具有颜色这个属性，也都具有<code>draw</code>这个行为，那么我们就可以抽象一个父类<code>Shape</code>来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_COLOR</span> <span class="operator">=</span> <span class="string">&quot;black&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(DEFAULT_COLOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Draw Shape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类比较简单，实例变量<code>color</code>表示图形的颜色。类里定义了静态常量<code>DEFAULT_COLOR</code>表示默认颜色。定义<code>draw()</code>方法实现图形的绘制，这边就是简单的一句输出。</p>
<h5 id="Circle-类"><a href="#Circle-类" class="headerlink" title="Circle 类"></a>Circle 类</h5><p>接下来设计“圆”这个类，圆新增了圆心和半径两个属性，还新增了<code>area()</code>方法用来计算面积。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Point center;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(Point center, <span class="type">double</span> r)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.center = center;</span><br><span class="line">        <span class="built_in">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Draw Circle at %s with r %f, using color %s.&quot;</span>, </span><br><span class="line">                center, r, getColor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * r * r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Point <span class="title function_">getCenter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> center;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCenter</span><span class="params">(Point center)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.center = center;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getR</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setR</span><span class="params">(<span class="type">double</span> r)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类重写了父类<code>draw()</code>方法，并自定义一个求面积的方法。对于这个例子有以下几个注意点：</p>
<ol>
<li>Java 使用<code>extends</code>关键字表示继承，这边<code>Circle</code>继承于<code>Shape</code>。</li>
<li>子类不能直接访问父类私有的属性和方法，因此代码里使用<code>getColor()</code>方法获取图形的颜色。</li>
<li><code>new</code>的时候，在调用子类构造之前，一定会先调用父类的构造。如果没有明确写调用父类哪个构造，那么将会调用父类的无参构造，若这种情况下父类没有无参构造是会报错的。上面的例子，没有显式调用父类构造，所以默认调用了父类的无参构造，因此图形颜色是默认的<code>black</code>。</li>
</ol>
<h5 id="Line-类"><a href="#Line-类" class="headerlink" title="Line 类"></a>Line 类</h5><p>接下来我们设计“线段”类，这个类新增了两个端点以及一个计算长度的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Point start;</span><br><span class="line">    <span class="keyword">private</span> Point end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Line</span><span class="params">(Point start, Point end, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(color);</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">length</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> start.distance(end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Draw Line from %s to %s, using color %s.&quot;</span>, </span><br><span class="line">                start, end, getColor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Point <span class="title function_">getStart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStart</span><span class="params">(Point start)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Point <span class="title function_">getEnd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEnd</span><span class="params">(Point end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子主要出现了一个关键字<code>super</code>，这个关键字和<code>this</code>有些像，它的作用：</p>
<ol>
<li>通过<code>super</code>关键字指定调用父类的哪一个构造方法，必须放在构造的第一行。这个例子里面指定调用父类带参的构造。</li>
<li>使用<code>super</code>可以访问父类非私有的成员变量，这个主要当父类和子类有同名变量的时候用作区分。</li>
<li>使用<code>super</code>可以调用父类的非私有方法，这个用的比较多。因为子类在重写完父类某方法之后，调用的就是子类重写后的方法了，这时候想要调用原来的方法，可以使用<code>super</code>关键字。</li>
</ol>
<p><code>super</code>和<code>this</code>看起来是很像的，一个表示父类，一个表示自己。但是两者有很大的不同：</p>
<ul>
<li><code>this</code>引用一个对象，是实实在在的，是可以作为参数和返回值存在的。</li>
<li><code>super</code>只是一个关键字，并不能作为参数之类的存在，它的作用只是告诉编译器将要访问父类的相关属性方法。</li>
</ul>
<h5 id="ArrowLine-类"><a href="#ArrowLine-类" class="headerlink" title="ArrowLine 类"></a>ArrowLine 类</h5><p>接下来我们设计“箭头”类，箭头相比于线段多了两个表示是否存在两端箭头的属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrowLine</span> <span class="keyword">extends</span> <span class="title class_">Line</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> startArrow;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> endArrow;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrowLine</span><span class="params">(Point start, Point end, String color,</span></span><br><span class="line"><span class="params">                     <span class="type">boolean</span> startArrow, <span class="type">boolean</span> endArrow)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(start, end, color);</span><br><span class="line">        <span class="built_in">this</span>.startArrow = startArrow;</span><br><span class="line">        <span class="built_in">this</span>.endArrow = endArrow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.draw();</span><br><span class="line">        <span class="keyword">if</span> (startArrow)</span><br><span class="line">            System.out.println(<span class="string">&quot;Draw start arrow.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (endArrow)</span><br><span class="line">            System.out.println(<span class="string">&quot;Draw end arrow.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStartArrow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> startArrow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStartArrow</span><span class="params">(<span class="type">boolean</span> startArrow)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.startArrow = startArrow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEndArrow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> endArrow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEndArrow</span><span class="params">(<span class="type">boolean</span> endArrow)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.endArrow = endArrow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类实现有两个地方需要注意：</p>
<ol>
<li>因为其父类<code>Line</code>没有无参构造，所以在本类的构造方法里面需要显式调用父类的构造。</li>
<li><code>draw()</code>方法里面使用<code>super</code>关键字是因为想要调用父类的<code>draw</code>方法。</li>
</ol>
<h5 id="ShapeManager-类"><a href="#ShapeManager-类" class="headerlink" title="ShapeManager 类"></a>ShapeManager 类</h5><p>使用继承就是方便管理多个不同的子类，下面我们设计一个图形管理器，用于添加图形以及对维护的图形进行绘制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_NUM</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> Shape[] shapes = <span class="keyword">new</span> <span class="title class_">Shape</span>[MAX_NUM];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">shapeNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addShape</span><span class="params">(Shape shape)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (shapeNum &gt;= MAX_NUM) <span class="keyword">return</span>;</span><br><span class="line">        shapes[shapeNum++] = shape;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; shapeNum; ++i) &#123;</span><br><span class="line">            shapes[i].draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类主要维护一个<code>Shape</code>数组，具备添加图形和绘制所有图形的功能。</p>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ShapeManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapeManager</span>();</span><br><span class="line">    manager.addShape(<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">3</span>), <span class="number">1</span>));</span><br><span class="line">    manager.addShape(<span class="keyword">new</span> <span class="title class_">Line</span>(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">2</span>), <span class="string">&quot;green&quot;</span>));</span><br><span class="line">    manager.addShape(<span class="keyword">new</span> <span class="title class_">ArrowLine</span>(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">3</span>), <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">4</span>, <span class="number">5</span>), </span><br><span class="line">            <span class="string">&quot;red&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>));</span><br><span class="line">    manager.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面写了一段测试代码，创建了一个圆、一条直线和一个箭头。我们将这些图形添加到管理器里面并统一绘制出来。<br><code>Circle</code>明明表示圆，但是我们把它看做一个图形是没有问题的。因此使用<code>Shape</code>类型变量来引用圆对象是合理的，这个叫做<strong>向上转型</strong>。<code>Shape</code>类型的对象可以引用任意一个子类的对象，这叫做<strong>多态</strong>，即一种类型的变量可以实际引用多种类型的对象。对于一个变量<code>Shape shape;</code>来说，我们称<code>Shape</code>是它的<strong>静态类型</strong>，<code>Circle/Line/ArrowLine</code>是它的<strong>动态类型</strong>。我们使用<code>shape.draw()</code>调用的是动态类型的方法，这叫做<strong>动态绑定</strong>。</p>
<h4 id="继承的细节"><a href="#继承的细节" class="headerlink" title="继承的细节"></a>继承的细节</h4><h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><p>第一个问题之前提过，创建子类对象的时候，在调用子类构造之前会先调用父类构造。如果没有手动指定调用父类哪个构造，那么就会默认调用父类无参构造，若此时恰巧父类没有无参构造，那就会报错了。<br>第二个问题是在父类的构造函数里面调用可被重写的成员方法时可能遇到的问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span> &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">c.test();</span><br></pre></td></tr></table></figure>
<p>上面的代码运行会输出什么？<br>答：<code>0</code>和<code>123</code>。<br>下面主要谈谈为什么第一次输出<code>0</code>。</p>
<ol>
<li>首先父类的构造调用在子类之前，因此会在父类构造里面执行<code>test</code>函数。</li>
<li>因为是从子类上去的，所以将会执行子类的<code>test</code>函数，输出变量<code>a</code>的值。</li>
<li>此时子类的初始化还没开始，因此变量<code>a</code>的值为<code>0</code>，故而输出<code>0</code>。</li>
</ol>
<p>从这个例子可以看出，父类构造中调用能被子类重写的方法是不太好的。因此我们平时编程的时候建议只在父类构造里面调用私有方法，因为私有方法不能被重写。</p>
<h5 id="重名"><a href="#重名" class="headerlink" title="重名"></a>重名</h5><p>之前说过，子类能够重写父类非私有的实例方法，调用的时候会动态绑定，最终会执行子类的方法。那么对于实例变量、静态变量、静态方法而言，若是子类也有同名的变量方法，怎么执行？<br>首先，重名（子类和父类同时具有名字一样的属性或方法）是可以的。具体怎么执行分情况：</p>
<ol>
<li><p>私有的变量或方法。这种变量或方法只能在类内部进行访问，这种情况下当然各访问各的，子类访问子类的，父类访问父类的，互不影响。</p>
</li>
<li><p>非私有的变量或方法，这样变量或方法在类内或类外都可以访问：</p>
<ol>
<li>类内部访问，也是各访问各的，互不干扰。</li>
<li>类外部访问，静态类型是谁就访问谁的，看下面的代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;base&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;static_base&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;base_&quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;child&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;static_child&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;child_&quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> c;</span><br><span class="line">System.out.println(c.a);</span><br><span class="line">System.out.println(c.b);</span><br><span class="line">c.test();</span><br><span class="line"></span><br><span class="line">System.out.println(b.a);</span><br><span class="line">System.out.println(b.b);</span><br><span class="line">b.test();</span><br></pre></td></tr></table></figure>
执行上面的代码输出：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">child</span><br><span class="line">static_child</span><br><span class="line">child_static_child</span><br><span class="line">base</span><br><span class="line">static_base</span><br><span class="line">base_static_base</span><br></pre></td></tr></table></figure>
根据变量的静态类型确定访问变量或方法的行为称为静态绑定，静态绑定在编译阶段即可决定，动态绑定要到程序运行是才能确定。实例变量、静态变量、静态方法和私有方法都是采用静态绑定。<br>上面说的是父类和子类两者都有的情况。下面我们总结访问变量或方法时各种情况下的访问结果（不考虑私有变量方法和成员方法，因为私有的只有类内部可以访问，成员方法是动态绑定）：</li>
</ol>
</li>
<li><p>父类子类都没有对应的变量方法，谁访问都是报错。</p>
</li>
<li><p>访问子类特有的变量或方法只能使用静态类型是子类的变量访问，父类去访问会报错。</p>
</li>
<li><p>访问父类定义而子类没重复定义的变量方法，那静态类型是父类和子类的都能访问，访问的是父类对应的变量方法。</p>
</li>
<li><p>访问父类子类都有的变量方法，那就根据静态类型各访问各的，互不影响。</p>
</li>
</ol>
<h5 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h5><p>重载是指方法的名称相同但参数的签名不同（参数个数、类型或顺序不同），重写是指子类重新定义和父类参数签名相同的方法。我们在调用函数的时候，实参和形参不要求完全一致，只要实参精度不高于形参精度就可以。例如函数形参是<code>long</code>类型，实参是<code>int</code>类型也能调用。<br>假设父类和子类都有名为<code>sum</code>的函数：</p>
<ol>
<li>静态类型是父类的变量调用<code>sum</code>函数，只会在父类里面寻找参数类型匹配的函数调用，找不到报错。</li>
<li>静态类型是子类的变量调用<code>sum</code>函数，依据参数类型情况：<ol>
<li>优先调用参数匹配度高的函数，父类高就调用父类的函数。</li>
<li>匹配度一样的高的，子类的函数优先。</li>
</ol>
</li>
</ol>
<h5 id="父子类型转换"><a href="#父子类型转换" class="headerlink" title="父子类型转换"></a>父子类型转换</h5><p>子类型对象完全可以赋值给父类型的变量，这叫向上转型。那父类型的变量能不能赋值给子类型的变量呢？我们可以使用强转来尝试转换，如果类型是匹配的就可以，否则不行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> c;</span><br><span class="line">c = (Child) b;  <span class="comment">// 成功，因为此时的 b 本质上就是 Child</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br><span class="line"><span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> (Child) b;  <span class="comment">// 失败，因为此时 b 并不是 Child 类型的</span></span><br></pre></td></tr></table></figure>
<p>如果确实需要向下转型，但是又怕出错。可以使用<code>instanceof</code>关键字判断能否转型，例如使用<code>b instanceof Child</code>可以返回变量<code>b</code>引用的对象是否是<code>Child</code>类或其子类的对象。</p>
<h5 id="可见性重写和防止继承"><a href="#可见性重写和防止继承" class="headerlink" title="可见性重写和防止继承"></a>可见性重写和防止继承</h5><p>当我们使用子类重写父类的方法时，重写的方法不能降低可见性，可以提高。也就是说父类有个方法的可见性是<code>protected</code>，那么子类重写时可见性必须大于等于<code>protected</code>。<br>有时我们不希望某些非私有的方法被重写，我们在定义方法时候加上<code>final</code>关键字即可。类似的，我们可以在定义类的时候加上<code>final</code>关键字，这样这个类就是不可继承的。</p>
<h4 id="继承的基本原理"><a href="#继承的基本原理" class="headerlink" title="继承的基本原理"></a>继承的基本原理</h4><h5 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h5><p>所谓类加载是指将类相关的信息加载到内存之中的<strong>方法区</strong>。Java 的类是动态加载的，即第一次使用到这个类的时候才回去加载它，类加载只会进行一次。<br>首先我们要知道一个类包含哪些信息：</p>
<ol>
<li>类变量。</li>
<li>类初始化代码，这包含：<ul>
<li>定义静态变量时的赋值语句。</li>
<li>静态初始化代码块。</li>
</ul>
</li>
<li>类方法。</li>
<li>实例变量。</li>
<li>实例初始化代码，这包含：<ul>
<li>定义实例变量时的赋值语句。</li>
<li>实例初始化代码块。</li>
<li><strong>构造方法。</strong></li>
</ul>
</li>
<li>实例方法。</li>
<li>父类的信息引用。</li>
</ol>
<p>类加载的过程和顺序是这样的：</p>
<ol>
<li>分配内存保存类信息（上面列出的信息）。</li>
<li>给类变量赋默认值（数值类型是<code>0</code>，boolean 类型是<code>false</code>，引用类型是<code>null</code>）。</li>
<li>加载父类。</li>
<li>设置父子关系。</li>
<li>执行类初始化代码。</li>
</ol>
<p>从流程可以看出，加载父类的时候子类的所有信息都已经在内存之中了，类初始化代码也是父类先执行，然后是子类。</p>
<h5 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h5><p>一个类的多个对象之间互不干涉对方的实例变量，也就是说每个对象的实例变量都是独立的。那么每次创建的对象内存里面都包含着属于自己的实例变量。静态变量和成员方法都是共享的。<br>对象的创建过程如下：</p>
<ol>
<li>分配内存，内存里主要有：<ul>
<li>自己的所有实例变量。</li>
<li>父类的所有实例变量。</li>
<li>当前类信息的地址。</li>
</ul>
</li>
<li>对所有实例变量赋默认值（包含自己的和父类的）。</li>
<li>执行实例初始化代码，先执行父类的实例初始化代码，再执行自己的。</li>
</ol>
<p>我们假设基类是<code>Base</code>，子类是<code>Child</code>。这两个类都有实例变量<code>a</code>，那么我们执行<code>Child c = new Child(); Base b = c;</code>之后的内存图是这样的：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1700896542735-e50850b5-008b-46a1-a96a-6cc55d169d37.png#averageHue=%23e5e5e5&clientId=u1a25505d-4922-4&from=paste&height=663&id=u4e3fa6a9&originHeight=663&originWidth=947&originalType=binary&ratio=1&rotation=0&showTitle=false&size=166370&status=done&style=none&taskId=u391ac8cf-d7f9-48cd-a758-c3006d38ffe&title=&width=947" alt="image.png"><br>不要搞混，变量是存在<strong>栈</strong>里面的，对象的内容是存在<strong>堆</strong>里面的，类相关信息是存在<strong>方法区</strong>的。</p>
<h5 id="方法的调用过程"><a href="#方法的调用过程" class="headerlink" title="方法的调用过程"></a>方法的调用过程</h5><p>在<code>Child c = new Child(); Base b = c;</code>例子中，变量<code>b</code>和<code>c</code>的静态类型不一样。但实际上<code>b</code>和<code>c</code>指向同一个对象，若此时<code>b</code>调用<code>action</code>方法，肯定是从类<code>Child</code>里面寻找，找不到会到父类<code>Base</code>里面寻找，而这也是动态绑定的原因。<br>对于一些继承关系比较深的时候，层层寻找方法效率比较低下。所以很多实现都会在类加载的时候为每一个类创建一个虚方法表：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1700899733595-00ab9137-f4b0-499f-a76c-0099e4406e77.png#averageHue=%23f0f0f0&clientId=u1a25505d-4922-4&from=paste&height=633&id=u2f9854ea&originHeight=633&originWidth=967&originalType=binary&ratio=1&rotation=0&showTitle=false&size=170717&status=done&style=none&taskId=uc61da8c8-e844-4414-9374-101c6b6645d&title=&width=967" alt="image.png"></p>
<h4 id="双刃剑继承"><a href="#双刃剑继承" class="headerlink" title="双刃剑继承"></a>双刃剑继承</h4><p>继承功能很强大，但是随之也有一个很严重的问题——破坏封装性。所谓封装就是隐藏实现细节，提供简化接口即使用者只需要关注怎么用而不需要关注怎么实现。下面使用一个例子简单阐述继承是如何破坏封装性的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_NUM</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[MAX_NUM];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        arr[count++] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">            <span class="built_in">this</span>.arr[count++] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.add(n);</span><br><span class="line">        sum += n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.addAll(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">            sum += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基类的功能就是添加元素，添加分为一个个添加和批量添加。子类的功能是想在添加的基础上能够对添加的元素求和。表面上，父类实现的功能只管添加，子类重写方法时添加求和的功能即可。但实际上，父类方法的实现细节关乎子类的功能是否正常。例如，我把父类的<code>addAll</code>方法重写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">        add(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样改完之后，我们使用子类批量添加功能时，所有元素求和都会多求和一次。<br>此时，我们必须修改子类的实现，这就破坏了封装性。<br>正是因为继承的这个缺点，所以我们要尽可能的避免使用继承：</p>
<h5 id="使用final"><a href="#使用final" class="headerlink" title="使用final"></a>使用<code>final</code></h5><p>使用<code>final</code>修饰类，这个类直接不可继承；<code>final</code>修饰方法，这个方法不可被重写。</p>
<h5 id="使用组合"><a href="#使用组合" class="headerlink" title="使用组合"></a>使用组合</h5><p>我们看一下对于上面的例子改成组合之后是怎么实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Base base;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">()</span> &#123;</span><br><span class="line">        base = <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        base.add(n);</span><br><span class="line">        sum += n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        base.addAll(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">            sum += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个例子可以看出，使用组合之后，Base 类的实现就不重要了，我只需要关注我自己的功能即可。但这就带来了另一个问题——<code>Child</code>的对象就不能当做<code>Base</code>类进行统一处理了。这个问题我们只需要使用接口就可以解决。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag"># 后端</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2023/03/18/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8802%EF%BC%89/" rel="prev" title="Java 基础系列（02）">
                Java 基础系列（02） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/index.html">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">整数类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">小数类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9C%9F%E5%81%87%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.</span> <span class="nav-text">真假类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.</span> <span class="nav-text">字符类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.5.</span> <span class="nav-text">数组类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97"><span class="nav-number">2.</span> <span class="nav-text">基本运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="nav-number">2.1.</span> <span class="nav-text">算术运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97"><span class="nav-number">2.2.</span> <span class="nav-text">比较运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="nav-number">2.3.</span> <span class="nav-text">逻辑运算</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">分支结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#if%E5%88%86%E6%94%AF"><span class="nav-number">3.1.</span> <span class="nav-text">if分支</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#switch%E5%88%86%E6%94%AF"><span class="nav-number">3.2.</span> <span class="nav-text">switch分支</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E5%BC%BAswitch"><span class="nav-number">3.3.</span> <span class="nav-text">增强switch</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF"><span class="nav-number">4.</span> <span class="nav-text">循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">5.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B"><span class="nav-number">5.1.</span> <span class="nav-text">样例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%8F%82%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text">数组参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0"><span class="nav-number">5.3.</span> <span class="nav-text">可变长参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">5.4.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD"><span class="nav-number">5.5.</span> <span class="nav-text">重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-number">5.6.</span> <span class="nav-text">函数执行原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="nav-number">6.</span> <span class="nav-text">二进制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E6%95%B0"><span class="nav-number">6.1.</span> <span class="nav-text">整数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">6.2.</span> <span class="nav-text">位运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E6%95%B0"><span class="nav-number">6.3.</span> <span class="nav-text">小数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6"><span class="nav-number">6.4.</span> <span class="nav-text">字符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9F%BA%E7%A1%80"><span class="nav-number">7.</span> <span class="nav-text">类基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E3%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">7.1.</span> <span class="nav-text">变量、方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B"><span class="nav-number">7.2.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">7.3.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">7.4.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%85"><span class="nav-number">7.5.</span> <span class="nav-text">包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">7.6.</span> <span class="nav-text">可见性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jar-%E5%8C%85"><span class="nav-number">7.7.</span> <span class="nav-text">jar 包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">8.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B9%E7%88%B6%E7%B1%BB"><span class="nav-number">8.1.</span> <span class="nav-text">根父类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="nav-number">8.2.</span> <span class="nav-text">方法重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E5%BD%A2%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="nav-number">8.3.</span> <span class="nav-text">图形类的继承体系</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Shape-%E7%B1%BB"><span class="nav-number">8.3.1.</span> <span class="nav-text">Shape 类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Circle-%E7%B1%BB"><span class="nav-number">8.3.2.</span> <span class="nav-text">Circle 类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Line-%E7%B1%BB"><span class="nav-number">8.3.3.</span> <span class="nav-text">Line 类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ArrowLine-%E7%B1%BB"><span class="nav-number">8.3.4.</span> <span class="nav-text">ArrowLine 类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ShapeManager-%E7%B1%BB"><span class="nav-number">8.3.5.</span> <span class="nav-text">ShapeManager 类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-number">8.3.6.</span> <span class="nav-text">测试</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E7%BB%86%E8%8A%82"><span class="nav-number">8.4.</span> <span class="nav-text">继承的细节</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1"><span class="nav-number">8.4.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%90%8D"><span class="nav-number">8.4.2.</span> <span class="nav-text">重名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99"><span class="nav-number">8.4.3.</span> <span class="nav-text">重载和重写</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%88%B6%E5%AD%90%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">8.4.4.</span> <span class="nav-text">父子类型转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E9%87%8D%E5%86%99%E5%92%8C%E9%98%B2%E6%AD%A2%E7%BB%A7%E6%89%BF"><span class="nav-number">8.4.5.</span> <span class="nav-text">可见性重写和防止继承</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">8.5.</span> <span class="nav-text">继承的基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">8.5.1.</span> <span class="nav-text">类加载过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="nav-number">8.5.2.</span> <span class="nav-text">对象创建过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">8.5.3.</span> <span class="nav-text">方法的调用过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E5%88%83%E5%89%91%E7%BB%A7%E6%89%BF"><span class="nav-number">8.6.</span> <span class="nav-text">双刃剑继承</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8final"><span class="nav-number">8.6.1.</span> <span class="nav-text">使用final</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%84%E5%90%88"><span class="nav-number">8.6.2.</span> <span class="nav-text">使用组合</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lu Yan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
