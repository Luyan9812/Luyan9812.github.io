<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java,后端," />










<meta name="description" content="类的扩展接口我们在日常生活中，很多时候我们更关注能力而不是对象本身。比如我想要拍照，我关注的是“拍照”这个能力，至于使用什么设备并不重要。再比如比较的能力，同一个类对象之间甚至不同类对象之间都有可能进行比较，比如手机和平板都可以拍照，那谁拍照更厉害点？ 案例接下来我们假设有手机、平板若干，想要从这些设备里面选出拍照能力最强的设备。不同类别设备之间比较可以写方法来实现，但是类别较多的时候得写多少方法">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 基础系列（02）">
<meta property="og:url" content="http://example.com/2023/03/18/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8802%EF%BC%89/index.html">
<meta property="og:site_name" content="Luyan&#39;s Bolg">
<meta property="og:description" content="类的扩展接口我们在日常生活中，很多时候我们更关注能力而不是对象本身。比如我想要拍照，我关注的是“拍照”这个能力，至于使用什么设备并不重要。再比如比较的能力，同一个类对象之间甚至不同类对象之间都有可能进行比较，比如手机和平板都可以拍照，那谁拍照更厉害点？ 案例接下来我们假设有手机、平板若干，想要从这些设备里面选出拍照能力最强的设备。不同类别设备之间比较可以写方法来实现，但是类别较多的时候得写多少方法">
<meta property="og:locale">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1701430751923-2528ef15-0a29-48fc-8343-d808ef6299cc.png#averageHue=%23f0f0f0&clientId=u3e04a724-c595-4&from=paste&height=504&id=u52f6475f&originHeight=504&originWidth=958&originalType=binary&ratio=1&rotation=0&showTitle=false&size=152499&status=done&style=none&taskId=udfd5eb72-f315-4ca3-b1da-80a54b31bfb&title=&width=958">
<meta property="article:published_time" content="2023-03-18T04:03:52.000Z">
<meta property="article:modified_time" content="2024-08-02T04:17:28.629Z">
<meta property="article:author" content="Lu Yan">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="后端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1701430751923-2528ef15-0a29-48fc-8343-d808ef6299cc.png#averageHue=%23f0f0f0&clientId=u3e04a724-c595-4&from=paste&height=504&id=u52f6475f&originHeight=504&originWidth=958&originalType=binary&ratio=1&rotation=0&showTitle=false&size=152499&status=done&style=none&taskId=udfd5eb72-f315-4ca3-b1da-80a54b31bfb&title=&width=958">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2023/03/18/Java-基础系列（02）/"/>





  <title>Java 基础系列（02） | Luyan's Bolg</title>
  








<meta name="generator" content="Hexo 7.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Luyan's Bolg</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不积跬步，无以至千里；不积小流，无以成江海。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/index.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/18/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8802%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java 基础系列（02）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-03-18T12:03:52+08:00">
                2023-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="类的扩展"><a href="#类的扩展" class="headerlink" title="类的扩展"></a>类的扩展</h3><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>我们在日常生活中，很多时候我们更关注能力而不是对象本身。比如我想要拍照，我关注的是“拍照”这个能力，至于使用什么设备并不重要。再比如比较的能力，同一个类对象之间甚至不同类对象之间都有可能进行比较，比如手机和平板都可以拍照，那谁拍照更厉害点？</p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>接下来我们假设有手机、平板若干，想要从这些设备里面选出拍照能力最强的设备。不同类别设备之间比较可以写方法来实现，但是类别较多的时候得写多少方法？下面看看使用接口的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PhotoAble</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">takePhoto</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">photoAbility</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(PhotoAble o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们使用<code>interface</code>关键字定义了接口<code>PhotoAble</code>，这个接口定义了一些方法分别表示：拍照行为、计算设备拍照能力值、拍照设备之间比较。<br>比较的对象仍然是可拍照设备。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">PhotoAble</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Phone</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takePhoto</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;拍照&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">photoAbility</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 复杂的拍照能力逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(PhotoAble o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> photoAbility() - o.photoAbility();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pad</span> <span class="keyword">implements</span> <span class="title class_">PhotoAble</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pad</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takePhoto</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;平板拍照&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">photoAbility</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 复杂的拍照能力逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(PhotoAble o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> photoAbility() - o.photoAbility();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们定义了手机和平板类，它们都实现（implements）可拍照接口。<code>compareTo</code>方法返回一个整数，用这个整数的符号表示两个对象的大小关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Pad</span> <span class="variable">pad</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pad</span>(<span class="string">&quot;平板&quot;</span>);</span><br><span class="line">    <span class="type">Phone</span> <span class="variable">phone1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>(<span class="string">&quot;手机1&quot;</span>);</span><br><span class="line">    <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>(<span class="string">&quot;手机2&quot;</span>);</span><br><span class="line">    PhotoAble[] devices = <span class="keyword">new</span> <span class="title class_">PhotoAble</span>[]&#123;pad, phone1, phone2&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">PhotoAble</span> <span class="variable">max</span> <span class="operator">=</span> devices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (PhotoAble pa : devices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max.compareTo(pa) &lt; <span class="number">0</span>) max = pa;</span><br><span class="line">    &#125;</span><br><span class="line">    max.takePhoto();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试方法里面把一堆设备放到<code>PhotoAble</code>数组中，然后找出能力值最强的设备，并使用这个设备拍照。</p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ol>
<li>Java 使用<code>interface</code>关键字定义接口，使用<code>implements</code>关键字实现接口。</li>
<li>接口内可以声明一些方法，接口方法不需要加修饰符，默认都是<code>public abstract</code>。在 Java8 之前，接口内不能实现方法。</li>
<li>Java 继承只能是单继承，但是实现的接口可以是多个，表明这个类有多项能力。</li>
</ol>
<h5 id="接口的细节"><a href="#接口的细节" class="headerlink" title="接口的细节"></a>接口的细节</h5><ol>
<li>接口中是可以定义变量的，修饰符可以省略。省不省略修饰符都是<code>public static final</code>。</li>
<li>接口之间是可以继承的，而且接口的继承可以是多继承，也是使用<code>extends</code>关键字。当类实现接口的时候必须把该接口及其父接口的所有方法都实现一遍。</li>
<li>类可以同时继承父类与实现接口，但若是同时存在继承必须在前面，例如<code>class A extends B implements C, D &#123;&#125;</code>。</li>
<li>我们一样可以使用<code>instanceof</code>关键字来判断某对象是否实现了接口，例如<code>p instanceof A</code>。</li>
</ol>
<h5 id="使用接口替代继承"><a href="#使用接口替代继承" class="headerlink" title="使用接口替代继承"></a>使用接口替代继承</h5><p>记得上面的“添加数字求和”案例，之前使用继承会破坏代码的封装性。于是后面说使用组合，在<code>Child</code>类中引用<code>Base</code>类对象，这样就可以保护封装性。但这样<code>Base</code>与<code>Child</code>就没有办法统一处理。现在，为了解决这个问题，就可以定义接口来做到统一处理。于是最后就变成<code>组合+接口</code>替换继承。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IAdd</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> number)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] numbers)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">implements</span> <span class="title class_">IAdd</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> number)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">implements</span> <span class="title class_">IAdd</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> number)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="接口增强"><a href="#接口增强" class="headerlink" title="接口增强"></a>接口增强</h5><p>Java8 之前，接口中的方法都是抽象方法，不能有实现。Java8 则对接口做了一些增强，允许接口里面定义静态方法和默认方法。看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IAdd</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 默认方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> number)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] numbers)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态方法和默认方法都有方法体，静态方法可以通过接口名直接调用，例如<code>IAdd.test()</code>。默认方法使用关键字<code>default</code>关键字修饰，实现类可以选择不实现默认方法，直接使用默认的实现。引入默认方法的原因是某些接口已经被人实现，那么此时我需要往接口里面添加方法，那么所有的实现类都必须做适配处理，比较麻烦。<br>Java8 中静态方法和默认方法都必须是<code>public</code>，Java9 去除了这个限制，可以使用<code>private</code>。静态方法直接把修饰符从<code>public</code>改为<code>private</code>即可；但对于默认方法而言，<code>private</code>和<code>default</code>两个关键字不同一起使用，可以直接定义私有方法，例如<code>private void test() &#123;&#125;</code>。允许定义私有方法主要方便公开的方法复用代码。</p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类就是抽象的类，抽象类不能创建对象，它一般用于表达抽象的概念。例如圆形是具体的类，但图形是抽象的；苹果是具体的，水果就是抽象的等等。<br>之前说的<code>Shape</code>类，里面有一个<code>draw</code>方法。但对于图形来说，绘制是一件不知道如何实现的方法，只有具体的子类才能绘制。因此<code>Shape</code>就可以定义成抽象类，<code>draw</code>可以定义为抽象方法。抽象方法就是只有申明而没有实现的方法，接口里面的方法基本都是抽象的。抽象使用关键字<code>abstract</code>来表示，有抽象方法的类一定是抽象类，但抽象类不一定有抽象方法。<br>从形式上看，抽象类和接口很相似，有冗余的嫌疑。但实际上抽象类往往和接口互相配合，接口声明能力，抽象类提供默认实现。那有人问，接口有默认方法来提供默认实现，那么抽象类是不是就不需要了？并不是这样，首先抽象类是类，也就是说我们可以在抽象类里面正常定义实例变量之类的，这是接口做不到的。<br>对于实现接口的类来说，它可以选择自己实现接口或者选择继承抽象类。继承抽象类主要好处就是代码复用，但如果这个类已经有父类了，那么只能选择实现接口，因为 Java 类之间是单继承的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IAdd</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> number)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] numbers)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAdder</span> <span class="keyword">implements</span> <span class="title class_">IAdd</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">            add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span> <span class="keyword">extends</span> <span class="title class_">AbstractAdder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_NUM</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[MAX_NUM];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= MAX_NUM) <span class="keyword">return</span>;</span><br><span class="line">        numbers[count++] = number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>定义在一个类内部的类称为内部类，包含它的类称为外部类。内部类可以很方便访问外部类的私有变量，并且内部类本身可以定义为私有，这样就可以对外隐藏。但实际上，内部类只是编译器的概念，对 Java 虚拟机来说没有这样的概念，每一个内部类最后都会被编译成独立的类。内部类主要分为：</p>
<ol>
<li>静态内部类；</li>
<li>成员内部类；</li>
<li>方法内部类；</li>
<li>匿名内部类；</li>
</ol>
<p>下面我们一一讨论这些内部类。</p>
<h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5><p>静态内部类和静态变量、静态方法定义的位置是一样的，只不过定义的是类。看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">shared</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            shared++;</span><br><span class="line">            System.out.println(<span class="string">&quot;inner: &quot;</span> + shared);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;outer: &quot;</span> + shared);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态内部类与独立的类差别不大，可以有静态变量、静态方法、实例变量、实例方法、构造方法等。静态内部类可以访问外部类的<strong>静态变量</strong>与<strong>静态方法</strong>（私有的也能访问），但不可访问外部类的实例变量与实例方法。当内部类与外部类有变量同名的时候，需要使用<code>外部类.变量名</code>的方式使用。<br>外部类里面使用静态内部类，直接使用<code>new StaticInner()</code>即可。非私有的静态内部类可以被其它类访问，需要使用<code>外部类.静态内部类</code>的方式使用。看下面位于一个独立的类中的测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">    Outer.<span class="type">StaticInner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticInner();</span><br><span class="line">    outer.show();</span><br><span class="line">    inner.test();</span><br><span class="line">    outer.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们说，外部类和内部类最后都会被编译成两个独立的类。那么独立出来是怎么访问外部类的私有静态变量的？我们看看具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">shared</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Outer$StaticInner</span> <span class="variable">si</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer$StaticInner</span>();</span><br><span class="line">        si.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> access$<span class="number">0</span>()&#123;</span><br><span class="line">    	<span class="keyword">return</span> shared;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部类的名字会加上外部类名的前缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer$StaticInner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;inner &quot;</span> + Outer.access$<span class="number">0</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了让内部类访问到外部类的私有静态变量或私有静态方法，单独为外部类添加帮忙访问的静态方法。<br>静态内部类主要的使用场景：当我们类内部需要某种数据结构，而又不依赖外部类的具体实例，就可以使用静态内部类。比如外部类有一个方法需要返回数组里的最大值和最小值，那么我们可以定义一个静态内部类<code>Pair</code>用来存储最大值和最小值。之所以不把<code>Pair</code>分离成一个独立的类，是因为这个名字比较普遍，若是其他人也需要定义类似名字的变量比较麻烦。<br>Java API 中<code>LinkedList</code>类中就有一个私有静态内部类<code>Node</code>表示链表的节点。</p>
<h5 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h5><p>从形式上说，今天内部类和成员内部类的区别仅仅是没有<code>static</code>关键字修饰。但两者实际差距很大，看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">shared</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            Outer.shared++;</span><br><span class="line">            show();</span><br><span class="line">            System.out.printf(<span class="string">&quot;inner:%d, %d\n&quot;</span>, a, Outer.<span class="built_in">this</span>.a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;outer:%d, %d\n&quot;</span>, a, shared);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与静态内部类不同，成员内部类除了可以访问外部类的静态变量与静态方法还能访问外部类的成员变量与成员方法（不管是否私有都可以）。内外两个类存在变量或方法重名的时候，可以使用<code>外部类.变量名</code>的方式访问外部类的静态变量或静态方法，也可以使用<code>外部类.this.变量名</code>的方式访问外部类的实例变量或实例方法。<br>在外部类里面想要使用成员内部类，直接使用<code>new Inner()</code>即可。非私有的成员内部类可以被其它类访问，但不能直接通过外部类名来访问，而是需要借助外部类的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">    Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    inner.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要在其它类里面创建成员内部类对象需要使用<code>外部类对象.new 内部类()</code>的方式。<br>具体的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;action&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Outer$Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer$Inner</span>(<span class="built_in">this</span>);</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> access$<span class="number">0</span>(Outer outer) &#123;</span><br><span class="line">    	<span class="keyword">return</span> outer.a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> access$<span class="number">1</span>(Outer outer) &#123;</span><br><span class="line">    	outer.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer$Inner</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Outer outer;</span><br><span class="line">    <span class="keyword">public</span> Outer$Inner(Outer outer)&#123;</span><br><span class="line">    	ths.outer = outer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;outer a &quot;</span> + Outer.access$<span class="number">0</span>(outer));</span><br><span class="line">        Outer.access$<span class="number">1</span>(outer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员内部类在创建的时候会得到一个外部类的实例的引用，后期便可以通过它来访问实例变量与实例方法。应用场景：当内部类与外部类关系密切，需要使用外部类的实例变量或实例方法，那么定义为成员内部类比较合适。</p>
<h5 id="方法内部类"><a href="#方法内部类" class="headerlink" title="方法内部类"></a>方法内部类</h5><p>定义在方法体里面的内部类称为方法内部类，看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">shared</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> param)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;HH&quot;</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">                a++;</span><br><span class="line">                shared++;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(shared);</span><br><span class="line">                System.out.println(param);</span><br><span class="line">                System.out.println(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部类<code>Inner</code>定义在方法体里面，这个类只有在该方法内部可以使用。如果外部方法是静态的，那么内部类仅可以访问外部类的静态变量与静态方法；如果外部方法是实例方法，那么内部类可以访问外部类的静态变量、静态方法、实例变量、实例方法。不论外部方法是不是静态的，内部类都可以访问方法的参数与局部变量，前提是该参数或变量是<code>final</code>的或实际上是<code>final</code>的（没有修改）。<br>方法内部类访问外部类的成员变量的方式与上面其它内部类是一样，那局部变量或参数是怎么访问的呢？为什么要加上只能<code>final</code>的限制呢？<br>答：实际上，方法内部类在实例化的时候会把用到的参数与局部变量作为参数传到内部类里面。因此实际上，内部类访问到的局部变量和参数都是副本，根本和外部方法里面的变量不是同一个。所以你在内部类修改局部变量是不影响外面的，为了防止出现误解，故要求能访问的参数或局部变量必须要<code>final</code>的或者实际<code>final</code>的。你实在想在方法内部类里面修改外面的局部变量，那么就传一个数组进去，然后修改数组元素。</p>
<h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><p>匿名内部类没有单独的类定义，它是在创建对象的同时定义类。语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类(构造列表) &#123;</span><br><span class="line">	<span class="comment">// 内部实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父接口() &#123;</span><br><span class="line">    <span class="comment">// 内部实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一个以<code>Point</code>类为父类的匿名内部类的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>, y = <span class="number">1</span>;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> distance(<span class="keyword">new</span> <span class="title class_">Point</span>(x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(p.distance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们这边创建了一个匿名内部类，其父类是<code>Point</code>。这个内部类重写了<code>distance</code>方法，并在方法里访问了外部方法的局部变量。<br>匿名内部类只能使用一次，创建一个对象。它没有名字，没有构造，可以调用对应的父类构造。它可以定义实例变量与实例方法，也可以有初始化代码块。与其它内部类相似，它可以访问外部类所有的变量与方法，同时也可以访问外部方法的<code>final</code>局部变量与参数。<br>这个例子的内部实现类似于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer$1</span> <span class="keyword">extends</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x2;</span><br><span class="line">    <span class="type">int</span> y2;</span><br><span class="line">    Outer outer;</span><br><span class="line">    Outer$<span class="number">1</span>(Outer outer, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)&#123;</span><br><span class="line">        <span class="built_in">super</span>(x1,y1);</span><br><span class="line">        <span class="built_in">this</span>.outer = outer;</span><br><span class="line">        <span class="built_in">this</span>.x2 = x2;</span><br><span class="line">        <span class="built_in">this</span>.y2 = y2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> distance(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="built_in">this</span>.x2, y2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很多方法调用的时候有个参数是接口类型，此时匿名内部类使用也较多。比如比较方法里面需要一个参数是<code>Comparator</code>类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">        <span class="comment">// 比较逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>枚举是一种特殊的类型，它的取值是有限的。比如一周七天，一年四季。枚举的定义和使用很简单，下面使用表示大小的枚举来举例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    SMALL, MEDIUM, BIG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子定义了一个枚举类，名字叫<code>Size</code>。它有三种取值，分别是：<code>SMALL</code>、<code>MEDIUM</code>、<code>BIG</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Size</span> <span class="variable">size</span> <span class="operator">=</span> Size.SMALL;</span><br><span class="line">System.out.println(size.name());</span><br><span class="line">System.out.println(size.toString());</span><br></pre></td></tr></table></figure>
<p>要取枚举类里面定义的值来给枚举变量赋值。我们可以使用<code>name</code>和<code>toString</code>方法返回枚举值的字面量，这边返回字符串<code>SMALL</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(size == Size.BIG);</span><br><span class="line">println(size.equals(Size.BIG));</span><br></pre></td></tr></table></figure>
<p>枚举变量之间可以进行比较，可以使用<code>equals</code>方法也可以直接使用<code>==</code>进行比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(size.ordinal());</span><br></pre></td></tr></table></figure>
<p>调用<code>ordinal</code>方法可以返回枚举量的序号（从 0 开始编号）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(size.compareTo(Size.BIG));</span><br></pre></td></tr></table></figure>
<p>枚举类型都实现了<code>Comparable</code>接口，因此可以调用<code>compareTo</code>方法返回两个变量的大小关系，比较的依据是两个变量的序号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (size) &#123;</span><br><span class="line">    <span class="keyword">case</span> SMALL:</span><br><span class="line">        println(<span class="string">&quot;SMALL&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类型可以使用<code>switch</code>语句，但是在<code>case</code>里面直接写值即可，不需要添加类名前缀。例如可以写<code>case BIG</code>而不是<code>case Size.BIG</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Size</span> <span class="variable">s</span> <span class="operator">=</span> Size.valueOf(<span class="string">&quot;SMALL&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Size s : Size.values()) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类有静态方法：</p>
<ul>
<li><code>valueOf</code>方法根据字面量返回枚举类型。</li>
<li><code>values</code>方法按序返回所有的枚举值。</li>
</ul>
<p>上面普通枚举类型将会被编译器转换成具体的类，转换后的代码大致如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Size</span> <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;Size&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Size</span> <span class="variable">SMALL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Size</span>(<span class="string">&quot;SMALL&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Size</span> <span class="variable">MEDIUM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Size</span>(<span class="string">&quot;MEDIUM&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Size</span> <span class="variable">LARGE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Size</span>(<span class="string">&quot;LARGE&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Size[] VALUES = <span class="keyword">new</span> <span class="title class_">Size</span>[]&#123;SMALL,MEDIUM,LARGE&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Size</span><span class="params">(String name, <span class="type">int</span> ordinal)</span>&#123;</span><br><span class="line">    	<span class="built_in">super</span>(name, ordinal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Size[] values()&#123;</span><br><span class="line">        Size[] values = <span class="keyword">new</span> <span class="title class_">Size</span>[VALUES.length];</span><br><span class="line">        System.arraycopy(VALUES, <span class="number">0</span>, values, <span class="number">0</span>, VALUES.length);</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Size <span class="title function_">valueOf</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> Enum.valueOf(Size.class, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个类将会继承于<code>Enum</code>类，<code>Enum</code>类有两个实例变量<code>name</code>和<code>ordinal</code>，在构造里需要传递。<code>Enum</code>类的<code>name()、toString()、ordinal()、compareTo()、equals()</code>都是基于这两个变量实现的。<br>上面我们只是介绍了最简单的枚举应用，在日常使用中，枚举值很可能有缩写或其它的别名。此时代码可以改成下面的样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    SMALL(<span class="string">&quot;S&quot;</span>, <span class="string">&quot;小号&quot;</span>),</span><br><span class="line">    MEDIUM(<span class="string">&quot;M&quot;</span>, <span class="string">&quot;中号&quot;</span>),</span><br><span class="line">    BIG(<span class="string">&quot;L&quot;</span>, <span class="string">&quot;大号&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String abbr;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    Size(String abbr, String title) &#123;</span><br><span class="line">        <span class="built_in">this</span>.abbr = abbr;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Size <span class="title function_">fromAbbr</span><span class="params">(String abbr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Size size : values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (size.abbr.equals(abbr)) <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAbbr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> abbr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们给枚举类型添加了两个属性<code>abbr</code>和<code>title</code>，它们分别表示缩写和中文名称。</li>
<li>把这两个属性加到构造方法里面，注意：因为枚举变量的值是固定的，所以这个构造只能是私有的，不能被外人调用，<code>private</code>修饰符可以省略。</li>
<li>为了方便，我们定义了一个根据缩写返回对应枚举值的静态方法。</li>
<li>此时，我们在定义枚举值的时候需要：<ul>
<li>枚举值必须定义在类的最上面。</li>
<li>枚举值定义的时候，需要以构造的方式传参。</li>
</ul>
</li>
<li>使用还是老样子<code>Size s = Size.BIG;</code>或者<code>Size s = Size.fromAbbr(&quot;L&quot;);</code>。</li>
</ul>
<p>这种情况下编译器转换的源码大致如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Size</span> <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;Size&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Size</span> <span class="variable">SMALL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Size</span>(<span class="string">&quot;SMALL&quot;</span>,<span class="number">0</span>, <span class="string">&quot;S&quot;</span>, <span class="string">&quot;小号&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Size</span> <span class="variable">MEDIUM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Size</span>(<span class="string">&quot;MEDIUM&quot;</span>,<span class="number">1</span>,<span class="string">&quot;M&quot;</span>,<span class="string">&quot;中号&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Size</span> <span class="variable">LARGE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Size</span>(<span class="string">&quot;LARGE&quot;</span>,<span class="number">2</span>,<span class="string">&quot;L&quot;</span>,<span class="string">&quot;大号&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> String abbr;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Size</span><span class="params">(String name, <span class="type">int</span> ordinal, String abbr, String title)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name, ordinal);</span><br><span class="line">        <span class="built_in">this</span>.abbr = abbr;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下，每个枚举值都会关联一个<code>id</code>值。一个自然的想法是使用<code>ordinal</code>，如果这样写会有一个隐患：如果枚举变量的<code>id</code>已经被存储到了其它地方（例如数据库），我们这时准备再添加一个枚举值，那么就有可能改变枚举值的<code>ordinal</code>，那么存储的<code>id</code>就可能对应错误的枚举值。合理的做法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    XSMALL(<span class="number">10</span>), SMALL(<span class="number">20</span>), MEDIUM(<span class="number">30</span>), LARGE(<span class="number">40</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Size</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">    	<span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>程序运行过程中会遇到许许多多的问题，比如内存耗尽、网络异常、使用未初始化的变量等。这些非正常的情况，在 Java 里面都认作异常。</p>
<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p>下面的案例，我们在字符串<code>s</code>为空的情况下调用方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    s.indexOf(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果类似于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException:</span><br><span class="line">	at com.luyan.Main.main(Main.java:<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>这个输出告诉我们<code>Main</code>类的<code>main</code>方法里面第 6 行出问题了。主要是<code>null</code>不能调用方法，所以程序没法继续执行下去了。这时就启动异常处理机制：</p>
<ol>
<li>首先创建异常对象<code>NullPointerException</code>（空指针异常）。</li>
<li>然后查看谁能处理这个异常，没有人处理就启用默认机制。</li>
<li>默认打印异常栈并结束程序，因为是结束程序，所以出错代码后面的代码是运行不到的。</li>
</ol>
<p>很多时候默认的处理机制我们并不满意，我们可以使用<code>try/catch</code>来捕获异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        s.indexOf(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串为 null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用<code>try</code>块将可能出异常的代码块括起来，然后使用<code>catch</code>块捕获异常。当程序抛出<code>NullPointerException</code>异常的时候会被捕获，然后执行<code>catch</code>内部的代码。因为异常被处理了，所以不会启用默认机制，因此程序也不会退出，后面的代码也能继续执行。</p>
<h4 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h4><p>Java 里定义了许多异常类，例如上面见到的<code>NullPointerException</code>。所有的异常类都继承于<code>Throwable</code>，下面我们一一介绍。</p>
<h5 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h5><p><code>Throwable</code>是所有异常类的父类，它有 4 个公开的构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Throwable</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Throwable</span><span class="params">(String message)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Throwable</span><span class="params">(String message, Throwable cause)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Throwable</span><span class="params">(Throwable cause)</span></span><br></pre></td></tr></table></figure>
<p>构造的参数主要有两个：一个是<code>message</code>，表示异常信息；一个是<code>cause</code>，表示触发该异常的其它异常。异常可以构成一个异常链，上层异常由底层异常触发，<code>cause</code>就表示底层异常。除了构造方法外，<code>Throwable</code>还有一个方法<code>Throwable initCause(Throwable cause)</code>来设置<code>cause</code>，这个方法最多给<strong>调用一次</strong>。<br><code>Throwable</code>类有一个很重要的方法<code>fillInStackTrace()</code>，这个方法会在所有的构造里面调用，它表示将异常信息保存，这是我们能看到异常栈的关键。除此之外，<code>Throwable</code>还有一些查看异常信息的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printStackTrace</span><span class="params">()</span>  <span class="comment">// 打印异常栈信息到标准错误输出流</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印异常栈信息到指定的流</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printStackTrace</span><span class="params">(PrintStream s)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printStackTrace</span><span class="params">(PrintWriter s)</span></span><br><span class="line"></span><br><span class="line">String <span class="title function_">getMessage</span><span class="params">()</span>  <span class="comment">// 获取异常 message</span></span><br><span class="line">Throwable <span class="title function_">getCause</span><span class="params">()</span>  <span class="comment">//឴ 获取异常 cause</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取异常栈每层的信息，每层信息包含文件名、类名、方法名、行号等信息</span></span><br><span class="line">StackTraceElement[] getStackTrace()</span><br></pre></td></tr></table></figure>
<h5 id="异常类体系"><a href="#异常类体系" class="headerlink" title="异常类体系"></a>异常类体系</h5><p>以<code>Throwable</code>为根，Java 定义了很多异常，部分异常如下图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1701430751923-2528ef15-0a29-48fc-8343-d808ef6299cc.png#averageHue=%23f0f0f0&clientId=u3e04a724-c595-4&from=paste&height=504&id=u52f6475f&originHeight=504&originWidth=958&originalType=binary&ratio=1&rotation=0&showTitle=false&size=152499&status=done&style=none&taskId=udfd5eb72-f315-4ca3-b1da-80a54b31bfb&title=&width=958" alt="image.png"><br><code>Throwable</code>有两个直接子类：<code>Error</code>和<code>Exception</code>。其中<code>Error</code>表示系统错误或资源耗尽，应用层不应该抛出或处理这样的异常。<code>Exception</code>表示应用程序错误，我们可以继承它或它的子类来自定义异常。<br><code>RuntimeException</code>叫做运行时异常，这个名字比较有误导性，因为其它的异常也都是运行时产生的。准确的说<code>RuntimeException</code>是未受检异常，所谓受检异常指的是强制要求程序员处理的异常，未受检异常则不强制。相比而言，<code>Exception</code>其它子类和它本身都是受检异常，所有<code>Error</code>则是未受检异常。<br>如此多的异常类相比<code>Throwable</code>这个基类而言并没有添加多少属性和方法，定义这么多异常，主要为了名字不同。因为异常的名字包含了错误的关键信息，取合适的名字可以增加代码的可读性。</p>
<h5 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h5><p>自定义异常只需要取一个合适的名字，然后选择一个合适的父类异常进行继承即可。自定义异常的受检性和其父类一致，一般来说自定义的异常我们也不会添加什么属性方法，只会写几个构造里面调用父类构造即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SelfException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SelfException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SelfException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SelfException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SelfException</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="catch-匹配"><a href="#catch-匹配" class="headerlink" title="catch 匹配"></a>catch 匹配</h5><p>我们在案例里面简单看了异常的捕获，实际上<code>catch</code>块可以有多个，表示捕获多种异常，看例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">// 可能出异常代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;not valid number&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(RuntimeException e)&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;runtime exception &quot;</span>+e.getMessage());</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当代码出异常的时候会查找能捕获的第一个<code>catch</code>块并执行里面的代码，其它<code>catch</code>里面的代码是不执行的。如果找不到能捕获的，此时后面的代码不会执行，会直接跳到上一层调用中继续查找，到最后都找不到就执行默认机制。<br>捕获异常的时候，若异常之间如有继承关系，则范围小的异常应该在上面，否则会报错的（因为大异常在上面，就没下面小异常的事情了）。这个例子里面使用了<code>e.getMessage()</code>和<code>e.printStackTrace()</code>获取&#x2F;输出异常信息。在实际应用中，我们会将异常信息保存在专门的日志文件里面而不是直接控制台输出。<br>当我们多种异常的处理方案是一样的时候，Java7 之后给我们提供了简化的语法<code>|</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 可能出异常代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionA | ExceptionB e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="重新抛出异常"><a href="#重新抛出异常" class="headerlink" title="重新抛出异常"></a>重新抛出异常</h5><p>在<code>catch</code>块里面处理完异常后，我们可以重新再抛出异常，可以抛出原来的，也可以抛出新建的异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">// 可能出异常代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;not valid number&quot;</span>);</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AppException</span>(<span class="string">&quot;输入格式不对&quot;</span>, e);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抛出新异常的时候，把当前异常作为<code>cause</code>传递给新异常。这样就形成一个异常链，调用者可以使用<code>getCause</code>方法获取到原来的异常。<br>为什么要重新抛出？因为当前代码不能完全处理这个异常，需要调用者进一步处理。<br>为什么抛出新异常？抛出新异常可能是因为当前异常不合适或者需要补充新信息。</p>
<h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><p><code>finally</code>是异常机制中重要的一部分，它可以跟在<code>catch</code>后面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">// 可能出异常代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">	<span class="comment">// 异常捕获</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="comment">// 无论有无异常都会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>若无异常发生，<code>finally</code>代码块在<code>try</code>块结束之后执行。</li>
<li>异常被捕获，则<code>finally</code>块在<code>catch</code>块之后执行。</li>
<li>有异常但没被捕获，<code>finally</code>块在异常抛给上层之前执行。</li>
</ol>
<p>因为这些特性，<code>finally</code>块一般用来释放资源，如数据库连接、文件流等。<br>在实际操作的时候，<code>catch</code>块可以没有，只有<code>try/finally</code>块，这表示出现异常时直接上抛，但<code>finally</code>里面的代码在出现异常的时候也要执行。<br>有个小细节，当我们在<code>try/catch</code>块里面返回变量<code>ret</code>的值时，此时我们在<code>finally</code>里面改变<code>ret</code>的值会怎样？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ret = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终还是返回 0，返回肯定还是在<code>finally</code>执行完毕之后才返回的。<br>原因是之前讲的，当遇到<code>return</code>之后，会先把返回值存起来，然后调用方获取存的值。<br>因此<code>finally</code>只是修改变量<code>ret</code>的值而不是返回值。<br>那如果<code>finally</code>里面有<code>return</code>呢？那么会返回<code>finally</code>里面的值。不仅如此，<code>finally</code>有返回值时还会掩盖掉上抛的异常，就像没有异常一样。除此之外，如果在<code>finally</code>里面抛出异常，原来的异常会被顶替掉，就消失了。基于此，我们应该避免在<code>finally</code>里面返回值或抛出异常。</p>
<h5 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h5><p>对于需要使用资源的场景，经典流程是在<code>finally</code>里面释放资源。Java7 支持了一种新语法，这称为<code>try-with-resources</code>，它能够自动关闭要释放的资源。这种语法针对实现了<code>AutoCloseable</code>接口的类对象。这个接口定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>try-with-resources</code>语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="type">AutoCloseable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Hello&quot;</span>)) &#123;</span><br><span class="line">	<span class="comment">// 使用资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>资源的定义放在<code>try</code>语句里面，我们无需在<code>finally</code>里面手动释放。系统会在执行完<code>try</code>之后自动调用对象的<code>close</code>方法。如果有多个资源，那么在<code>try</code>语句里面定义多个，使用<code>;</code>隔开。<br>Java9 之后可以把资源定义在外面，但要求资源是<code>final</code>或实际上是<code>final</code>的，如下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AutoCloseable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">AutoCloseable</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">try</span>(r; r2) &#123;</span><br><span class="line">	<span class="comment">// 使用资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h5><p>异常机制中有一个关键字<code>throw</code>，这个关键字用于代码抛出异常，例如<code>throw new IllegalArgumentException();</code>。<br>还有一个<code>throws</code>关键字与之很像，它用于声明一个方法可能抛出的异常。语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, NumberFormatException &#123;</span><br><span class="line">	<span class="comment">//主体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>throws</code>可以声明多个异常，异常间使用逗号隔开。它表示这个方法可能会抛出哪些异常，这些异常在方法内无法完全处理，需要调用者继续处理。但具体什么情况抛异常未知，因此我们应该将这些信息用注释的方式标注出来。<br>对于未受检异常不要求使用<code>throws</code>声明，但是受检异常必须声明然后才能抛出。受检异常声明之后可以不抛出，但抛出必须有声明。<br>若一个方法 A 调用了另一个有<strong>受检异常</strong>声明的方法 B，那么 A 必须要处理声明的受检异常（不受检异常不做要求）。处理的方式包括：</p>
<ol>
<li>使用<code>catch</code>捕获异常。</li>
<li>继续使用<code>throws</code>往上抛出。</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag"># 后端</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2023/03/01/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8801%EF%BC%89/" rel="next" title="Java 基础系列（01）">
                <i class="fa fa-chevron-left"></i> Java 基础系列（01）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2023/04/02/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8803%EF%BC%89/" rel="prev" title="Java 基础系列（03）">
                Java 基础系列（03） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/index.html">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">1.</span> <span class="nav-text">类的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">案例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.1.2.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%86%E8%8A%82"><span class="nav-number">1.1.3.</span> <span class="nav-text">接口的细节</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%9B%BF%E4%BB%A3%E7%BB%A7%E6%89%BF"><span class="nav-number">1.1.4.</span> <span class="nav-text">使用接口替代继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%A2%9E%E5%BC%BA"><span class="nav-number">1.1.5.</span> <span class="nav-text">接口增强</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">1.2.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.3.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.3.1.</span> <span class="nav-text">静态内部类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.3.2.</span> <span class="nav-text">成员内部类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.3.3.</span> <span class="nav-text">方法内部类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.3.4.</span> <span class="nav-text">匿名内部类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.4.</span> <span class="nav-text">枚举</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">2.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="nav-number">2.1.</span> <span class="nav-text">案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="nav-number">2.2.</span> <span class="nav-text">异常类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Throwable"><span class="nav-number">2.2.1.</span> <span class="nav-text">Throwable</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%B1%BB%E4%BD%93%E7%B3%BB"><span class="nav-number">2.2.2.</span> <span class="nav-text">异常类体系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="nav-number">2.2.3.</span> <span class="nav-text">自定义异常</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">2.3.</span> <span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#catch-%E5%8C%B9%E9%85%8D"><span class="nav-number">2.3.1.</span> <span class="nav-text">catch 匹配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="nav-number">2.3.2.</span> <span class="nav-text">重新抛出异常</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#finally"><span class="nav-number">2.3.3.</span> <span class="nav-text">finally</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#try-with-resources"><span class="nav-number">2.3.4.</span> <span class="nav-text">try-with-resources</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#throws"><span class="nav-number">2.3.5.</span> <span class="nav-text">throws</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lu Yan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
