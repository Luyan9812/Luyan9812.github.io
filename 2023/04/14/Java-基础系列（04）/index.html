<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java,后端," />










<meta name="description" content="泛型简单使用泛型字面意思是广泛的类型，类、接口、方法代码可以应用于非常广泛的类型，代码与它们能够操作的数据类型不再绑定在一起。下面看一个简单的例子： 1234567891011class Pair&lt;T&gt; &#123;    T data;    public Pair(T data) &#123;        this.data &#x3D; data;    &#125;    public">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 基础系列（04）">
<meta property="og:url" content="http://example.com/2023/04/14/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8804%EF%BC%89/index.html">
<meta property="og:site_name" content="Luyan&#39;s Bolg">
<meta property="og:description" content="泛型简单使用泛型字面意思是广泛的类型，类、接口、方法代码可以应用于非常广泛的类型，代码与它们能够操作的数据类型不再绑定在一起。下面看一个简单的例子： 1234567891011class Pair&lt;T&gt; &#123;    T data;    public Pair(T data) &#123;        this.data &#x3D; data;    &#125;    public">
<meta property="og:locale">
<meta property="article:published_time" content="2023-04-14T04:03:58.000Z">
<meta property="article:modified_time" content="2024-08-02T04:17:09.557Z">
<meta property="article:author" content="Lu Yan">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="后端">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2023/04/14/Java-基础系列（04）/"/>





  <title>Java 基础系列（04） | Luyan's Bolg</title>
  








<meta name="generator" content="Hexo 7.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Luyan's Bolg</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不积跬步，无以至千里；不积小流，无以成江海。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/index.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/14/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8804%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java 基础系列（04）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-14T12:03:58+08:00">
                2023-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><p>泛型字面意思是广泛的类型，类、接口、方法代码可以应用于非常广泛的类型，代码与它们能够操作的数据类型不再绑定在一起。下面看一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是一个简单的泛型例子，这边的<code>T</code>是类型参数，泛型就是类型参数化，处理的数据类型不是固定的而是可以作为参数传入的。使用时直接用<code>Pair&lt;Integer&gt; pair = new Pair&lt;Integer&gt;(1)</code>来创建带泛型的类对象，我们使用<code>pair.getData()</code>方法返回的数据直接就是<code>Integer</code>类型。<br>参数类型可以有多个，多个类型之间使用逗号隔开：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;U, V&gt; &#123;</span><br><span class="line">    U first;</span><br><span class="line">    V second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(U first, V second)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> U <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getSecond</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建对象的时候可以使用<code>Pair&lt;Integer, String&gt; pair = new Pair&lt;Integer, String&gt;(1, &quot;张三&quot;) </code>，从 Java7 开始<code>new</code>后面的泛型可以省略以简洁代码：<code>Pair&lt;Integer, String&gt; pair = new Pair&lt;&gt;(1, &quot;张三&quot;) </code>。<br>上面带泛型的类创建对象的时候，传递的类型可以是任意的，按需传递。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>对于上面的例子，如果没有泛型机制我们也是可以实现的，以第一个例子看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    Object data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 使用强转变为原类型</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> (Integer) pair.getData();</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure>

<p>我们直接使用<code>Object</code>作为数据类型也可以实现类似的功能，只是稍微麻烦一点。实际上编译器内部也是这么做的，它会将含有泛型的代码转化成不含泛型的代码。主要是将泛型参数<code>T</code>之类的<strong>擦除</strong>，将其转化成<code>Object</code>，然后插入必要的强制类型转换。当代码进入虚拟机运行的时候，是没有泛型的概念的。<br>既然这样为什么不直接使用<code>Object</code>？泛型是 Java5 开始支持的，这么设计也是为了兼容性。泛型有两个主要的好处：更好的安全性和更好的可读性。<br>可读性可以理解，安全性可以使用一个例子看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) pair.getData();</span><br></pre></td></tr></table></figure>
<p>因为 data 是<code>Object</code>类型，所以强转成<code>String</code>不会报语法错误，但是实际上运行时会报错。<br>如果使用泛型就不会发生这样的问题，因为如果接受变量的类型不一致会直接编译出错。</p>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>除了类可以泛型，方法也可以使用泛型。注意，方法是否泛型与其所在类是否泛型无关：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">index</span><span class="params">(T[] arr, T ele)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i].equals(ele)) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法就是一个泛型方法，类型参数是<code>T</code>，定义在返回值类型的前面。我们可以有如下调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index(<span class="keyword">new</span> <span class="title class_">Integer</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, <span class="number">4</span>);</span><br><span class="line">index(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;卢研&quot;</span>, <span class="string">&quot;刘妙霞&quot;</span>&#125;, <span class="string">&quot;卢研&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>index</code>是一种算法，一种在数组里面寻找元素的算法，与具体数据类型无关。和泛型类相似，泛型方法也可以定义多个泛型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U,V&gt; Pair&lt;U,V&gt; <span class="title function_">makePair</span><span class="params">(U first, V second)</span>&#123;</span><br><span class="line">    Pair&lt;U,V&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(first, second);</span><br><span class="line">    <span class="keyword">return</span> pair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与泛型类不同，我们在调用泛型方法的时候不需要指定具体的类型进去，因为根据函数参数能够推断出泛型的具体类型。就好比可以直接写<code>makePair(1,&quot;卢研&quot;)</code>而不需要<code>makePair&lt;Integer, String&gt;(1,&quot;卢研&quot;)</code>，实际上后者的写法是错误的。</p>
<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>接口也可以使用泛型，之前介绍的<code>Comparable</code>和<code>Comparator</code>接口都使用了泛型。它们代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T o)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现接口的时候需要指定具体的类型，例如对于<code>Integer</code>来说，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Integer</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Integer anotherInteger)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> compare(<span class="built_in">this</span>.value, anotherInteger.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型参数限定"><a href="#类型参数限定" class="headerlink" title="类型参数限定"></a>类型参数限定</h4><p>根据之前的理解，我们把泛型参数当做<code>Object</code>，这个范围太大了。Java 支持给这个泛型添加一个上限，使用关键字<code>extends</code>实现。</p>
<h5 id="上界是具体类"><a href="#上界是具体类" class="headerlink" title="上界是具体类"></a>上界是具体类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;</span><br><span class="line">    T one, two;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T one, T two)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.one = one;</span><br><span class="line">        <span class="built_in">this</span>.two = two;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> one.doubleValue() + two.doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这个类仍然是泛型类，不过我们对泛型参数<code>T</code>设置了一个上限<code>Number</code>。这样变量<code>one</code>和<code>two</code>就可以当做<code>Number</code>处理，创建对象时传递的类型必须要是<code>Number</code>及其子类。限定类型之后，如果类型使用不匹配会报错。<br>指定边界之后，泛型擦除时不会转换成<code>Object</code>而会转换成它的边界类型。</p>
<h5 id="上界是接口"><a href="#上界是接口" class="headerlink" title="上界是接口"></a>上界是接口</h5><p>在实际使用中，一种很常见的场景是限定类型必须实现<code>Comparable</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">max</span><span class="params">(T[] arr)</span>&#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].compareTo(max)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边使用泛型方法举例子，方法功能是返回数组里面的最大的元素。数组元素的类型只要实现了<code>Comparable</code>接口即可。注意，泛型参数继承<code>Comparable&lt;T&gt;</code>表示类型<code>T</code>必须能够与同一类型的其它元素比较。</p>
<h5 id="上界是其它类型参数"><a href="#上界是其它类型参数" class="headerlink" title="上界是其它类型参数"></a>上界是其它类型参数</h5><p>Java 还支持一个类型参数以另一个类型参数作为上界，为什么需要这个功能，我们使用例子一步步看。首先我们自己实现一个低配版的<code>ArrayList</code>命名为<code>MyList</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> Object[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_SIZE];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T ele)</span> &#123;</span><br><span class="line">        ensureCapacity(size + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">this</span>.arr[size++] = ele;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="built_in">this</span>.arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity &gt;= minCapacity) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; minCapacity)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        arr = Arrays.copyOf(arr, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类主要方法就是<code>add</code>和<code>get</code>，因为不存在<code>new T[SIZE]</code>这样的写法，所以数组被定义为<code>Object</code>类型。下面我们想要添加一个新方法<code>addAll</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(MyList&lt;T&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size; ++i) &#123;</span><br><span class="line">        add(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码实现比较简单，一切似乎都没有问题。那我们看下面的使用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyList&lt;Number&gt; list1 = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;&gt;();</span><br><span class="line">MyList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;&gt;();</span><br><span class="line">list1.addAll(list2);  <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>
<p>正如注释所说，代码编译错误。错误的原因是参数需要<code>MyList&lt;Number&gt;</code>，传进来的却是<code>MyList&lt;Integer&gt;</code>。按理来说，<code>Integer</code>是<code>Number</code>类的子类，将一些<code>Integer</code>放到<code>Number</code>数组里面也是合情合理。为什么不能把<code>MyList&lt;Integer&gt;</code>也看成<code>MyList&lt;Number&gt;</code>的子类呢？假设可以看成子类，我们再看另一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;&gt;();</span><br><span class="line">MyList&lt;Number&gt; list = list2;  <span class="comment">// 假设这么写成立</span></span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">3.14</span>));  <span class="comment">// 那么按照假设，这样写也是没错的</span></span><br></pre></td></tr></table></figure>
<p>所以从这个例子也可以看出，严格区分不同泛型类是很有必要的。<br>回到原来的案例，我想实现<code>addAll</code>方法能够传递<code>MyList&lt;Integer&gt;</code>怎么办？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E <span class="keyword">extends</span> <span class="title class_">T</span>&gt; <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(MyList&lt;E&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size; ++i) &#123;</span><br><span class="line">        add(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以实现了。</p>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><h5 id="有限定通配符"><a href="#有限定通配符" class="headerlink" title="有限定通配符"></a>有限定通配符</h5><p>通配符<code>?</code>大量应用于 Java 容器类里面，它往往能够简化参数类型的限定，下面我使用通配符简化上面<code>addAll</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(MyList&lt;? extends T&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size; ++i) &#123;</span><br><span class="line">        add(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法里面<code>?</code>是<strong>有限定通配符</strong>，它表示匹配<code>T</code>或<code>T</code>的某个子类，具体是哪个子类不知道，是一种抽象的概念。下面我们对比一下<code>&lt;E extends T&gt;</code>和<code>&lt;? extends T&gt;</code>：</p>
<ul>
<li><code>&lt;E entends T&gt;</code>用于定义类型参数，它声明了一个类型<code>E</code>。</li>
<li><code>&lt;? extends T&gt;</code>用于实例化类型参数，定义泛型变量的时候可以使用它。</li>
</ul>
<p>注意，通配符使用于定义变量的地方，就像上面的形参<code>MyList&lt;? extends T&gt; list</code>。</p>
<h5 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h5><p>除了有限定通配符，还有<strong>无限定通配符</strong><code>&lt;?&gt;</code>，它可以匹配任意<code>Object</code>及其子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(MyList&lt;E&gt; arr)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(MyList&lt;?&gt; arr)</span></span><br></pre></td></tr></table></figure>
<p>上面的两种写法可以得到一样的效果，所以通配符的一个好处就是可以简化泛型代码。但通配符并不是万能的，是有限制的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyList&lt;?&gt; list = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;Number&gt;();  <span class="comment">// 合法，? 可以匹配 Number</span></span><br><span class="line"></span><br><span class="line"><span class="type">Number</span> <span class="variable">n</span> <span class="operator">=</span> list.get(<span class="number">0</span>);  <span class="comment">// 错误，因为返回值类型是 ? 而不是 Number</span></span><br><span class="line"><span class="type">Number</span> <span class="variable">n</span> <span class="operator">=</span> (Number) list.get(<span class="number">0</span>);  <span class="comment">// 正确，我们知道实际类型是 Number，所以可以强转</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，因为形参需要 ? 而传递一个 Double；</span></span><br><span class="line"><span class="comment">// 这种情况下甚至无法强转，因为怎么把 Double 强转成 ?</span></span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">3.14</span>));</span><br><span class="line"></span><br><span class="line">list.add(list.get(<span class="number">0</span>));  <span class="comment">// 这样也不行</span></span><br></pre></td></tr></table></figure>
<p>其实添加这些限制也能理解，因为<code>list</code>的静态类型是<code>MyList&lt;?&gt;</code>，那么添加的时候即可以添加<code>Integer</code>也可以添加<code>String</code>，这很显然是不合理的。<br>总结下来，当我们关注泛型里的类型的时候就不能使用通配符，否则就使用通配符。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(T[] arr, T ele)</span></span><br></pre></td></tr></table></figure>
<p>这个函数就没办法写成通配符形式，因为我们需要<code>T</code>这个类型定义形参。<br>当需要多种类型且类型之间有依赖关系的时候也不能使用通配符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;D, S <span class="keyword">extends</span> <span class="title class_">D</span>&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(MyList&lt;D&gt; dest, MyList&lt;S&gt; src)</span></span><br></pre></td></tr></table></figure>
<p>虽然这种情况无法使用通配符完全替换，但可以使用通配符简化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;D&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(MyList&lt;D&gt; dest, MyList&lt;? extends D&gt; src)</span></span><br></pre></td></tr></table></figure>
<h5 id="超类型通配符"><a href="#超类型通配符" class="headerlink" title="超类型通配符"></a>超类型通配符</h5><p>与<code>&lt;? extends T&gt;</code>刚好相反，超类型通配符形式为<code>&lt;? super T&gt;</code>，它匹配<code>T</code>的某种父类型。举个例子，我们希望在上面列表里面加一个方法<code>copyTo</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyTo</span><span class="params">(MyList&lt;T&gt; dest)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        dest.add(get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法就是把列表里面的元素全部添加到<code>dest</code>列表里面。我们写出下面的测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyList&lt;Integer&gt; ints = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;&gt;();</span><br><span class="line">MyList&lt;Number&gt; numbers = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;&gt;();</span><br><span class="line">ints.copyTo(number);  <span class="comment">// 编译出错</span></span><br></pre></td></tr></table></figure>
<p>方法需要的是<code>MyList&lt;Integer&gt;</code>但实参是<code>MyList&lt;Number&gt;</code>，类型不匹配。但实际上把一堆<code>Integer</code>存到<code>Number</code>数组里面是很合理的操作，此时只需要把形参改为<code>MyList&lt;? super T&gt; dest</code>即可。<br> 超通配符的另一种常见使用场景是<code>Comparable/Comparator</code>接口。我们先定义一个求最大值的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;E&gt;&gt; E <span class="title function_">max</span><span class="params">(MyList&lt;E&gt; arr)</span> &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">ans</span> <span class="operator">=</span> arr.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.size; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.get(i).compareTo(ans) &gt; <span class="number">0</span>) ans = arr.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再定义两个类，分别为<code>Base</code>和<code>Child</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Base&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sortOrder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">(<span class="type">int</span> sortOrder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sortOrder = sortOrder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Base o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortOrder - o.sortOrder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">(<span class="type">int</span> sortOrder)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(sortOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Base</code>实现了<code>Comparable&lt;Base&gt;</code>，<code>Child</code>没做特别说明，因为继承所以默认也是实现了<code>Comparable&lt;Base&gt;</code>。下面我们使用测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyList&lt;Child&gt; childs = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;&gt;();</span><br><span class="line">childs.add(<span class="keyword">new</span> <span class="title class_">Child</span>(<span class="number">20</span>));</span><br><span class="line">childs.add(<span class="keyword">new</span> <span class="title class_">Child</span>(<span class="number">80</span>));</span><br><span class="line"><span class="type">Child</span> <span class="variable">maxChild</span> <span class="operator">=</span> MyList.max(childs);  <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure>
<p>我们想求<code>Child</code>列表里的最大值，所以把<code>childs</code>作为参数传进<code>max</code>方法。<code>max</code>解析的时候认为<code>E</code>是<code>Child</code>，而<code>Child</code>类并不满足<code>&lt;E extends Comparable&lt;E&gt;&gt;</code>。即<code>Child</code>并没有实现<code>Comparable&lt;Child&gt;</code>，而实际上我们知道这边父类的比较规则完全可以适配到子类上来，对<code>Child</code>列表找最大值是很合理的操作。因此修改函数签名为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> E&gt;&gt; E <span class="title function_">max</span><span class="params">(MyList&lt;E&gt; arr)</span></span><br></pre></td></tr></table></figure>
<p>只有在通配符才能使用<code>super</code>表示父级，常规的类型参数写法是不支持这样的。</p>
<h5 id="通配符小结"><a href="#通配符小结" class="headerlink" title="通配符小结"></a>通配符小结</h5><p>目前一共介绍了<code>&lt;?&gt;</code>、<code>&lt;? extends E&gt;</code>、<code>&lt;? super E&gt;</code>这三种通配符，下面进行比较：</p>
<ol>
<li>它们的目的都是为了使接口或方法更灵活，可以接受更广的类型。</li>
<li><code>&lt;? super E&gt;</code>用于灵活写入或比较，使对象可以写进父类型的容器，使父类型的比较方法可以应用于子类型，它不能被类型参数形式代替。</li>
<li><code>&lt;? extends E&gt;</code>用于灵活读取，使方法可以读取任何<code>E</code>及其子类型的容器对象，它可以用类型参数形式替代，但用通配符更简洁。</li>
</ol>
<p>Java 里面有很多通配符的例子，在<code>Collections</code>类中就有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">max</span><span class="params">(Collection&lt;? extends T&gt; coll, Comparator&lt;? <span class="built_in">super</span> T&gt; comp)</span></span><br></pre></td></tr></table></figure>
<h4 id="细节和局限"><a href="#细节和局限" class="headerlink" title="细节和局限"></a>细节和局限</h4><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><p>因为 Java 泛型本质上是擦除，是将类型改为<code>Object</code>或上限类型。所以泛型里面不能使用基本数据类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyList&lt;<span class="type">int</span>&gt; ints = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;<span class="type">int</span>&gt;();  <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>
<p>这种写法是错误的，不能使用基本数据类型作为泛型参数。对于这个问题我们可以使用基本数据类型对应的包装类型。</p>
<h5 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h5><p>之前讲过，每个类在内存里都有一份类型信息，而创建出来的每一个对象都包含着这个类型信息的引用。这个类型信息实际上也是一个对象，它的类型是<code>Class</code>，我们可以通过<code>类名.class</code>或<code>对象.getClass()</code>来获取类信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; cs = <span class="string">&quot;&quot;</span>.getClass();</span><br><span class="line">Class&lt;?&gt; cs2 = String.class;</span><br></pre></td></tr></table></figure>
<p>注意，类型信息与泛型无关，所以类似于<code>Pair&lt;Integer&gt;.class</code>的写法是错误的，我们应该直接使用<code>Pair.class</code>。同一个泛型类的对象即使泛型不同，它们获取的类信息是一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer&gt; p1 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;();</span><br><span class="line">Pair&lt;String&gt; p2 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;();</span><br><span class="line">print(Pair.class == p1.getClass());  <span class="comment">//true</span></span><br><span class="line">print(p1.getClass() == p2.getClass());  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>原因很简单，类型擦除会将所有类型改为<code>Object</code>，所以即使泛型不一样，类信息实际上是一样的。</p>
<h5 id="一些冲突"><a href="#一些冲突" class="headerlink" title="一些冲突"></a>一些冲突</h5><p>我们看之前的一个例子，有两个类<code>Base</code>和<code>Child</code>，它们的签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Base&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span></span><br></pre></td></tr></table></figure>
<p>这边<code>Child</code>没有直接实现<code>Comparable</code>接口，比较使用的是父类那一套逻辑。如果子类的比较需要自定义怎么办，直觉上可以让子类再实现一次：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Child&gt; &#123;</span><br><span class="line">	<span class="comment">// 主体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但实际上是错误的，因为一个接口不能实现两次。当子类继承父类的时候默认就实现了一次接口，这边再实现就重复了。注意<code>Comparable&lt;Base&gt;</code>和<code>Comparable&lt;Child&gt;</code>是同一个接口，因为类型擦除之后它们都相当于<code>Comparable</code>。那我却是需要修改怎么办呢？可以重写接口方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Base o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Child))&#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> (Child)o;</span><br><span class="line">        <span class="comment">// 比较逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后关于重载，你可能会认为下面的重载是成立的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(MyList&lt;Integer&gt; intArr)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(MyList&lt;String&gt; strArr)</span></span><br></pre></td></tr></table></figure>
<p>实际上是不成立的，仍然是类型擦除搞的鬼。擦完之后，两个方法的形参类型都变为了<code>MyList</code>，所以重载失败。</p>
<h5 id="定义泛型类"><a href="#定义泛型类" class="headerlink" title="定义泛型类"></a>定义泛型类</h5><p>不能使用类型参数创建对象，如下代码是错误的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">T</span> <span class="variable">elm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();  <span class="comment">// 错误</span></span><br><span class="line">T[] arr = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">10</span>];  <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>其实很好理解，当我们写这样的代码的时候，我们预期是创建对应类型的对象，但实际上因为类型擦除创建的却是<code>Object</code>对象，产生了冲突。<br>除此之外，静态变量或静态方法里面不能使用类型参数，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> T elm;  <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title function_">func</span><span class="params">()</span> &#123;  <span class="comment">// 错误</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态变量和静态方法是属于类级别的，不管有多少对象都共享这一份。如果允许上面的写法，那么对于不同的类型<code>T</code>都需要一份对应的静态变量或方法，这就冲突了。<br>Java 泛型的上限可以有多个的，多个上限之间使用<code>&amp;</code>分隔：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> <span class="title class_">Base</span> &amp; Comparable &amp; Serializable</span><br></pre></td></tr></table></figure>
<p>如果有上界类，那么类应该放第一个。类型擦除的时候会使用第一个上界替换。</p>
<h5 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h5><p>泛型是不能创数组的，例如下面的代码是不允许的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer&gt;[] list = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;Integer&gt;[<span class="number">5</span>];  <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>为什么不允许呢？如果是允许的，那么下面的代码就是对的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] os = list;</span><br><span class="line">os[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String&gt;();  <span class="comment">// 类型和一开始定义的就不同了</span></span><br></pre></td></tr></table></figure>
<p>这很显然就出现问题了，所以泛型是不允许创建数组的，如果真的需要怎么办？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair[] list = <span class="keyword">new</span> <span class="title class_">Pair</span>[<span class="number">5</span>];</span><br><span class="line">MyList&lt;Pair&lt;String&gt;&gt; options = <span class="keyword">new</span> <span class="title class_">MyList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>我们可以直接使用原始类型的数组替代，或者使用容器类。</p>
<h3 id="列表和队列"><a href="#列表和队列" class="headerlink" title="列表和队列"></a>列表和队列</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p><code>ArrayList</code>是泛型容器，和我们上面实现的<code>MyList</code>类似但更强：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p><code>ArrayList</code>的主要方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>  <span class="comment">// 添加元素到末尾</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>  <span class="comment">// 判断容器 size 是否为 0</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>  <span class="comment">//឴ 返回元素个数</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>  <span class="comment">// 返回下标 index 处的元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span>  <span class="comment">// 查找元素，找到返回下标否则返回 -1</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span>  <span class="comment">// 从后往前查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>  <span class="comment">// 判断元素是否存在于容器里面，使用 equals 作为依据</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>  <span class="comment">// 删除指定下标的元素并返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定元素，使用 equals 作为依据，返回是否删除了元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>  <span class="comment">// 删除全部元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>  <span class="comment">// 在指定下标处插入元素</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span>  <span class="comment">// 修改指定位置的元素</span></span><br></pre></td></tr></table></figure>
<p>方法及使用很简单，不多说。</p>
<h5 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h5><p>和我们上面实现的<code>MyList</code>类似，<code>ArrayList</code>内部也是维护一个数组存储数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure>
<p><code>elementData</code>就是存储数据的数组，会随着元素的增加而扩增；<code>size</code>表示元素的个数。</p>
<h6 id="add和remove"><a href="#add和remove" class="headerlink" title="add和remove"></a>add和remove</h6><p>数组的<code>add</code>方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">	<span class="comment">// 确保容量充足</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 分配的空间最少也要 DEFAULT_CAPACITY 个，默认是 10 个</span></span><br><span class="line">    <span class="keyword">if</span>(elementData == EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    	minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span>(minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    	grow(minCapacity);  <span class="comment">// 分配空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// &gt;&gt;1 等价于 ÷2，所以扩容为原来的 1.5 倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 容量不足 minCapacity 就使用 minCapacity</span></span><br><span class="line">    <span class="keyword">if</span>(newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    	newCapacity = minCapacity;</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面<code>modCount</code>变量用来记录内部结构性变化的次数，结构性变化包含增加和删除，修改元素不算。<br>数组<code>remove</code>方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">	<span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;  <span class="comment">// 计算要移动的元素个数</span></span><br><span class="line">    <span class="keyword">if</span>(numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    	System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>;  <span class="comment">// 置 null 取消引用便于垃圾回收</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h6><p>除了普通 for 循环，我们还可以使用 foreach 循环来遍历<code>ArrayList</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;卢研&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;刘妙霞&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String name : list) &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上背后编译器会把代码转化成下面的样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但我们会更倾向于使用 	foreach 循环，因为它更简洁。<br><code>ArrayList</code>实现了<code>Iterable</code>接口，它表示可迭代的。定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">	Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口内有一个方法需要返回<code>Iterator&lt;T&gt;</code>即迭代器，迭代器内部包含：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;  <span class="comment">// 是否还有元素未访问</span></span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;  <span class="comment">// 返回下一个元素</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;  <span class="comment">// 删除最后访问的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要类实现了<code>Iterable</code>接口就可以使用 foreach 循环遍历。除了<code>iterator()</code>方法，<code>ArrayList</code>还提供了两个<code>listIterator</code>方法用来返回<code>ListIterator</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span></span><br></pre></td></tr></table></figure>
<p><code>ListIterator</code>是对<code>Iterator</code>的扩展，主要添加了以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ListIterator</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">previous</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>listIterator()</code>方法返回的迭代器从下标<code>0</code>开始，<code>listIterator(int index)</code>方法返回的迭代器从指定下标<code>index</code>开始。当我们想要倒序遍历的时候，可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ListIterator&lt;String&gt; it = list.listIterator(list.size());</span><br><span class="line"><span class="keyword">while</span> (it.hasPrevious()) &#123;</span><br><span class="line">    System.out.println(it.previous());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="迭代的陷阱"><a href="#迭代的陷阱" class="headerlink" title="迭代的陷阱"></a>迭代的陷阱</h6><p>假设我们有需求，在一个整型<code>ArrayList</code>里面，我想在遍历的同时删除值小于 100 的元素，我们的直觉是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">99</span>);</span><br><span class="line">list.add(<span class="number">100</span>);</span><br><span class="line">list.add(<span class="number">101</span>);</span><br><span class="line"><span class="keyword">for</span> (Integer a : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= <span class="number">100</span>) list.remove(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是运行的时候会报错<code>java.util.ConcurrentModificationException</code>，这个称为并发修改错误。因为迭代器内部维护了一些与索引相关的变量，这要求在迭代的过程中列表不能发生结构性变化（增加和删除），否则这些变量就失效了。想要避免异常可以这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it.next() &lt; <span class="number">100</span>) it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于它是怎么在迭代过程中知道列表发生了结构性变化以及为什么它自己的<code>remove</code>方法就可以避免，看下面迭代器的原理。</p>
<h6 id="迭代器的原理"><a href="#迭代器的原理" class="headerlink" title="迭代器的原理"></a>迭代器的原理</h6><p>我们看<code>ArrayList</code>的<code>iterator()</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它返回了<code>Itr</code>对象，这是一个静态内部类，它的签名是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>这个类有 3 个实例成员变量，分别是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cursor;  <span class="comment">// 下一个要返回元素的下标</span></span><br><span class="line"><span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>;  <span class="comment">// 最后访问元素的下标，默认是 -1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;  <span class="comment">// 记录当前列表经历结构性变化的次数</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是<code>expectedModCount</code>变量，每次调用<code>next()</code>方法最开始都会比对<code>expectedModCount</code>和<code>modCount</code>，用来检查列表在遍历期间是否有结构性变化。<br>接下来我们看<code>hasNext()</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> cursor != size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个非常容易理解，不多说。下面是<code>next()</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= size)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= elementData.length)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(modCount != expectedModCount)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>checkForComodification</code>方法判断列表是否发生结构性变化；<code>next</code>方法更新对应索引并返回访问的元素。<br>最后看看<code>remove()</code>方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(lastRet &lt; <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码不难，主要是更新几个变量。因为使用这个方法删除会更新<code>expectedModCount</code>所以不会因为发生结构性变化而报错。但是有一点需要注意，每次删除之后都会将<code>lastRet</code>置为 -1，所以下面继续删除会抛异常。因此我们每次调用<code>remove</code>方法之前必须先调用<code>next</code>方法。</p>
<h5 id="实现的接口"><a href="#实现的接口" class="headerlink" title="实现的接口"></a>实现的接口</h5><h6 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h6><p><code>Collection</code>是集合接口，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>;</span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    Object[] toArray();</span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大部分方法我们都看过，下面介绍几个<code>xxxAll</code>方法：</p>
<ol>
<li><code>addAll</code>方法表示添加参数集合<code>c</code>中的所有元素。</li>
<li><code>removeAll</code>方法删除所有存在于参数集合<code>c</code>里的元素。</li>
<li><code>retainAll</code>方法仅保留存在于参数集合<code>c</code>里的元素。</li>
<li><code>containsAll</code>方法返回当前集合是否完全包含给定的集合<code>c</code>。</li>
</ol>
<p>上面的方法涉及比较的时候都是使用<code>equals</code>进行比较。</p>
<h6 id="List"><a href="#List" class="headerlink" title="List"></a>List</h6><p><code>List</code>表示有顺序的集合，是对<code>Collection</code>的扩展，主要增加了以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span>;</span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>;</span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span>;</span><br><span class="line">ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span>;</span><br><span class="line">ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span>;</span><br></pre></td></tr></table></figure>
<h6 id="RandomAccess"><a href="#RandomAccess" class="headerlink" title="RandomAccess"></a>RandomAccess</h6><p><code>RandomAccess</code>是随机访问接口，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RandomAccess</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个空接口，主要用来声明类具有一种性质，这边主要表示实现的类具有随机访问的性质。</p>
<h5 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h5><p><code>ArrayList</code>还有额外的两个有参构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>第一个构造能传递一个初始化数组大小进去，在一些能够提前预知列表大小的时候可以使用。第二个构造会根据一个已有的<code>Collection</code>创建，数据会复制一份。<br><code>ArrayList</code>有两个方法可以返回数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray()</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a)</span><br></pre></td></tr></table></figure>
<p>第一个方法直接返回一个<code>Object</code>数组，它的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">	<span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个方法返回对应类型的数组，若是传递的数组<code>a</code>够大就把元素复制进去，要是不够大就新开一个数组返回，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">// Make a new array of a&#x27;s runtime type, but my contents:</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Arrays</code>类中有一个静态方法<code>asList</code>可以将数组转换成列表，但是返回的列表不是我们这边的<code>ArrayList</code>，而是<code>Arrays</code>类里面的一个内部类。在这个内部类的实现中，数组直接使用传进去的数组，也不能动态改变大小，对它调用<code>add</code>和<code>remove</code>会抛异常。因此正确使用<code>asList</code>的方法应该是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(a));</span><br></pre></td></tr></table></figure>
<p>除此之外，还有两个方法用来控制内部数组的大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span></span><br></pre></td></tr></table></figure>
<p>第一个方法会将大小缩减到和元素个数一样多，用来节省空间；第二个方法用来确保列表大小至少为<code>minCapacity</code>，如果不够会进行扩展。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><code>**ArrayList**</code><strong>是线程不安全的</strong>，<code>Vector</code>是一个原理和<code>ArrayList</code>差不多但使用<code>synchronized</code>关键字实现线程安全的类。<code>ArrayList</code>有以下几个特点：</p>
<ol>
<li>因为内部使用数组，所以可以随机访问，按照下标获取元素效率很高。</li>
<li>添加元素效率一般，不超出容量的时候很快，超出容量要重开数组空间较慢。</li>
<li>插入和删除元素很慢，因为需要移动元素。</li>
</ol>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p><code>LinkedList</code>是基于链表实现的列表类，它随机访问效率很低，但插入和删除效率很高。它除了实现<code>List</code>接口还实现了<code>Deque</code>和<code>Queue</code>接口。可以按照栈、队列、双端队列的方式操作它。</p>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><h6 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h6><p><code>LinkedList</code>有两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>第一个是默认的构造，第二个接受一个集合作为参数。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;));</span><br></pre></td></tr></table></figure>
<h6 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h6><p><code>LinkedList</code>实现了<code>List</code>接口，<code>List</code>扩展了<code>Collection</code>接口，所以这些接口里的方法都是可以使用的。除此之外，还实现了<code>Queue</code>接口，下面看看接口内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>;</span><br><span class="line">    E <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">poll</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">element</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">peek</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Queue</code>扩展了<code>Collection</code>接口，主要的操作有三种：</p>
<ol>
<li>在尾部添加元素（<code>add</code>、<code>offer</code>）；</li>
<li>删除并返回头部元素（<code>remove</code>、<code>poll</code>）；</li>
<li>查看头部元素（<code>element</code>、<code>peek</code>）；</li>
</ol>
<p>每种操作都有两个方法实现，它们的主要差别就是当队列为空或为满的时候，一种会报错，另一种不会：</p>
<ul>
<li>队列为空时<code>element、remove</code>会抛异常<code>NoSuchElementException</code>，而<code>peek、poll</code>则是返回<code>null</code>。</li>
<li>队列满的时候<code>add</code>抛异常<code>IllegalStateException</code>，而<code>offer</code>则是返回<code>false</code>。</li>
</ul>
<p>把<code>LinkedList</code>当做队列操作的简单例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">queue.offer(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">queue.offer(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">queue.offer(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(queue.peek()!=<span class="literal">null</span>)&#123;</span><br><span class="line">	System.out.println(queue.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h6><p>栈是另一种使用比较频繁的数据结构，它的特点是后进先出。栈没有单独的接口，它的一些操作定义在双端队列<code>Deque</code>中，主要方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span>;  <span class="comment">// 头部添加元素，栈满则抛 IllegalStateException 异常</span></span><br><span class="line">E <span class="title function_">pop</span><span class="params">()</span>;  <span class="comment">// 删除并返回头部元素，栈为空抛 NoSuchElementException 异常</span></span><br><span class="line">E <span class="title function_">peek</span><span class="params">()</span>;  <span class="comment">// 查看栈头部元素，栈为空返回 null</span></span><br></pre></td></tr></table></figure>
<p>把<code>LinkedList</code>当做栈操作的简单例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">stack.push(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(stack.peek()!=<span class="literal">null</span>)&#123;</span><br><span class="line">	System.out.println(stack.pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 里有<code>Stack</code>类表示栈，这个类是<code>Vector</code>的子类，没有实现<code>Deque</code>。它使用<code>synchronized</code>关键字实现了线程安全，也因此操作效率低，所以不要求线程安全的情况下不建议使用。</p>
<h6 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h6><p><code>Deque</code>可以操作两端，除了栈操作，它还定义了如下更明确的双端操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span>;</span><br><span class="line">E <span class="title function_">getFirst</span><span class="params">()</span>;</span><br><span class="line">E <span class="title function_">getLast</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span>;</span><br><span class="line">E <span class="title function_">peekFirst</span><span class="params">()</span>;</span><br><span class="line">E <span class="title function_">peekLast</span><span class="params">()</span>;</span><br><span class="line">E <span class="title function_">pollFirst</span><span class="params">()</span>;</span><br><span class="line">E <span class="title function_">pollLast</span><span class="params">()</span>;</span><br><span class="line">E <span class="title function_">removeFirst</span><span class="params">()</span>;</span><br><span class="line">E <span class="title function_">removeLast</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p><code>xxxFirst</code>表示操作头部，<code>xxxLast</code>表示操作尾部。每种操作有两种形式，含义和上面一样，一种会报错，一种不会。队列空时，使用<code>getXXX</code>或<code>removeXXX</code>会抛异常，而<code>peekXXX</code>或<code>pollXXX</code>则会返回<code>null</code>；队列满时，使用<code>addXXX</code>会抛异常，而使用<code>offerXXX</code>会返回<code>false</code>。<br><code>Deque</code>还有一个迭代器方法，可以返回一个从后往前遍历的迭代器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; <span class="title function_">descendingIterator</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><code>LinkedList</code>内部实现使用的是双向链表，链表节点是一个内部类，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LinkedList</code>内部主要维护三个成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 节点数量</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;  <span class="comment">// 头节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;  <span class="comment">// 为节点</span></span><br></pre></td></tr></table></figure>
<p>下面主要看一些函数的源码。</p>
<h6 id="add"><a href="#add" class="headerlink" title="add"></a>add</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="literal">null</span>)</span><br><span class="line">    	first = newNode;</span><br><span class="line">    <span class="keyword">else</span> l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出<code>add</code>是直接往尾部插入一个节点，与<code>ArrayList</code>类似，<code>modCount</code>也是用来记录链表结构化改变次数的。</p>
<h6 id="get"><a href="#get" class="headerlink" title="get"></a>get</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(index);  <span class="comment">// 检查要插入的下标是否合法</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkElementIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!isElementIndex(index))</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isElementIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">   		Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">        	x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">        x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>get</code>方法的核心是调用<code>node(index)</code>方法，这个方法会判断要查找下标在链表的前半段还是后半段，然后确定从前往后还是从后往前查找。从这也能看出，链表的随机访问效率是很低的。</p>
<h6 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span>(x.item == <span class="literal">null</span>)</span><br><span class="line">            	<span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span>(o.equals(x.item))</span><br><span class="line">            	<span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按元素查找就是直接从前往后查找，使用<code>equals</code>判断元素是否相同。</p>
<h6 id="插入-add"><a href="#插入-add" class="headerlink" title="插入 add"></a>插入 add</h6><p><code>add</code>还有一个重载方法表示在指定下标处插入，源码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="keyword">if</span>(index == size)</span><br><span class="line">    	linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span>(pred == <span class="literal">null</span>)</span><br><span class="line">    	first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，找到要插入位置的元素，在其前面插入。</p>
<h6 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">    <span class="keyword">if</span>(prev == <span class="literal">null</span>) &#123;</span><br><span class="line">    	first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(next == <span class="literal">null</span>) &#123;</span><br><span class="line">    	last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单总结：<code>ArrayList</code>使用数组实现，因此比较适合频繁需要按照下标访问元素的情况，不适合大量删除或插入的情况；<code>LinkedList</code>相反，适合频繁插入或删除而不适合随机访问的情况。</p>
<h4 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h4><p>除了<code>LinkedList</code>，Java 里还有一个类<code>ArrayDeque</code>实现了双向队列<code>Deque</code>。<code>ArrayDeque</code>内部使用数组存储数据，按道理说对于删除和添加数组效率很低。但<code>ArrayList</code>使用循环数组提高效率，所谓循环数组就是在逻辑上将数组尾部与数组头部相连。</p>
<h5 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h5><p><code>ArrayDeque</code>有三种构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(<span class="type">int</span> numElements)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>这些构造的含义很好推测，不过对于有参构造，传递进去的<code>numElements</code>并不直接是数组的大小。<br>因为实现了<code>Deque</code>，所以对于栈运用<code>push、pop、peek</code>方法，也有明确的双端队列的方法<code>addFirst</code>等，这些方法及用法和上面讲的是一样的，不多说。</p>
<h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><h6 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h6><p><code>ArrayDeque</code>主要维护下面几个成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> E[] elements;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> tail;</span><br></pre></td></tr></table></figure>
<p>我们将数组逻辑上看成一个环，然后通过移动<code>head</code>和<code>tail</code>来避免删除时大量移动剩余元素。Java 的循环数组将<code>tail</code>理解成下一个元素的下标，因此当<code>head = tail</code>时表示队列为空。<br>下面看看各构造的内部实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">()</span> &#123;</span><br><span class="line">	elements = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">16</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出无参构造默认分配 16 个空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(<span class="type">int</span> numElements)</span> &#123;</span><br><span class="line">	allocateElements(numElements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个构造调用<code>allocateElements</code>方法来分配空间，分配空间大小逻辑比较复杂，总结来说：至少分配 8 个空间，需要的大于等于 8 个时，分配的个数一定是 2 的次幂且严格大于需要的空间数。举个例子：<code>4=&gt;8</code>、<code>8=&gt;16</code>、<code>25=&gt;32</code>。为什么要严格大于所需的空间，因为循环数组的性质决定了能使用的空间数等于分配的空间数减一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    allocateElements(c.size());</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先按需分配空间，再将集合的元素添加到队列中，<code>addAll</code>内部就是循环调用<code>add</code>方法。</p>
<h6 id="add-1"><a href="#add-1" class="headerlink" title="add"></a>add</h6><p><code>add</code>是往尾部添加元素，看下面源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(e == <span class="literal">null</span>)  <span class="comment">// 不能添加 null</span></span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    elements[tail] = e;</span><br><span class="line">    <span class="keyword">if</span>( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)</span><br><span class="line">    	doubleCapacity();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doubleCapacity</span><span class="params">()</span> &#123;  <span class="comment">// 这个函数执行的时候 head 和 tail 是重合的</span></span><br><span class="line">    <span class="keyword">assert</span> head == tail;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> elements.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> n - p;  <span class="comment">// number of elements to the right of p</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Sorry, deque too big&quot;</span>);</span><br><span class="line">    Object[] a = <span class="keyword">new</span> <span class="title class_">Object</span>[newCapacity];</span><br><span class="line">    System.arraycopy(elements, p, a, <span class="number">0</span>, r);  <span class="comment">// 先复制 head 后面的</span></span><br><span class="line">    System.arraycopy(elements, <span class="number">0</span>, a, r, p);  <span class="comment">// 再复制 tail 前面的</span></span><br><span class="line">    elements = (E[])a;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    tail = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出队列里面的元素都不为<code>null</code>，需要注意的是<code>tail = (tail+1) &amp; (elements.length-1)</code>。因为是循环数组，所以下标<code>n-1</code>后一个下标是<code>0</code>，<code>0</code>前一个下标是<code>n-1</code>。实现这个功能，我第一个想到的是使用<code>%</code>，但<code>%</code>效率很低，<strong>这边的写法需要配合数组容量是 2 的次幂</strong>。<br>假设数组容量是 8，那么<code>elements.length-1</code>的二进制就是<code>0111</code>。任何一个<code>0-7</code>以内的数与<code>0111</code>相与的结果都是这个数本身，相当于没做操作。考虑特殊情况，<code>tail=7</code>时，此时<code>tail+1=8=1000</code>，与<code>0111</code>相与结果是<code>0</code>；<code>tail=0</code>时，此时<code>tail-1=-1=1111</code>，与<code>0111</code>相与的结果是<code>7</code>。综上所述，<code>(tail±1) &amp; (elements.length-1)</code>都可以得出正确的位置。</p>
<h6 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst"></a>addFirst</h6><p><code>addFirst</code>是头部添加元素的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(e == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;</span><br><span class="line">    <span class="keyword">if</span>(head == tail) doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="removeFirst"><a href="#removeFirst" class="headerlink" title="removeFirst"></a>removeFirst</h6><p><code>removeFirst</code>是头部删除函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> pollFirst();</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> elements[h]; <span class="comment">//Element is null if deque empty</span></span><br><span class="line">    <span class="keyword">if</span>(result == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    elements[h] = <span class="literal">null</span>; <span class="comment">//Must null out slot</span></span><br><span class="line">    head = (h + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="size"><a href="#size" class="headerlink" title="size"></a>size</h6><p><code>size</code>是获取元素个数的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (tail - head) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h6><p><code>contains</code>方法用来判断元素是否存在于队列中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(o == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> elements.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> head;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">while</span>( (x = elements[i]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(o.equals(x))</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        i = (i + <span class="number">1</span>) &amp; mask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>head</code>开始遍历，使用<code>equals</code>方法作为比较依据。这边使用<code>null</code>作为结束标记而不是<code>tail</code>，因为有效元素一定不是<code>null</code>。</p>
<h6 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h6><p><code>toArray</code>方法返回队列数组的副本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">	<span class="keyword">return</span> copyElements(<span class="keyword">new</span> <span class="title class_">Object</span>[size()]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; T[] copyElements(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span>(head &lt; tail) &#123;</span><br><span class="line">    	System.arraycopy(elements, head, a, <span class="number">0</span>, size());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(head &gt; tail) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">headPortionLen</span> <span class="operator">=</span> elements.length - head;</span><br><span class="line">        System.arraycopy(elements, head, a, <span class="number">0</span>, headPortionLen);</span><br><span class="line">        System.arraycopy(elements, <span class="number">0</span>, a, headPortionLen, tail);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>head &gt; tail</code>的情况，先复制后面再复制前面的部分。这样能保证返回的数组元素是原来的顺序。<br>因为<code>Deque</code>接口里面没有根据下标的操作，所以<code>ArrayDeque</code>也不能按照索引操作数据。一般而言，<code>ArrayDeque</code>效率优于<code>LinkedList</code>，所有我们应该优先使用<code>ArrayList</code>。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag"># 后端</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2023/04/02/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8803%EF%BC%89/" rel="next" title="Java 基础系列（03）">
                <i class="fa fa-chevron-left"></i> Java 基础系列（03）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2023/04/20/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8805%EF%BC%89/" rel="prev" title="Java 基础系列（05）">
                Java 基础系列（05） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/index.html">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.</span> <span class="nav-text">简单使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">1.2.</span> <span class="nav-text">基本原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">泛型方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.4.</span> <span class="nav-text">泛型接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E9%99%90%E5%AE%9A"><span class="nav-number">1.5.</span> <span class="nav-text">类型参数限定</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8A%E7%95%8C%E6%98%AF%E5%85%B7%E4%BD%93%E7%B1%BB"><span class="nav-number">1.5.1.</span> <span class="nav-text">上界是具体类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8A%E7%95%8C%E6%98%AF%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.5.2.</span> <span class="nav-text">上界是接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8A%E7%95%8C%E6%98%AF%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-number">1.5.3.</span> <span class="nav-text">上界是其它类型参数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">1.6.</span> <span class="nav-text">通配符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">1.6.1.</span> <span class="nav-text">有限定通配符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">1.6.2.</span> <span class="nav-text">无限定通配符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B6%85%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">1.6.3.</span> <span class="nav-text">超类型通配符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E5%B0%8F%E7%BB%93"><span class="nav-number">1.6.4.</span> <span class="nav-text">通配符小结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%86%E8%8A%82%E5%92%8C%E5%B1%80%E9%99%90"><span class="nav-number">1.7.</span> <span class="nav-text">细节和局限</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.7.1.</span> <span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Class"><span class="nav-number">1.7.2.</span> <span class="nav-text">Class</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%86%B2%E7%AA%81"><span class="nav-number">1.7.3.</span> <span class="nav-text">一些冲突</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="nav-number">1.7.4.</span> <span class="nav-text">定义泛型类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="nav-number">1.7.5.</span> <span class="nav-text">泛型数组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-number">2.</span> <span class="nav-text">列表和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList"><span class="nav-number">2.1.</span> <span class="nav-text">ArrayList</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">2.1.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-1"><span class="nav-number">2.1.2.</span> <span class="nav-text">基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#add%E5%92%8Cremove"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">add和remove</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">迭代</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E7%9A%84%E9%99%B7%E9%98%B1"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">迭代的陷阱</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">迭代器的原理</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.1.3.</span> <span class="nav-text">实现的接口</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Collection"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">Collection</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#List"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#RandomAccess"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">RandomAccess</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.4.</span> <span class="nav-text">其它方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.1.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList"><span class="nav-number">2.2.</span> <span class="nav-text">LinkedList</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%B3%95"><span class="nav-number">2.2.1.</span> <span class="nav-text">用法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E9%80%A0"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">构造</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="nav-number">2.2.1.4.</span> <span class="nav-text">双端队列</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.2.</span> <span class="nav-text">原理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#add"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">add</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#get"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">get</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#indexOf"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">indexOf</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%92%E5%85%A5-add"><span class="nav-number">2.2.2.4.</span> <span class="nav-text">插入 add</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#remove"><span class="nav-number">2.2.2.5.</span> <span class="nav-text">remove</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayDeque"><span class="nav-number">2.3.</span> <span class="nav-text">ArrayDeque</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">构造</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-1"><span class="nav-number">2.3.2.</span> <span class="nav-text">原理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E9%80%A0-2"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">构造</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#add-1"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">add</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#addFirst"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">addFirst</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#removeFirst"><span class="nav-number">2.3.2.4.</span> <span class="nav-text">removeFirst</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#size"><span class="nav-number">2.3.2.5.</span> <span class="nav-text">size</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#contains"><span class="nav-number">2.3.2.6.</span> <span class="nav-text">contains</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#toArray"><span class="nav-number">2.3.2.7.</span> <span class="nav-text">toArray</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lu Yan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
