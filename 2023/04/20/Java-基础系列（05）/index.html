<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java,后端," />










<meta name="description" content="Map &amp; Set总述Map维护的是键到值的映射关系，键是不能重复的，但值可以。访问的时候给定一个键，返回这个键对应的值。给同一个键重复设值，新值会覆盖旧值。接口定义如下： 123456789101112131415161718192021222324public interface Map&lt;K,V&gt; &#123;  &#x2F;&#x2F; K、V 是类型参数，分别表示键和值的类型    V p">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 基础系列（05）">
<meta property="og:url" content="http://example.com/2023/04/20/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8805%EF%BC%89/index.html">
<meta property="og:site_name" content="Luyan&#39;s Bolg">
<meta property="og:description" content="Map &amp; Set总述Map维护的是键到值的映射关系，键是不能重复的，但值可以。访问的时候给定一个键，返回这个键对应的值。给同一个键重复设值，新值会覆盖旧值。接口定义如下： 123456789101112131415161718192021222324public interface Map&lt;K,V&gt; &#123;  &#x2F;&#x2F; K、V 是类型参数，分别表示键和值的类型    V p">
<meta property="og:locale">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703648545502-48d8e98e-7d30-4124-97e7-7110903b2af5.png#averageHue=%23d8d8d8&clientId=u2e2c9feb-4180-4&from=paste&height=102&id=u3d63d8e1&originHeight=102&originWidth=601&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31160&status=done&style=none&taskId=ue89ce0a7-21bc-412a-a071-e3086619b0f&title=&width=601">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703830772252-25bb81af-ee4e-48ae-ac55-3704b0125d0d.png#averageHue=%23f8f8f8&clientId=u934a904e-b132-4&from=paste&height=194&id=u028b7d8b&originHeight=528&originWidth=978&originalType=binary&ratio=2&rotation=0&showTitle=false&size=154093&status=done&style=none&taskId=u64edecb3-23c4-49c9-a354-7d8c2cf0b82&title=&width=360">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703830824298-c5b974e8-52f4-41f0-a562-092f60fe8e9e.png#averageHue=%23f8f8f8&clientId=u934a904e-b132-4&from=paste&height=194&id=ue24b42ca&originHeight=702&originWidth=1040&originalType=binary&ratio=2&rotation=0&showTitle=false&size=168948&status=done&style=none&taskId=ueaa73243-2fd6-41ad-a799-ead44df8854&title=&width=287">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703832887812-70b3fd55-b329-4077-8914-a1862a5d9d09.png#averageHue=%23fbfbfb&clientId=u934a904e-b132-4&from=paste&height=250&id=u76817a50&originHeight=504&originWidth=830&originalType=binary&ratio=2&rotation=0&showTitle=false&size=118276&status=done&style=none&taskId=ub5c048e7-b402-4c9d-ae52-bebc0f591da&title=&width=412">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703832899714-f044e380-9169-454c-a712-928ae02316b8.png#averageHue=%23fbfbfb&clientId=u934a904e-b132-4&from=paste&height=250&id=u63c202ac&originHeight=512&originWidth=834&originalType=binary&ratio=2&rotation=0&showTitle=false&size=122626&status=done&style=none&taskId=u40817453-adb9-48ef-b547-c6cccf1beb6&title=&width=407">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703834638239-32f40a68-8071-4134-b201-ab8c3d3b13b1.png#averageHue=%23fbfbfb&clientId=u934a904e-b132-4&from=paste&height=220&id=qgrNk&originHeight=560&originWidth=914&originalType=binary&ratio=2&rotation=0&showTitle=false&size=142072&status=done&style=none&taskId=uecace63f-9d7a-479d-b7c3-33b4607c03b&title=&width=359">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703834676625-b9a62ee0-af57-459c-babc-522f42ec9a62.png#averageHue=%23f9f9f9&clientId=u934a904e-b132-4&from=paste&height=270&id=oOZp3&originHeight=540&originWidth=898&originalType=binary&ratio=2&rotation=0&showTitle=false&size=151995&status=done&style=none&taskId=ua6a90f37-f1dc-466c-acd5-23253721db5&title=&width=449">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703834719346-18dbc976-1a3a-4f61-b07e-c1e5061756b1.png#averageHue=%23fafafa&clientId=u934a904e-b132-4&from=paste&height=270&id=HIjrW&originHeight=540&originWidth=892&originalType=binary&ratio=2&rotation=0&showTitle=false&size=146941&status=done&style=none&taskId=u23c06b6d-1850-476b-8f09-e4963acd053&title=&width=446">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703834656419-b4687e70-bc75-4aa1-b39b-11db1d3ef56e.png#averageHue=%23fafafa&clientId=u934a904e-b132-4&from=paste&height=220&id=VMGOI&originHeight=534&originWidth=890&originalType=binary&ratio=2&rotation=0&showTitle=false&size=147980&status=done&style=none&taskId=u5a0bdc0a-8ee8-4596-b929-23b234467ad&title=&width=367">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703834696308-e3f469b4-1256-4f69-9df3-ae862f64f21a.png#averageHue=%23fafafa&clientId=u934a904e-b132-4&from=paste&height=267&id=eOfdl&originHeight=534&originWidth=884&originalType=binary&ratio=2&rotation=0&showTitle=false&size=148507&status=done&style=none&taskId=ub61d985e-e3a3-4122-94b1-54f4082c43c&title=&width=442">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703839847513-e4bce9d6-13ed-4d89-b99d-1a0f818ce192.png#averageHue=%23fbfbfb&clientId=u934a904e-b132-4&from=paste&height=228&id=ua7c8d7a0&originHeight=245&originWidth=387&originalType=binary&ratio=2&rotation=0&showTitle=false&size=38724&status=done&style=none&taskId=u50a752c7-b763-4790-8bc8-e334d373f72&title=&width=360">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703839912798-7bd735d8-bb5d-47fc-b793-d4966c8c469a.png#averageHue=%23fafafa&clientId=u934a904e-b132-4&from=paste&height=228&id=u863f73cb&originHeight=228&originWidth=362&originalType=binary&ratio=2&rotation=0&showTitle=false&size=34089&status=done&style=none&taskId=u5fdcdb90-0efd-4325-b955-b17e0185941&title=&width=362">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703839875343-d7e76d6b-3951-4ffa-90ed-a764b2942baf.png#averageHue=%23fafafa&clientId=u934a904e-b132-4&from=paste&height=228&id=ue0e24dc8&originHeight=227&originWidth=364&originalType=binary&ratio=2&rotation=0&showTitle=false&size=36670&status=done&style=none&taskId=u93c09756-015e-4fef-be5c-66a6b1dbcc9&title=&width=366">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703839928727-e6afbdce-462f-45c5-b723-787450ffdbc3.png#averageHue=%23fafafa&clientId=u934a904e-b132-4&from=paste&height=225&id=ubc86baf6&originHeight=225&originWidth=364&originalType=binary&ratio=2&rotation=0&showTitle=false&size=33052&status=done&style=none&taskId=ucdd89eea-f432-44c4-9ac6-317f05ad2ef&title=&width=364">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703840299441-2ab492ca-5c31-4052-a693-0bb41f7ce059.png#averageHue=%23f8f8f8&clientId=u934a904e-b132-4&from=paste&height=228&id=ued366b86&originHeight=216&originWidth=349&originalType=binary&ratio=2&rotation=0&showTitle=false&size=38038&status=done&style=none&taskId=ua61946e8-007a-42d5-9ba8-14fb4d39a21&title=&width=368">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703840317301-e382bf81-0c76-4e87-b012-418bccf80e32.png#averageHue=%23f8f8f8&clientId=u934a904e-b132-4&from=paste&height=228&id=ufbcce7a2&originHeight=216&originWidth=350&originalType=binary&ratio=2&rotation=0&showTitle=false&size=38964&status=done&style=none&taskId=uabda82cd-e57e-441b-a65e-e7d1fb48da2&title=&width=369">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703840334386-5b34380d-694d-4bef-a6b0-681ace21a569.png#averageHue=%23f9f9f9&clientId=u934a904e-b132-4&from=paste&height=228&id=u5652cfe1&originHeight=232&originWidth=369&originalType=binary&ratio=2&rotation=0&showTitle=false&size=38467&status=done&style=none&taskId=u6bd7edab-46fe-4e5d-b3ea-1bc9e4d88ff&title=&width=363">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703840351373-1fb56801-420e-45cf-bb42-f363e0ced05d.png#averageHue=%23f9f9f9&clientId=u934a904e-b132-4&from=paste&height=228&id=uf2979300&originHeight=211&originWidth=338&originalType=binary&ratio=2&rotation=0&showTitle=false&size=35550&status=done&style=none&taskId=u319eba56-f02c-450c-a0b9-1620a655887&title=&width=365">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703840370163-af7026a4-1d87-4a49-baff-65d8602e96df.png#averageHue=%23f9f9f9&clientId=u934a904e-b132-4&from=paste&height=228&id=u1792f8c8&originHeight=212&originWidth=338&originalType=binary&ratio=2&rotation=0&showTitle=false&size=35930&status=done&style=none&taskId=u9e8fc7dc-c30f-47b9-963f-ce7cdd4a6dc&title=&width=364">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703840384843-02bf0b28-d32f-4352-927a-a1a3e754c350.png#averageHue=%23f8f8f8&clientId=u934a904e-b132-4&from=paste&height=228&id=u9275004b&originHeight=228&originWidth=372&originalType=binary&ratio=2&rotation=0&showTitle=false&size=39360&status=done&style=none&taskId=u09aed5e9-fb41-472f-87de-63c79f69c12&title=&width=372">
<meta property="article:published_time" content="2023-04-20T04:04:00.000Z">
<meta property="article:modified_time" content="2024-08-02T04:16:59.947Z">
<meta property="article:author" content="Lu Yan">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="后端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703648545502-48d8e98e-7d30-4124-97e7-7110903b2af5.png#averageHue=%23d8d8d8&clientId=u2e2c9feb-4180-4&from=paste&height=102&id=u3d63d8e1&originHeight=102&originWidth=601&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31160&status=done&style=none&taskId=ue89ce0a7-21bc-412a-a071-e3086619b0f&title=&width=601">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2023/04/20/Java-基础系列（05）/"/>





  <title>Java 基础系列（05） | Luyan's Bolg</title>
  








<meta name="generator" content="Hexo 7.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Luyan's Bolg</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不积跬步，无以至千里；不积小流，无以成江海。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/index.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/20/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8805%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java 基础系列（05）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-20T12:04:00+08:00">
                2023-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="Map-Set"><a href="#Map-Set" class="headerlink" title="Map &amp; Set"></a>Map &amp; Set</h3><h4 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h4><p><code>Map</code>维护的是键到值的映射关系，键是不能重复的，但值可以。访问的时候给定一个键，返回这个键对应的值。给同一个键重复设值，新值会覆盖旧值。接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K,V&gt; &#123;  <span class="comment">// K、V 是类型参数，分别表示键和值的类型</span></span><br><span class="line">    V <span class="title function_">put</span><span class="params">(K key, V value)</span>;  <span class="comment">// 保存键值对，若 key 不存在返回 null，存在就返回旧值</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(Object key)</span>;  <span class="comment">// 根据键获取值，找不到返回 null</span></span><br><span class="line">    V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span>;  <span class="comment">// 同上，但找不到返回 defaultValue</span></span><br><span class="line">    V <span class="title function_">remove</span><span class="params">(Object key)</span>;  <span class="comment">// 根据键删除键值对，返回对应的值，若键不存在返回 null</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;  <span class="comment">// 返回键值对的数量</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;  <span class="comment">// 返回 Map 是否为空</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span>;  <span class="comment">// 返回是否包含某个键</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span>;  <span class="comment">// 返回是否包含某个值</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span>;<span class="comment">// 将 m 中所有键值对保存到当前 Map</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;  <span class="comment">// 清空所有键值对</span></span><br><span class="line">    Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>;  <span class="comment">//឴ 返回 Map 中所有键的集合</span></span><br><span class="line">    Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span>;  <span class="comment">//឴ 获取 Map 中所有值的集合</span></span><br><span class="line">    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();  <span class="comment">//឴ 获取 Map 中所有键值对的集合</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Entry</span>&lt;K,V&gt; &#123;  <span class="comment">// 内部接口，表示键值对</span></span><br><span class="line">        K <span class="title function_">getKey</span><span class="params">()</span>;</span><br><span class="line">        V <span class="title function_">getValue</span><span class="params">()</span>;</span><br><span class="line">        V <span class="title function_">setValue</span><span class="params">(V value)</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Set</code>是一个表示数学中集合概念的接口，即元素不重复：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Set</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 迭代遍历的时候不要求元素有特别的顺序</span></span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素。元素存在时直接返回 false，不存在时才会添加进去并返回 true</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个集合里的所有元素，重复元素不添加。返回当前集合是否有变化</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它扩展了<code>Collection</code>接口但没有定义新方法，它要求所有的实现者必须满足其语义约束，即不能有重复的元素。<br><code>Map</code>中的<code>keySet</code>方法因为所有键是不重复的，所以会返回一个<code>Set</code>。<code>keySet、values、entrySet</code>返回的都是视图，不是复制的值，基于返回值的修改都会作用到<code>Map</code>自身：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.values().clear();</span><br><span class="line">map.keySet().clear();</span><br><span class="line">map.entrySet().clear();</span><br></pre></td></tr></table></figure>
<p>上面的三种写法都会清空掉<code>Map</code>。</p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><p><code>HashMap</code>实现了<code>Map</code>接口。我们看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> rnd.nextInt(<span class="number">4</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.getOrDefault(n, <span class="number">0</span>);</span><br><span class="line">    map.put(n, count + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; kv : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(kv.getKey() + <span class="string">&quot;: &quot;</span> + kv.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子想要检验随机数类生成的随机数是否均匀，里面的用法也很简单，其一次输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: <span class="number">265</span></span><br><span class="line"><span class="number">1</span>: <span class="number">244</span></span><br><span class="line"><span class="number">2</span>: <span class="number">248</span></span><br><span class="line"><span class="number">3</span>: <span class="number">243</span></span><br></pre></td></tr></table></figure>
<p>除了默认的构造方法，<code>HashMap</code>还有如下的几种构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span><br></pre></td></tr></table></figure>
<p><code>initialCapacity</code>和<code>loadFactor</code>是什么含义后面看。最后一个构造会将<code>m</code>的键值对添加到当前的<code>Map</code>中。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><h6 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h6><p><code>HashMap</code>有如下几个主要的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>size</code>表示键值对的数目；</p>
</li>
<li><p><code>table</code>是一个<code>Entry</code>类型的数组，称为哈希表或哈希桶，数组里面的每一个元素都指向一个单链表。<code>Entry</code>是一个内部类，它的实例变量和构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="type">int</span> hash;</span><br><span class="line">    Entry(<span class="type">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出这是一个单链表的节点，<code>key</code>和<code>value</code>分别表示键与值，<code>next</code>指向下一个节点，<code>hash</code>存储<code>key</code>的哈希值，之所以存储哈希值是为了加快比较速度。<br><code>table</code>的初值是<code>EMPTY_TABLE</code>，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>随着往<code>Map</code>里面添加元素，<code>table</code>的容量会扩展，每次扩展双倍。具体扩展的时机与<code>threshold</code>相关。</p>
</li>
<li><p><code>threshold</code>表示阈值，当<code>size ≥ threshold</code>时考虑扩展空间。一般来讲，<code>threshold = table.length * loadFactor</code>。</p>
</li>
<li><p><code>loadFactor</code>是负载因子，指示<code>table</code>被占用的程度，默认值是 0.75，可以通过构造修改。</p>
</li>
</ul>
<h6 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h6><p><code>HashMap</code>的默认构造是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DEFAULT_INITIAL_CAPACITY</code>默认是 16，<code>DEFAULT_LOAD_FACTOR</code>默认是 0.75。它调用的构造是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要就是设置<code>loadFactor</code>和<code>threshold</code>的初值。</p>
<h6 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(table == EMPTY_TABLE) &#123;</span><br><span class="line">    	inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(key == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span>(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次添加元素的时候调用<code>inflateTable</code>给<code>table</code>分配空间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inflateTable</span><span class="params">(<span class="type">int</span> toSize)</span> &#123;</span><br><span class="line">    <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> roundUpToPowerOf2(toSize);</span><br><span class="line">    threshold = (<span class="type">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码写的很清楚，默认情况下会分配一个长度 16 的数组，此时<code>threshold</code>是 12。<br>下面调用<code>hash</code>方法计算<code>key</code>的哈希值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数使用对象本身的<code>hashCode</code>再做一些位运算，增加随机和均匀性。<br>下面调用<code>indexFor</code>方法计算指定哈希值应该放在数组哪一个下标：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> h &amp; (length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>HashMap</code>中，数组的长度是 2 的次幂，所以<code>h &amp; (length - 1)</code>等价于<code>h % (length - 1)</code>。我们知道<code>table[i]</code>指向一个单链表，下面就是从单链表里面寻找这个键，如果这个键存在就执行修改操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">    Object k;</span><br><span class="line">    <span class="comment">// hash 相同并且键相同就是存在这个键</span></span><br><span class="line">    <span class="keyword">if</span>(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">        e.value = value;</span><br><span class="line">        e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实只比较键就可以了，先比较哈希是为了提高效率。因为哈希不同后面的键比较就不需要了，而哈希是整型比较起来会很快。<br>如果键不存在就使用<code>addEntry</code>插入一条，<code>modCount</code>也是用来记录结构性变化次数的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 将键值对封装成 Entry 并插入到对应位置链表的头部</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>addEntry</code>里面，如果容量足够就直接插入元素，插入的时候是插入到链表头部。如果容量不够，就使用<code>resize</code>分配两倍空间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span>(rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>resize</code>分配好空间之后，使用<code>transfer</code>方法转移所有键值对并更新<code>threshold</code>的值。</p>
<h6 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h6><p>根据键获取值的<code>get</code>方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(key == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span> == entry ? <span class="literal">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">      e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span>(e.hash == hash </span><br><span class="line">          &amp;&amp; ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        	<span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要流程就是根据键的哈希值找到对应单链表的头结点，然后依次往下比较，找到直接返回，找不到返回<code>null</code>。<br><code>containsKey</code>的查找流程和<code>get</code>有些像：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> getEntry(key) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HashMap</code>可以高效的操作键，但对于值需要挨个查找。<code>containsValue</code>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(value == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> containsNullValue();</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length ; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i] ; e != <span class="literal">null</span> ; e = e.next)</span><br><span class="line">            <span class="keyword">if</span>(value.equals(e.value))</span><br><span class="line">            	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑很简单就是从前到后遍历每一个链表里的每一个节点，看看值是否存在。</p>
<h6 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = removeEntryForKey(key);</span><br><span class="line">    <span class="keyword">return</span> (e == <span class="literal">null</span> ? <span class="literal">null</span> : e.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">removeEntryForKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line">    <span class="keyword">while</span>(e != <span class="literal">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span>(e.hash == hash &amp;&amp;</span><br><span class="line">          ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span>(prev == e)</span><br><span class="line">            	table[i] = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            	prev.next = next;</span><br><span class="line">            e.recordRemoval(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e;</span><br><span class="line">        e = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑很简单，根据键找到<code>table[i]</code>，然后顺着链表找到要删除的节点进行删除。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>查找时会先比较哈希值然后再使用<code>equals</code>方法进行比较，即如果两个对象哈希值不一样那么就认为它们不一样。这也就解释了前面说的，<code>hashCode</code>和<code>equals</code>必须一起重写且<code>equals</code>返回<code>true</code>那么<code>hashCode</code>必须返回一样的值，反之不一定。<br>在 Java8 里面，对<code>HashMap</code>进行了优化，当哈希桶里面某个链表过长时会将其转换成平衡的排序二叉树。<br>值得注意，<code>**HashMap**</code><strong>线程不安全</strong>。还有一个实现和<code>HashMap</code>基本相同的线程安全的类<code>HashTable</code>，这个类是使用<code>synchronized</code>关键字实现的线程安全。<code>HashMap</code>的键或值都可以是<code>null</code>，但<code>HashTable</code>不可以。在不需要并发的场景下推荐使用<code>HashMap</code>，高并发下推荐使用后面将会介绍的<code>ConcurrentHashMap</code>。</p>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p><code>HashSet</code>的构造有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>这里<code>initialCapacity</code>和<code>loadFactor</code>的含义与<code>HashMap</code>一致。<br><code>HashSet</code>的使用也很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">set.add(<span class="string">&quot;卢研&quot;</span>);</span><br><span class="line">set.addAll(Arrays.asList(<span class="string">&quot;卢研&quot;</span>, <span class="string">&quot;刘妙霞&quot;</span>));</span><br><span class="line"><span class="keyword">for</span> (String name : set) &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边“卢研”并不会被添加两次，输出的顺序并不是按照添加的顺序的来的。和<code>HashMap</code>类似，<code>HashSet</code>要求元素重写<code>hashCode</code>和<code>equals</code>方法，<code>equals</code>返回<code>true</code>时<code>hashCode</code>必须相同，反之不要求。尤其对于自定义类一定要注意这点，因为<code>equals</code>方法比较的是两个对象的地址。<br><code>HashSet</code>内部使用<code>HashMap</code>实现，它内部有一个<code>HashMap</code>的实例变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br></pre></td></tr></table></figure>
<p>我们知道<code>HashMap</code>有键和值，但<code>HashSet</code>只有键，所以存的时候所有键的值都是一样的，这个值定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>
<p>下面<code>HashSet</code>的构造，主要就是初始化<code>HashMap</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">	map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据 c 的容量计算 HashMap 的初始容量，最少为 16，默认的负载因子是 0.75</span></span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(Math.max((<span class="type">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面看看一些常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素，调用 map.put 的返回值为 null 说明这个键没出现过，因为添加的时候值一定不为 null</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> map.put(e, PRESENT) == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若存在对应的键，其值一定是 PRESENT</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> map.remove(o) == PRESENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HashSet</code>可以高效的实现去重、集合运算等。但其内元素是无序的，若要保持添加的先后顺序可以使用<code>HashSet</code>子类<code>LinkedHashSet</code>。除此之外还有一个重要的<code>Set</code>的实现类<code>TreeSet</code>支持排序。</p>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>前面我们提到过<code>HashMap</code>有一个局限，键值对之间没有特定顺序。<code>TreeMap</code>内部使用排序二叉树，使得键值对之间有序（升序或降序而不是添加的顺序）。<br>排序二叉树就是对树里的任意一棵子树来说，左子树的所有节点值都小于根节点，右子树所有节点值都大于根节点。</p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p><code>TreeMap</code>有两个基本构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span></span><br></pre></td></tr></table></figure>
<p>第一个是无参构造要求<code>Map</code>里的键必须实现<code>Comparable</code>接口，后面会将<code>Comparable.compareTo</code>作为键之间排序的依据。<br>第二个构造接受一个<code>Comparator</code>，这样就不要求键去实现<code>Comparable</code>接口，比较的时候会调用<code>comparator.compare</code>方法。<br>需要强调的是，<code>TreeMap</code>是按键有序，和值无关，和插入顺序也无关。下面是简单的案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;abs&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;come&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;T&quot;</span>, <span class="string">&quot;To&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; kv : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(kv.getKey() + <span class="string">&quot;-&gt;&quot;</span> + kv.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T-&gt;To</span><br><span class="line">a-&gt;abs</span><br><span class="line">c-&gt;come</span><br></pre></td></tr></table></figure>
<p>可以看出，我们默认是从小到大按键进行排序，<code>String</code>类实现的<code>Comparable</code>接口是依次比较字符。如果我们想忽略大小写呢？那么只能使用第二种构造，传一个<code>Comparator</code>进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</span><br></pre></td></tr></table></figure>
<p>如果希望从大到小排序呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(Collections.reverseOrder());</span><br></pre></td></tr></table></figure>
<p><code>Collections.reverseOrder</code>方法里面还可以再传递一个<code>Comparator</code>进去，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(</span><br><span class="line">	Collections.reverseOrder(String.CASE_INSENSITIVE_ORDER));</span><br></pre></td></tr></table></figure>
<p>这就是忽略大小写并逆序排序。对于更复杂的排序规则那就需要自己实现<code>Comparator</code>了，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sdf.parse(o1).compareTo(sdf.parse(o2));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">map.put(<span class="string">&quot;2023-12-3&quot;</span>, <span class="string">&quot;100&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;2023-10-15&quot;</span>, <span class="string">&quot;50&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;2023-12-25&quot;</span>, <span class="string">&quot;200&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; kv : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(kv.getKey() + <span class="string">&quot;-&gt;&quot;</span> + kv.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个案例就是将键当做一个日期来比较大小，输出的结果是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023</span>-<span class="number">10</span>-<span class="number">15</span>-&gt;<span class="number">50</span></span><br><span class="line"><span class="number">2023</span>-<span class="number">12</span>-<span class="number">3</span>-&gt;<span class="number">100</span></span><br><span class="line"><span class="number">2023</span>-<span class="number">12</span>-<span class="number">25</span>-&gt;<span class="number">200</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>TreeMap</code>要求键是唯一的，而是否唯一的判定标准也是看<code>Comparable</code>或<code>Comparator</code>的比较方法。那这就会出现一些有趣的现象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = </span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">map.put(<span class="string">&quot;T&quot;</span>, <span class="string">&quot;To&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;t&quot;</span>, <span class="string">&quot;to&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; kv : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(kv.getKey() + <span class="string">&quot;-&gt;&quot;</span> + kv.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T-&gt;to</span><br></pre></td></tr></table></figure>
<p>一开始设置键值对<code>T -&gt; To</code>，接下来当我们设置<code>t -&gt; to</code>的时候，因为比较是忽略大小写的，所以认为<code>T</code>和<code>t</code>是相同的键，因此执行的是修改而不是添加，最后的结果就是剩下一对键值对<code>T -&gt; to</code>。</p>
<h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p><code>TreeMap</code>内部使用红黑树实现，红黑树是一种大致平衡的排序二叉树。</p>
<h6 id="内部组成"><a href="#内部组成" class="headerlink" title="内部组成"></a>内部组成</h6><p><code>TreeMap</code>主要有以下几个成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;  <span class="comment">// 比较器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root = <span class="literal">null</span>;  <span class="comment">// 根节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 键值对数量</span></span><br></pre></td></tr></table></figure>
<p><code>Entry</code>是静态内部类，其主要成员和构造如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    K key;  <span class="comment">// 键</span></span><br><span class="line">    V value;  <span class="comment">// 值</span></span><br><span class="line">    Entry&lt;K,V&gt; left = <span class="literal">null</span>;  <span class="comment">// 左孩子</span></span><br><span class="line">    Entry&lt;K,V&gt; right = <span class="literal">null</span>;  <span class="comment">// 右孩子</span></span><br><span class="line">    Entry&lt;K,V&gt; parent;  <span class="comment">// 父节点</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK;  <span class="comment">// 每个节点有个颜色，非黑即红</span></span><br><span class="line">    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="保存键值对"><a href="#保存键值对" class="headerlink" title="保存键值对"></a>保存键值对</h6><p><code>put</code>方法的代码比较长，我们断开看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>) &#123;</span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, <span class="literal">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当添加第一个节点的时候会进到<code>if</code>里面，主要创建一个新节点，让<code>root</code>指向它。里面调用<code>compare</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object k1, Object k2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> comparator==<span class="literal">null</span> ? ((Comparable&lt;? <span class="built_in">super</span> K&gt;)k1).compareTo((K)k2)</span><br><span class="line">    	: comparator.compare((K)k1, (K)k2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要检查是否有比较器或键是否实现了<code>Comparable</code>接口。接下来根据是否包含比较器进入不同的流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cmp;</span><br><span class="line">Entry&lt;K,V&gt; parent;</span><br><span class="line"><span class="comment">//split comparator and comparable paths</span></span><br><span class="line">Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;</span><br><span class="line"><span class="keyword">if</span>(cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        cmp = cpr.compare(key, t.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>)</span><br><span class="line">        	t = t.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>)</span><br><span class="line">        	t = t.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	<span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主体流程就是键小就往左边插入，键大就往右边插入，键一样大就是修改。当退出循环的时候<code>parent</code>指向待插入位置的父节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(key == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        cmp = k.compareTo(t.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>)</span><br><span class="line">        	t = t.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>)</span><br><span class="line">        	t = t.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	<span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span>(t != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有比较器就把键当做<code>Comparable</code>进行比较，流程和上面是一样的。<br>找到父节点后，就创建新节点并插进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent);</span><br><span class="line"><span class="keyword">if</span>(cmp &lt; <span class="number">0</span>)</span><br><span class="line">	parent.left = e;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	parent.right = e;</span><br><span class="line">fixAfterInsertion(e);</span><br><span class="line">size++;</span><br><span class="line">modCount++;</span><br></pre></td></tr></table></figure>
<p>每次插入之后，都会调用<code>fixAfterInsertion</code>方法来调整红黑树的结构使之大致平衡。<br>从整个流程也可以看出，比较优先使用比较器而不是<code>Comparable</code>接口。</p>
<h6 id="用键获取值"><a href="#用键获取值" class="headerlink" title="用键获取值"></a>用键获取值</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> (p == <span class="literal">null</span> ? <span class="literal">null</span> : p.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// Offload comparator-based version for sake of performance</span></span><br><span class="line">    <span class="keyword">if</span>(comparator != <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="keyword">if</span>(key == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>)</span><br><span class="line">        	p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>)</span><br><span class="line">        	p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	<span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主体流程也是很简单，根据键的大小确定往左找还是往右找。里面<code>getEntryUsingComparator</code>方法流程也是一样的，只不过使用比较器进行比较。</p>
<h6 id="查找值"><a href="#查找值" class="headerlink" title="查找值"></a>查找值</h6><p><code>TreeMap</code>可以高效的查找键，但是查找值需要依次遍历。遍历是按照键从小到大进行的，没有使用递归，而是定义了函数<code>successor</code>返回一个节点的后继节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; e = getFirstEntry(); e != <span class="literal">null</span>; e = successor(e))</span><br><span class="line">        <span class="keyword">if</span>(valEquals(value, e.value))</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回最小的节点，显然是在树的最左边</span></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getFirstEntry</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">while</span> (p.left != <span class="literal">null</span>)</span><br><span class="line">    		p = p.left;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; <span class="title function_">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="literal">null</span>)</span><br><span class="line">        	p = p.left;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">        Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">            ch = p;</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对任意一个节点的后继节点的查找策略：</p>
<ol>
<li>如果这个节点有右孩子，那么后继节点一定是右孩子里最小的节点（最左侧节点）。</li>
<li>若这个节点没有右孩子，那么后继节点一定是它的某个祖先节点，不一定是父节点。这个祖先节点一定在它的右侧，若找不到这样的祖先节点就说明遍历结束。</li>
</ol>
<h6 id="删除键值对"><a href="#删除键值对" class="headerlink" title="删除键值对"></a>删除键值对</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> p.value;</span><br><span class="line">    deleteEntry(p);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主体逻辑就是找到键对应的节点，删除掉该节点并返回删除节点的值。<code>deleteEntry</code>方法就是做的删除操作，逻辑比较复杂，主要分三种情况：</p>
<ul>
<li>待删节点是叶子节点，那么直接将其父节点的对应孩子引用置为<code>null</code>。</li>
<li>待删节点只有一个孩子，那么直接让父节点指向这个孩子节点即可。</li>
<li>待删节点有两个孩子，找到该节点的后继节点并将后继节点的值填充到当前节点里面，再删除掉后继节点即可。而我们知道，后继节点是自己右孩子最左侧的节点，因此这个后继节点没有左孩子，很好删除。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">//If strictly internal, copy successor&#x27;s element to p and then make p</span></span><br><span class="line">    <span class="comment">//point to successor.</span></span><br><span class="line">    <span class="keyword">if</span>(p.left != <span class="literal">null</span> &amp;&amp; p.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125; <span class="comment">//p has 2 children</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Start fixup at replacement node, if it exists.</span></span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="literal">null</span> ? p.left : p.right);</span><br><span class="line">    <span class="keyword">if</span>(replacement != <span class="literal">null</span>) &#123;  <span class="comment">// 有一个孩子节点</span></span><br><span class="line">        <span class="comment">//Link replacement to parent</span></span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span>(p.parent == <span class="literal">null</span>)</span><br><span class="line">        	root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p == p.parent.left)</span><br><span class="line">        	p.parent.left = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	p.parent.right = replacement;</span><br><span class="line">        <span class="comment">// Null out links so they are OK to use by fixAfterDeletion.</span></span><br><span class="line">        p.left = p.right = p.parent = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// Fix replacement</span></span><br><span class="line">        <span class="keyword">if</span>(p.color == BLACK)</span><br><span class="line">        	fixAfterDeletion(replacement);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="literal">null</span>) &#123;  <span class="comment">// 树里只有一个节点</span></span><br><span class="line">    	root = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 普通的叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(p.color == BLACK)</span><br><span class="line">        	fixAfterDeletion(p);</span><br><span class="line">        <span class="keyword">if</span>(p.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p == p.parent.left)</span><br><span class="line">            	p.parent.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p == p.parent.right)</span><br><span class="line">            	p.parent.right = <span class="literal">null</span>;</span><br><span class="line">            p.parent = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><code>TreeMap</code>除了实现<code>Map</code>接口还实现了<code>SortedMap</code>、<code>NavigableMap</code>接口，所以它能够更方便进行一些操作，例如：查找第一个节点、最后一个节点、某一个范围的键、邻近键等。<br>在日常使用中，如果需要排序考虑使用<code>TreeMap</code>，否则考虑使用<code>HashMap</code>。</p>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>之前讲<code>HashSet</code>里面的元素是无序的，如果我们想让元素有序（大小有序），可以使用<code>TreeSet</code>。实际上<code>TreeSet</code>内部也是维护了一个<code>TreeMap</code>，所有的操作也是基于<code>TreeMap</code>的。它有以下两个构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span></span><br></pre></td></tr></table></figure>
<p>构造里面就是实例化<code>TreeMap</code>。因此和<code>TreeMap</code>类似，元素之间必须可比较，要么传入一个比较器，要么自己实现<code>Comparable</code>接口。<br><code>TreeSet</code>有如下两个成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>
<p>下面看一些常用功能的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> m.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> m.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> m.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到全是基于<code>TreeMap</code>的操作。</p>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p><code>HashMap</code>里键值对是无序的，<code>TreeMap</code>里键值对是按键有序。有时我们需要让键值对保持插入时的顺序或者保持访问的顺序。保持插入顺序就是先插入的在前面，后插入的在后面。保持访问的顺序，就是最近访问的在后面，最久未访问的在前面。<br><code>LinkedHashMap</code>继承于<code>HashMap</code>，因此<code>LinkedHashMap</code>也是使用哈希桶+单链表的形式存数据。除此之外，<code>LinkedHashMap</code>还维护了一个双向循环链表，这个链表就是用来记录元素的插入顺序或访问顺序，每一个<code>Entry</code>即在哈希桶里还在这个链表里面。</p>
<h5 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h5><p>按插入排序的构造有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span></span><br></pre></td></tr></table></figure>
<p>按访问顺序排序的构造只有一个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> accessOrder)</span></span><br></pre></td></tr></table></figure>
<p>所有的构造中<code>initialCapacity</code>和<code>loadFactor</code>都是用来调用父类即<code>HashMap</code>的构造的，<code>accessOrder</code>设为<code>true</code>表示按访问顺序排序。<br>下面看个按插入有序的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="number">3</span>);</span><br><span class="line">map.put(<span class="string">&quot;c&quot;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; kv : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(kv.getKey() + <span class="string">&quot; &quot;</span> + kv.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a <span class="number">3</span></span><br><span class="line">b <span class="number">2</span></span><br><span class="line">c <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>我们再看一个按访问有序的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">16</span>, <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="number">3</span>);</span><br><span class="line">map.put(<span class="string">&quot;c&quot;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; kv : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(kv.getKey() + <span class="string">&quot; &quot;</span> + kv.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b <span class="number">2</span></span><br><span class="line">a <span class="number">3</span></span><br><span class="line">c <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>注意，最近访问的元素会放到最后面。按访问有序有一个典型的应用：<code>LRU</code>缓存。<code>LRU(Least Recently Used)</code>是一种流行的替换算法，即最近最少使用。<br>主要的应用场景是：当我们往缓存里面添加数据的时候，若缓存已经满了，则我们需要选择一条数据清理掉，<code>LRU</code>算法就是选择最近最少使用的数据进行清理。<br><code>LinkedHashMap</code>能够实现按访问排序，但默认情况下不会清理旧元素即容量没有限制。是否清理主要看下面函数的返回值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LinkedHashMap</code>每次添加元素之后都会调用这个方法，传进去最久未使用的元素，若这个方法返回<code>true</code>，这个元素将会被删除。可以看到默认的实现就是返回<code>false</code>即不删除。如果需要删除的话，我们可以自定义类继承它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxEntries;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> maxEntries)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.maxEntries = maxEntries;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> size() &gt; maxEntries;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><p><code>LinkedHashMap</code>作为<code>HashMap</code>的子类，多加了以下实例变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; header;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>
<p><code>accessOrder</code>表示是否按访问顺序排列，<code>header</code>表示双向循环链表的头结点。注意这边的<code>Entry</code>类是<code>LinkedHashMap</code>自定义继承于<code>HashMap.Entry</code>的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">    	<span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;  <span class="comment">// 从双向链表里删除当前元素</span></span><br><span class="line">        before.after = after;</span><br><span class="line">        after.before = before;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将当前节点插入到指定节点 existingEntry 前</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> &#123;</span><br><span class="line">        after = existingEntry;</span><br><span class="line">        before = existingEntry.before;</span><br><span class="line">        before.after = <span class="built_in">this</span>;</span><br><span class="line">        after.before = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆写父类方法，每次访问存在的元素时会调用这个方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> &#123;</span><br><span class="line">        LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class="line">        <span class="keyword">if</span>(lm.accessOrder) &#123;</span><br><span class="line">            lm.modCount++;</span><br><span class="line">            remove();</span><br><span class="line">            addBefore(lm.header);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆写父类方法，每次删除元素时会调用这个方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> &#123;</span><br><span class="line">    	remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>recordAccess</code>和<code>recordRemoval</code>是定义在<code>HashMap.Entry</code>里面的方法，这两个方法在<code>HashMap</code>里面的实现是空的，它们是专门用来给子类覆写的。<br><code>LinkedHashMap</code>覆写了这两个方法：</p>
<ul>
<li>删除键值对时会调用<code>recordRemoval</code>方法，这个方法就是将节点从维护的双向链表里删除。</li>
<li>访问已存在的键值对时会调用<code>recordAccess</code>方法，这个方法里面在按照访问顺序排列时会将节点移到双向链表的尾部。因为这个链表是循环的，所以头的前面就是尾。</li>
</ul>
<p><code>HashMap</code>构造里会调用<code>init</code>方法，这个方法默认是空实现，也是设计用来被覆写的。<code>LinkedHashMap</code>就重写了这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    header = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(-<span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    header.before = header.after = header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做的事情就是初始化头结点。<br><code>HashMap</code>插入新键值对时会调用<code>addEntry</code>方法，这个方法会进行哈希桶扩容检查并调用<code>createEntry</code>方法将键值对插入到哈希桶指定下标的单链表的头部。<code>LinkedHashMap</code>重写了这两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.addEntry(hash, key, value, bucketIndex);</span><br><span class="line">    <span class="comment">//Remove eldest entry if instructed</span></span><br><span class="line">    Entry&lt;K,V&gt; eldest = header.after;</span><br><span class="line">    <span class="keyword">if</span>(removeEldestEntry(eldest)) &#123;  <span class="comment">// 是否删除最久未访问节点</span></span><br><span class="line">    	removeEntryForKey(eldest.key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, old);</span><br><span class="line">    table[bucketIndex] = e;  <span class="comment">// 节点插到哈希桶里</span></span><br><span class="line">    e.addBefore(header);  <span class="comment">// 节点插到双向链表里</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LinkedHashMap</code>在修改元素或访问元素的时候会做一次检验，若按照访问顺序排列则将这个元素放到双向链表的尾部。下面看一下<code>get</code>的方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);</span><br><span class="line">    <span class="keyword">if</span>(e == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    e.recordAccess(<span class="built_in">this</span>);  <span class="comment">// 将本节点插入到双向链表的尾部</span></span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p><code>LinkedHashMap</code>是<code>HashMap</code>的子类，<code>LinkedHashMap.Entry</code>是<code>HashMap.Entry</code>的子类。除了使用哈希桶来维护键与值的映射关系，还将每个键值对放到一个双向链表里面。这个双向链表存储着键值对插入的先后顺序，通过配置可以表示访问的先后的顺序。</p>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>每一种<code>Map</code>背后都有一种与之对应的<code>Set</code>，所以理所当然有<code>LinkedHashSet</code>。它有以下构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span></span><br></pre></td></tr></table></figure>
<p><code>LinkedHashSet</code>内部使用<code>LinkedHashMap</code>，所以能够按照插入的顺序访问元素。但是没有构造传递<code>accessOrder</code>，所以无法维护访问顺序。</p>
<h4 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h4><p>当我们需要<code>Map</code>的实现类且键的类型是枚举类型时，可以选择<code>EnumMap</code>。</p>
<h5 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h5><p>假设我们定义了表示大小的<code>Size</code>枚举类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    SMALL, MEDIUM, BIG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以像下面这样使用<code>EnumMap</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Size, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(Size.class);</span><br><span class="line">map.put(Size.SMALL, <span class="number">10</span>);</span><br><span class="line">map.put(Size.BIG, <span class="number">100</span>);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>
<p>使用上没什么两样，主要看创建。创建<code>EnumMap</code>对象的时候需要传递一个类型信息，例如上面的<code>Size.class</code>，有了这个类型信息，<code>EnumMap</code>内部就可以依据这个枚举类进行初始化。<br>注意，<code>EnumMap</code>是保证顺序的，输出是按照键在枚举中的顺序。</p>
<h5 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h5><p><code>EnumMap</code>有如下实例变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;K&gt; keyType;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> K[] keyUniverse;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] vals;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>keyType</code>是类型信息。</li>
<li><code>size</code>是键值对的个数。</li>
<li><code>keyUniverse</code>是键的数组，存储所有可能的枚举值。</li>
<li><code>vals</code>存储键所对应的值，存的时候要和键数组的下标保持一致。</li>
</ul>
<p><code>EnumMap</code>的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">EnumMap</span><span class="params">(Class&lt;K&gt; keyType)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.keyType = keyType;</span><br><span class="line">    keyUniverse = getKeyUniverse(keyType);</span><br><span class="line">    vals = <span class="keyword">new</span> <span class="title class_">Object</span>[keyUniverse.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getKeyUniverse</code>方法比较复杂，它最终是调用对应枚举类型的<code>values</code>方法获取所有的枚举值存到<code>keyUniverse</code>数组里。<br>我们下面看保存键值对的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    typeCheck(key);</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> key.ordinal();  <span class="comment">// 使用 ordinal 作为下标访问元素</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">oldValue</span> <span class="operator">=</span> vals[index];</span><br><span class="line">    vals[index] = maskNull(value);</span><br><span class="line">    <span class="keyword">if</span>(oldValue == <span class="literal">null</span>)</span><br><span class="line">    	size++;</span><br><span class="line">    <span class="keyword">return</span> unmaskNull(oldValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查键的类型是否匹配</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">typeCheck</span><span class="params">(K key)</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">keyClass</span> <span class="operator">=</span> key.getClass();</span><br><span class="line">    <span class="keyword">if</span>(keyClass != keyType &amp;&amp; keyClass.getSuperclass() != keyType)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassCastException</span>(keyClass + <span class="string">&quot; != &quot;</span> + keyType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体代码比较简单，但有两个方法<code>maskNull</code>和<code>unmaskNull</code>。<code>EnumMap</code>允许值为<code>null</code>，而数组里元素的默认值也是<code>null</code>，那么遇到<code>null</code>算这个元素出现了还是没出现？于是出现了这两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">NULL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&quot;java.util.EnumMap.NULL&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">maskNull</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (value == <span class="literal">null</span> ? NULL : value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> V <span class="title function_">unmaskNull</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span>(V) (value == NULL ? <span class="literal">null</span> : value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是<code>get</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (isValidKey(key) ? unmaskNull(vals[((Enum)key).ordinal()]) : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键的类型检查，不通过只会返回 false 而不是报错</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(key == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//Cheaper than instanceof Enum followed by getDeclaringClass</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">keyClass</span> <span class="operator">=</span> key.getClass();</span><br><span class="line">    <span class="keyword">return</span> keyClass == keyType || keyClass.getSuperclass() == keyType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它常用方法的源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;  <span class="comment">// 查看是否包含值</span></span><br><span class="line">    value = maskNull(value);</span><br><span class="line">    <span class="keyword">for</span>(Object val : vals)</span><br><span class="line">    	<span class="keyword">if</span>(value.equals(val))</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;  <span class="comment">// 删除键值对</span></span><br><span class="line">    <span class="keyword">if</span>(!isValidKey(key))</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ((Enum)key).ordinal();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">oldValue</span> <span class="operator">=</span> vals[index];</span><br><span class="line">    vals[index] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(oldValue != <span class="literal">null</span>)</span><br><span class="line">    	size--;</span><br><span class="line">    <span class="keyword">return</span> unmaskNull(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h4><p><code>EnumSet</code>是针对枚举类型的集合。之前就说每种<code>Map</code>都有与之对应的<code>Set</code>，所以<code>EnumSet</code>也是存在的。但是注意，<code>EnumSet</code>内部和<code>EnumMap</code>无关，而是采用了更高效的位向量来实现。<br>我在使用这个类的时候遇到一些错误<code>java: No enum constant javax.lang.model.element.Modifier.SEALED</code>，解决方案是：</p>
<ol>
<li><code>IDEA</code>-&gt;<code>File</code>-&gt;<code>Project Structure</code>-&gt;<code>Language level</code></li>
<li>将 JDK 的版本调到 17 就解决了。</li>
</ol>
<h5 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a>用法</h5><p><code>EnumSet</code>是一个抽象类，所以不能直接<code>new</code>出来。但是<code>EnumSet</code>提供了很多静态方法来创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建指定枚举类型的空集</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">noneOf</span><span class="params">(Class&lt;E&gt; elementType)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建指定枚举类型的全集，初始集合包含所有枚举值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">allOf</span><span class="params">(Class&lt;E&gt; elementType)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 ordinal 作为依据，初始集合包含枚举值中范围是 [from, to] 元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">range</span><span class="params">(E from, E to)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始集合包含指定集合的补集</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">complementOf</span><span class="params">(EnumSet&lt;E&gt; s)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始集合包含参数里的所有元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">of</span><span class="params">(E e)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">of</span><span class="params">(E e1, E e2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">of</span><span class="params">(E e1, E e2, E e3)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">of</span><span class="params">(E e1, E e2, E e3, E e4)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">of</span><span class="params">(E first, E... rest)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始集合包含容器中的所有元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">copyOf</span><span class="params">(EnumSet&lt;E&gt; s)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">copyOf</span><span class="params">(Collection&lt;E&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是<code>of</code>方法有很多重载，从功能角度来说有最后一个就足够了，之所以定义前面的重载方法，是因为使用可变长参数效率比较低。</p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>假设我们定义枚举类型<code>Day</code>表示周几：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">    Mon, Tues, Wed, Thur, Fri, Sat, Sun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再定义员工类，里面包含该员工能工作的具体时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Day&gt; workDays;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name, Set&lt;Day&gt; workDays)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.workDays = workDays;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Day&gt; <span class="title function_">getWorkDays</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> workDays;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义一些员工出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Worker[] workers = <span class="keyword">new</span> <span class="title class_">Worker</span>[] &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;张三&quot;</span>, EnumSet.of(Day.Mon, Day.Tues, Day.Wed, Day.Fri)),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;李四&quot;</span>, EnumSet.of(Day.Tues, Day.Thur, Day.Sat)),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;王五&quot;</span>, EnumSet.of(Day.Tues, Day.Thur))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面基于这些员工回答一些问题：</p>
<ol>
<li><p>哪些天一个人都不会来？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Day&gt; days = EnumSet.allOf(Day.class);</span><br><span class="line"><span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">    days.removeAll(worker.getWorkDays());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(days);</span><br></pre></td></tr></table></figure>
<p>[Sun]<br>创建全集 -&gt; 删掉有人来的日期 -&gt; 剩下的日期就是没人来的。</p>
</li>
<li><p>哪些天至少有一个人来？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Day&gt; days = EnumSet.noneOf(Day.class);</span><br><span class="line"><span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">    days.addAll(worker.getWorkDays());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(days);</span><br></pre></td></tr></table></figure>
<p>[Mon, Tues, Wed, Thur, Fri, Sat]<br>创建空集 -&gt; 添加有人来的日期 -&gt; 存在的就是有人来的。</p>
</li>
<li><p>哪些天至少两个人来？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Day&gt; days = EnumSet.noneOf(Day.class);</span><br><span class="line">Map&lt;Day, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(Day.class);</span><br><span class="line"><span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Day day : worker.getWorkDays()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.getOrDefault(day, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        map.put(day, count);</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= <span class="number">2</span>) days.add(day);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(days);</span><br></pre></td></tr></table></figure>
<p>[Tues, Thur]<br>我们先借助<code>EnumMap</code>统计每天有多少人去，选出至少两个人的添加到集合里面。</p>
</li>
<li><p>哪些天所有人都在？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Day&gt; days = EnumSet.allOf(Day.class);</span><br><span class="line"><span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">    days.retainAll(worker.getWorkDays());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(days);</span><br></pre></td></tr></table></figure>
<p>[Tues]<br>创建全集并保留每一个员工都在的日期，最后剩余的就是答案。</p>
</li>
<li><p>哪些人周一、周二都会来？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Day&gt; mt = EnumSet.of(Day.Mon, Day.Tues);</span><br><span class="line"><span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">    <span class="keyword">if</span> (worker.getWorkDays().containsAll(mt)) &#123;</span><br><span class="line">        System.out.println(worker.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>张三<br>看每个员工的工作日期是否同时包含周一和周二。</p>
</li>
</ol>
<h5 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h5><p><code>EnumSet</code>使用位向量实现，所谓位向量就是使用一位表示元素的状态，使用一组位表示集合的状态。而集合中每个元素的状态只有存在和不存在两种。<br>对于元素是<code>Day</code>类型的集合，一共就 7 种元素，所以使用一个字节（8 位）即可表示。位向量中自右向左表示元素，例如包含<code>Day.Mon</code>、<code>Day.Tues</code>、<code>Day.Wed</code>、<code>Day.Fri</code>的集合位向量图为：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703648545502-48d8e98e-7d30-4124-97e7-7110903b2af5.png#averageHue=%23d8d8d8&clientId=u2e2c9feb-4180-4&from=paste&height=102&id=u3d63d8e1&originHeight=102&originWidth=601&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31160&status=done&style=none&taskId=ue89ce0a7-21bc-412a-a071-e3086619b0f&title=&width=601" alt="image.png"><br><code>EnumSet</code>里面位向量的长度是多少呢？<br><code>EnumSet</code>是一个抽象类，里面并没有定义位向量。它有两个子类<code>RegularEnumSet</code>和<code>JumboEnumSet</code>，其中<code>RegularEnumSet</code>内部使用一个<code>long</code>作为位向量，<code>JumboEnumSet</code>使用一个<code>long</code><strong>数组</strong>作为位向量。使用<code>EnumSet</code>静态方法创建集合的时候，若枚举值个数小于等于 64 会创建<code>RegularEnumSet</code>，否则会创建<code>JumboEnumSet</code>。<br><code>EnumSet</code>内部定义了如下两个成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Class&lt;E&gt; elementType;</span><br><span class="line"><span class="keyword">final</span> Enum[] universe;</span><br></pre></td></tr></table></figure>
<p>其中<code>elementType</code>表示枚举类型，<code>universe</code>存储所有枚举值。<code>EnumSet</code>内部没有位向量及记录元素个数的变量，这些内容由子类维护。<br>对于<code>RegularEnumSet</code>有以下定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">elements</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Long.bitCount(elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>elements</code>作为位向量存在，<code>size</code>方法用来统计位向量里面有多少元素。<br>对<code>JumboEnumSet</code>有如下定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> elements[];</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><code>elements</code>数组作为位向量，使用<code>size</code>变量记录元素的个数。<br>下面我们看看<code>EnumSet</code>的静态方法<code>noneOf</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">noneOf</span><span class="params">(Class&lt;E&gt; elementType)</span> &#123;</span><br><span class="line">    Enum[] universe = getUniverse(elementType);</span><br><span class="line">    <span class="keyword">if</span>(universe == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassCastException</span>(elementType + <span class="string">&quot; not an enum&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(universe.length &lt;= <span class="number">64</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegularEnumSet</span>&lt;&gt;(elementType, universe);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JumboEnumSet</span>&lt;&gt;(elementType, universe);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RegularEnumSet(Class&lt;E&gt;elementType, Enum[] universe) &#123;</span><br><span class="line">	<span class="built_in">super</span>(elementType, universe);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JumboEnumSet(Class&lt;E&gt;elementType, Enum[] universe) &#123;</span><br><span class="line">    <span class="built_in">super</span>(elementType, universe);</span><br><span class="line">    <span class="comment">// (universe.length + 63) &gt;&gt;&gt; 6 可以计算出至少需要多少 long 才能存下</span></span><br><span class="line">    elements = <span class="keyword">new</span> <span class="title class_">long</span>[(universe.length + <span class="number">63</span>) &gt;&gt;&gt; <span class="number">6</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法里面是根据枚举值的数量选择对应的子类进行创建，子类的构造里面会调用父类的构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EnumSet(Class&lt;E&gt;elementType, Enum[] universe) &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementType = elementType;</span><br><span class="line">    <span class="built_in">this</span>.universe = universe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它的工厂方法都是先调用<code>noneOf</code>然后再往集合里面添加元素。<br>下面看看<code>RegularEnumSet</code>的<code>add</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    typeCheck(e);</span><br><span class="line">    <span class="type">long</span> <span class="variable">oldElements</span> <span class="operator">=</span> elements;</span><br><span class="line">    elements |= (<span class="number">1L</span> &lt;&lt; ((Enum)e).ordinal());</span><br><span class="line">    <span class="keyword">return</span> elements != oldElements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要就是根据元素值的<code>ordinal</code>决定给位向量里哪一位置 1。<br><code>JumboEnumSet</code>的<code>add</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    typeCheck(e);</span><br><span class="line">    <span class="type">int</span> <span class="variable">eOrdinal</span> <span class="operator">=</span> e.ordinal();</span><br><span class="line">    <span class="type">int</span> <span class="variable">eWordNum</span> <span class="operator">=</span> eOrdinal &gt;&gt;&gt; <span class="number">6</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">oldElements</span> <span class="operator">=</span> elements[eWordNum];</span><br><span class="line">    elements[eWordNum] |= (<span class="number">1L</span> &lt;&lt; eOrdinal);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> (elements[eWordNum] != oldElements);</span><br><span class="line">    <span class="keyword">if</span>(result)</span><br><span class="line">    	size++;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个思路和上面<code>RegularEnumSet</code>的思路类似，只是多了一个寻找位向量下标的操作。如前面的内容，不论左移还是右移，移动的位数不是直接使用后面的数字。对<code>int</code>移位是取后面数字的低 5 位作为移动位数，<code>long</code>是取 6 位。<br>其它的方法<code>JumboEnumSet</code>的实现和<code>RegularEnumSet</code>都是类似的，只不过都多了寻找下标的操作。因此，后面我们主要看<code>RegularEnumSet</code>的实现。<br>我们再看<code>RegularEnumSet</code>的<code>remove</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(e == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">eClass</span> <span class="operator">=</span> e.getClass();</span><br><span class="line">    <span class="keyword">if</span>(eClass != elementType &amp;&amp; eClass.getSuperclass() != elementType)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">oldElements</span> <span class="operator">=</span> elements;</span><br><span class="line">    elements &amp;= ~(<span class="number">1L</span> &lt;&lt; ((Enum)e).ordinal());</span><br><span class="line">    <span class="keyword">return</span> elements != oldElements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要思路就是将要删除的位置为 0，其余位置为 1，然后再与位向量相与即可。<br>再看<code>contains</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(e == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;<span class="type">Class</span> <span class="variable">eClass</span> <span class="operator">=</span> e.getClass();</span><br><span class="line">    <span class="keyword">if</span>(eClass != elementType &amp;&amp; eClass.getSuperclass() != elementType)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (elements &amp; (<span class="number">1L</span> &lt;&lt; ((Enum)e).ordinal())) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是<code>EnumSet</code>的工厂方法<code>complementOf</code>，它能够求补集，内部调用的是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">complement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(universe.length != <span class="number">0</span>) &#123;</span><br><span class="line">        elements = ~elements;</span><br><span class="line">        elements &amp;= -<span class="number">1L</span> &gt;&gt;&gt; -universe.length; <span class="comment">// Mask unused bits</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求补集本来是直接取反就可以了，但是考虑的位向量里面可能存在没使用到的位。例如枚举值一共就 7 种可能，使用一个<code>long</code>存储，那么高 57 位是用不到的，默认都是置 0，取反就变成 1 了。因此，就有了最后一句话<code>elements &amp;= -1L &gt;&gt;&gt; -universe.length</code>，需要注意的是移动<code>-universe.length</code>位相当于移动<code>64 - universe.length</code>位。</p>
<h3 id="堆和优先级队列"><a href="#堆和优先级队列" class="headerlink" title="堆和优先级队列"></a>堆和优先级队列</h3><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>首先堆是一棵完全二叉树，完全二叉树比满二叉树的约束要小一点。满二叉树（图A）里所有非叶子节点都有两个孩子，且叶子节点只会出现在最后一行，这就要求最后一行是满的。而完全二叉树（图B）相对于满二叉树不要求最后一行是满的，如果最后一行不满，所有节点必须从左到右依次排列，中间不能空着。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703830772252-25bb81af-ee4e-48ae-ac55-3704b0125d0d.png#averageHue=%23f8f8f8&clientId=u934a904e-b132-4&from=paste&height=194&id=u028b7d8b&originHeight=528&originWidth=978&originalType=binary&ratio=2&rotation=0&showTitle=false&size=154093&status=done&style=none&taskId=u64edecb3-23c4-49c9-a354-7d8c2cf0b82&title=&width=360" alt="image.png"><br>（A）满二叉树<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703830824298-c5b974e8-52f4-41f0-a562-092f60fe8e9e.png#averageHue=%23f8f8f8&clientId=u934a904e-b132-4&from=paste&height=194&id=ue24b42ca&originHeight=702&originWidth=1040&originalType=binary&ratio=2&rotation=0&showTitle=false&size=168948&status=done&style=none&taskId=ueaa73243-2fd6-41ad-a799-ead44df8854&title=&width=287" alt="image.png"><br>（B）完全二叉树<br>如上图（B），我们可以给一个完全二叉树里面的节点从 1 开始、自上而下、自左到右编号。我们发现对任意一个节点<code>i</code>：</p>
<ul>
<li>它的父节点编号是<code>i / 2</code>；</li>
<li>它的子节点编号分别是<code>i * 2</code>和<code>i * 2 + 1</code>。</li>
</ul>
<p>这样的特性很好，因为这样我们就可以物理上使用数组来存储逻辑上的树，这可以有效提升随机访问的效率。在堆中不要求元素之间完全有序，但对于父子之间存在一定的顺序，按照顺序可以把堆分成：最大堆和最小堆。<br>最大堆里面任意一个节点的值都不能大于父节点的值，最小堆则相反。因此最大堆的根节点是整个树里值最大的，最小堆则是最小的。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703832887812-70b3fd55-b329-4077-8914-a1862a5d9d09.png#averageHue=%23fbfbfb&clientId=u934a904e-b132-4&from=paste&height=250&id=u76817a50&originHeight=504&originWidth=830&originalType=binary&ratio=2&rotation=0&showTitle=false&size=118276&status=done&style=none&taskId=ub5c048e7-b402-4c9d-ae52-bebc0f591da&title=&width=412" alt="image.png"><br>最大堆例图<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703832899714-f044e380-9169-454c-a712-928ae02316b8.png#averageHue=%23fbfbfb&clientId=u934a904e-b132-4&from=paste&height=250&id=u63c202ac&originHeight=512&originWidth=834&originalType=binary&ratio=2&rotation=0&showTitle=false&size=122626&status=done&style=none&taskId=u40817453-adb9-48ef-b547-c6cccf1beb6&title=&width=407" alt="image.png"><br>最小堆例图</p>
<h5 id="堆的算法"><a href="#堆的算法" class="headerlink" title="堆的算法"></a>堆的算法</h5><p>最大堆和最小堆的算法都是类似的，下面的算法以最小堆举例子。</p>
<h6 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h6><p>所谓添加元素就是往最小堆里面添加元素并继续保持最小堆的特性：</p>
<ol>
<li>如果堆是空的那么直接添加一个根就行。</li>
<li>如果堆不空那么先将元素添加到最后并重复做：<ul>
<li>若元素值不小于父节点的值或元素没有父节点则结束</li>
<li>元素值小于父节点的值就和父节点交换位置</li>
</ul>
</li>
</ol>
<p>假设我们想在已存在的树里面追加一个节点 3，我们画图看一下例子：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703834638239-32f40a68-8071-4134-b201-ab8c3d3b13b1.png#averageHue=%23fbfbfb&clientId=u934a904e-b132-4&from=paste&height=220&id=qgrNk&originHeight=560&originWidth=914&originalType=binary&ratio=2&rotation=0&showTitle=false&size=142072&status=done&style=none&taskId=uecace63f-9d7a-479d-b7c3-33b4607c03b&title=&width=359" alt="image.png"><br>（a）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703834676625-b9a62ee0-af57-459c-babc-522f42ec9a62.png#averageHue=%23f9f9f9&clientId=u934a904e-b132-4&from=paste&height=270&id=oOZp3&originHeight=540&originWidth=898&originalType=binary&ratio=2&rotation=0&showTitle=false&size=151995&status=done&style=none&taskId=ua6a90f37-f1dc-466c-acd5-23253721db5&title=&width=449" alt="image.png"><br>（c）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703834719346-18dbc976-1a3a-4f61-b07e-c1e5061756b1.png#averageHue=%23fafafa&clientId=u934a904e-b132-4&from=paste&height=270&id=HIjrW&originHeight=540&originWidth=892&originalType=binary&ratio=2&rotation=0&showTitle=false&size=146941&status=done&style=none&taskId=u23c06b6d-1850-476b-8f09-e4963acd053&title=&width=446" alt="image.png"><br>（e）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703834656419-b4687e70-bc75-4aa1-b39b-11db1d3ef56e.png#averageHue=%23fafafa&clientId=u934a904e-b132-4&from=paste&height=220&id=VMGOI&originHeight=534&originWidth=890&originalType=binary&ratio=2&rotation=0&showTitle=false&size=147980&status=done&style=none&taskId=u5a0bdc0a-8ee8-4596-b929-23b234467ad&title=&width=367" alt="image.png"><br>（b）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703834696308-e3f469b4-1256-4f69-9df3-ae862f64f21a.png#averageHue=%23fafafa&clientId=u934a904e-b132-4&from=paste&height=267&id=eOfdl&originHeight=534&originWidth=884&originalType=binary&ratio=2&rotation=0&showTitle=false&size=148507&status=done&style=none&taskId=ub61d985e-e3a3-4122-94b1-54f4082c43c&title=&width=442" alt="image.png"><br>（d）<br>我们把这样满足自底向上比较、交换使得树满足堆性质的过程称为<strong>向上调整（siftup）</strong>。</p>
<h6 id="头部删除元素"><a href="#头部删除元素" class="headerlink" title="头部删除元素"></a>头部删除元素</h6><p>队列中一种常用操作是从头部删除元素，Java 是用堆实现优先级队列的。堆里面删除头部元素的一般步骤是：</p>
<ol>
<li>用最后一个元素替换头部元素并删除最后一个元素；</li>
<li>从头部开始，将元素与其孩子节点比较：<ol>
<li>若元素不小于孩子节点，结束；</li>
<li>若元素小于孩子节点，则将元素与其较小的孩子交换；</li>
<li>重复上述过程直到树满足最小堆。</li>
</ol>
</li>
</ol>
<p>下面描述了一个最小堆里删除头元素的过程：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703839847513-e4bce9d6-13ed-4d89-b99d-1a0f818ce192.png#averageHue=%23fbfbfb&clientId=u934a904e-b132-4&from=paste&height=228&id=ua7c8d7a0&originHeight=245&originWidth=387&originalType=binary&ratio=2&rotation=0&showTitle=false&size=38724&status=done&style=none&taskId=u50a752c7-b763-4790-8bc8-e334d373f72&title=&width=360" alt="image.png"><br>（a）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703839912798-7bd735d8-bb5d-47fc-b793-d4966c8c469a.png#averageHue=%23fafafa&clientId=u934a904e-b132-4&from=paste&height=228&id=u863f73cb&originHeight=228&originWidth=362&originalType=binary&ratio=2&rotation=0&showTitle=false&size=34089&status=done&style=none&taskId=u5fdcdb90-0efd-4325-b955-b17e0185941&title=&width=362" alt="image.png"><br>（c）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703839875343-d7e76d6b-3951-4ffa-90ed-a764b2942baf.png#averageHue=%23fafafa&clientId=u934a904e-b132-4&from=paste&height=228&id=ue0e24dc8&originHeight=227&originWidth=364&originalType=binary&ratio=2&rotation=0&showTitle=false&size=36670&status=done&style=none&taskId=u93c09756-015e-4fef-be5c-66a6b1dbcc9&title=&width=366" alt="image.png"><br>（b）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703839928727-e6afbdce-462f-45c5-b723-787450ffdbc3.png#averageHue=%23fafafa&clientId=u934a904e-b132-4&from=paste&height=225&id=ubc86baf6&originHeight=225&originWidth=364&originalType=binary&ratio=2&rotation=0&showTitle=false&size=33052&status=done&style=none&taskId=ucdd89eea-f432-44c4-9ac6-317f05ad2ef&title=&width=364" alt="image.png"><br>（d）<br>我们把这样满足自上向下比较、交换使得树满足堆性质的过程称为<strong>向下调整（siftdown）</strong>。</p>
<h6 id="中间删除元素"><a href="#中间删除元素" class="headerlink" title="中间删除元素"></a>中间删除元素</h6><p>从堆中间删除元素和从头部删除类似，我们先用结尾的元素替换要删除的元素。替换后做判断：若该元素小于父元素就向上调整，若该元素大于子元素就向下调整。<br>删除节点 21 的示例图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703840299441-2ab492ca-5c31-4052-a693-0bb41f7ce059.png#averageHue=%23f8f8f8&clientId=u934a904e-b132-4&from=paste&height=228&id=ued366b86&originHeight=216&originWidth=349&originalType=binary&ratio=2&rotation=0&showTitle=false&size=38038&status=done&style=none&taskId=ua61946e8-007a-42d5-9ba8-14fb4d39a21&title=&width=368" alt="image.png"><br>（a）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703840317301-e382bf81-0c76-4e87-b012-418bccf80e32.png#averageHue=%23f8f8f8&clientId=u934a904e-b132-4&from=paste&height=228&id=ufbcce7a2&originHeight=216&originWidth=350&originalType=binary&ratio=2&rotation=0&showTitle=false&size=38964&status=done&style=none&taskId=uabda82cd-e57e-441b-a65e-e7d1fb48da2&title=&width=369" alt="image.png"><br>（b）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703840334386-5b34380d-694d-4bef-a6b0-681ace21a569.png#averageHue=%23f9f9f9&clientId=u934a904e-b132-4&from=paste&height=228&id=u5652cfe1&originHeight=232&originWidth=369&originalType=binary&ratio=2&rotation=0&showTitle=false&size=38467&status=done&style=none&taskId=u6bd7edab-46fe-4e5d-b3ea-1bc9e4d88ff&title=&width=363" alt="image.png"><br>（c）<br>删除节点 9 的示例图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703840351373-1fb56801-420e-45cf-bb42-f363e0ced05d.png#averageHue=%23f9f9f9&clientId=u934a904e-b132-4&from=paste&height=228&id=uf2979300&originHeight=211&originWidth=338&originalType=binary&ratio=2&rotation=0&showTitle=false&size=35550&status=done&style=none&taskId=u319eba56-f02c-450c-a0b9-1620a655887&title=&width=365" alt="image.png"><br>（a）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703840370163-af7026a4-1d87-4a49-baff-65d8602e96df.png#averageHue=%23f9f9f9&clientId=u934a904e-b132-4&from=paste&height=228&id=u1792f8c8&originHeight=212&originWidth=338&originalType=binary&ratio=2&rotation=0&showTitle=false&size=35930&status=done&style=none&taskId=u9e8fc7dc-c30f-47b9-963f-ce7cdd4a6dc&title=&width=364" alt="image.png"><br>（b）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1703840384843-02bf0b28-d32f-4352-927a-a1a3e754c350.png#averageHue=%23f8f8f8&clientId=u934a904e-b132-4&from=paste&height=228&id=u9275004b&originHeight=228&originWidth=372&originalType=binary&ratio=2&rotation=0&showTitle=false&size=39360&status=done&style=none&taskId=u09aed5e9-fb41-472f-87de-63c79f69c12&title=&width=372" alt="image.png"><br>（c）</p>
<h6 id="构建初始堆"><a href="#构建初始堆" class="headerlink" title="构建初始堆"></a>构建初始堆</h6><p>将一个无序数组构建成堆的过程称为<code>heapify</code>，基本过程是从最后一个非叶子节点开始直到第一个节点，对这里面的每一个节点都执行一次向下调整。说白了就是从小树到大树，将每一棵树都构建成堆，到最后整棵树就成为了堆。<br>不妨假设树里面有<code>size</code>个节点，那么最后一个非叶子节点的下标是<code>size / 2</code>。因为对于任一节点<code>i</code>，如果下标为<code>2 * i</code>的节点存在于树里，那么<code>i</code>就不会是叶子节点，反之也成立。构建初始堆的示意代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size / <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        siftdown(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="查找和遍历"><a href="#查找和遍历" class="headerlink" title="查找和遍历"></a>查找和遍历</h6><p>在堆中进行查找本质上就是在数组里进行查找，只需要从头到尾遍历一遍数组即可。<br>遍历和查找类似，但需要注意的是堆的第一个元素一定是最大值或最小值。有趣的是，我们逐个从头部删除元素，可以确保输出是有序的。</p>
<h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p><code>PriorityQueue</code>是优先级队列，它的内部是使用堆实现的。它实现了<code>Queue</code>接口，与<code>LinkedList</code>类似，队列长度没有限制。与一般队列有所区别的是，队列里面的元素都具有一个优先级，队头的元素永远是优先级最高的。</p>
<h5 id="用法-4"><a href="#用法-4" class="headerlink" title="用法"></a>用法</h5><p><code>Queue</code>接口我们之前说过了，为了方便，这边再重新看一下定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;  <span class="comment">// 尾部添加元素，队满时抛异常</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>;  <span class="comment">// 尾部添加元素，队满时返回 false</span></span><br><span class="line">    E <span class="title function_">remove</span><span class="params">()</span>;  <span class="comment">// 头部删除元素，队空时抛异常</span></span><br><span class="line">    E <span class="title function_">poll</span><span class="params">()</span>;  <span class="comment">// 头部删除元素，队空时返回 null</span></span><br><span class="line">    E <span class="title function_">element</span><span class="params">()</span>;  <span class="comment">// 查看头部元素，队空时抛异常</span></span><br><span class="line">    E <span class="title function_">peek</span><span class="params">()</span>;  <span class="comment">// 查看头部元素，队空时返回 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PriorityQueue</code>有多个构造，部分构造如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(<span class="type">int</span> initialCapacity, Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span><br></pre></td></tr></table></figure>
<p><code>PriorityQueue</code>是用堆实现的，物理上就是数组，一个能动态扩展的数组。数组默认大小是 11，可以传递<code>initialCapacity</code>表示初始数组的大小，也可以传递一个集合那么集合元素的数目就是初始数组的大小。为了保持元素的顺序，<code>PriorityQueue</code>要求元素要么实现<code>Comparable</code>接口，要么传递一个<code>Comparator</code>进去。看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">pq.offer(<span class="number">10</span>);</span><br><span class="line">pq.add(<span class="number">22</span>);</span><br><span class="line">pq.addAll(Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;</span><br><span class="line">	<span class="number">11</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">19</span>, <span class="number">13</span> &#125;));</span><br><span class="line"><span class="keyword">while</span>(pq.peek() != <span class="literal">null</span>)&#123;</span><br><span class="line">    System.out.print(pq.poll() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次我们从头部删除一个元素，所以输出的是一个升序的序列。如果需要降序，可以自己传递一个<code>Comparator</code>进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="number">11</span>, Collections.reverseOrder());</span><br></pre></td></tr></table></figure>
<p>我们定义一个任务类，里面有优先级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Task&gt; taskComparator = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Task&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Task o1, Task o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o2.priority - o1.priority;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(String name, <span class="type">int</span> priority)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.priority = priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPriority</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Task&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="number">11</span>, Task.taskComparator);</span><br><span class="line">pq.addAll(Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;看电视&quot;</span>, <span class="number">10</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;研究技术&quot;</span>, <span class="number">50</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;看书&quot;</span>, <span class="number">30</span>))</span><br><span class="line">);</span><br><span class="line"><span class="keyword">while</span> (pq.peek() != <span class="literal">null</span>) &#123;  <span class="comment">// 按优先级输出各个任务</span></span><br><span class="line">    <span class="type">Task</span> <span class="variable">t</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">    System.out.println(t.name + <span class="string">&quot; &quot;</span> + t.priority);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h5><h6 id="成员及构造"><a href="#成员及构造" class="headerlink" title="成员及构造"></a>成员及构造</h6><p><code>PriorityQueue</code>内部有如下成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> E&gt; comparator;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>queue</code>是存储元素的数组；</li>
<li><code>size</code>是元素的个数；</li>
<li><code>comparator</code>是比较器；</li>
<li><code>modCount</code>表示队列结构化修改的次数。</li>
</ul>
<p>我们说<code>PriorityQueue</code>使用堆实现，和上面介绍的堆不同的是，节点编号从 0 开始即存储的时候从数组下标 0 的地方开始存储。那么对于任意下标<code>i</code>：</p>
<ul>
<li>父节点下标是<code>(i - 1) / 2</code></li>
<li>子节点的下标是<code>i * 2 + 1</code>与<code>i * 2 + 2</code></li>
</ul>
<p>我们再看看<code>PriorityQueue</code>几个基本的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(initialCapacity, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(<span class="type">int</span> initialCapacity, Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h6><p>两种添加方法实现差不多，只不过满队时一个抛异常一个不抛。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(e == <span class="literal">null</span>)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= queue.length)  <span class="comment">// 队列不够就扩容</span></span><br><span class="line">    	grow(i + <span class="number">1</span>);</span><br><span class="line">    size = i + <span class="number">1</span>;  <span class="comment">// 元素个数 +1</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)  <span class="comment">// 第一次添加直接加在队头</span></span><br><span class="line">    	queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 放在最后，向上调整</span></span><br><span class="line">    	siftUp(i, e);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> queue.length;</span><br><span class="line">    <span class="comment">// 目前容量不满 64 就翻倍否则增加 50%</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">        (oldCapacity + <span class="number">2</span>) : (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span>(newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    	newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 数组拷贝</span></span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向上调整的方法分为使用比较器和<code>Comparable</code>两种，逻辑都一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(comparator != <span class="literal">null</span>)</span><br><span class="line">    	siftUpUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> queue[parent];</span><br><span class="line">        <span class="keyword">if</span>(comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意因为下标从 0 开始，所以节点<code>i</code>的父节点下标是<code>(i - 1) / 2</code>。</p>
<h6 id="头部元素"><a href="#头部元素" class="headerlink" title="头部元素"></a>头部元素</h6><p>取头部元素比较简单，主体逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) queue[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除头部元素"><a href="#删除头部元素" class="headerlink" title="删除头部元素"></a>删除头部元素</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> (E) queue[<span class="number">0</span>];</span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) queue[s];</span><br><span class="line">    queue[s] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(s != <span class="number">0</span>)</span><br><span class="line">    	siftDown(<span class="number">0</span>, x);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(comparator != <span class="literal">null</span>)</span><br><span class="line">    	siftDownUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownComparable</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> E&gt; key = (Comparable&lt;? <span class="built_in">super</span> E&gt;)x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">//loop while a non-leaf</span></span><br><span class="line">    <span class="keyword">while</span>(k &lt; half) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">//assume left child is least</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; size &amp;&amp;</span><br><span class="line">          ((Comparable&lt;? <span class="built_in">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">        	c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span>(key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是下标<code>i</code>的孩子分别是<code>2 * i + 1</code>和<code>2 * i + 2</code>。</p>
<h6 id="根据值删除元素"><a href="#根据值删除元素" class="headerlink" title="根据值删除元素"></a>根据值删除元素</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexOf(o);</span><br><span class="line">    <span class="keyword">if</span>(i == -<span class="number">1</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        removeAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从前到后比较</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] es = queue;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = size; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(es[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">removeAt</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; size;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> --size;</span><br><span class="line">    <span class="keyword">if</span>(s == i) <span class="comment">// removed last element</span></span><br><span class="line">    	queue[i] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">moved</span> <span class="operator">=</span> (E) queue[s];</span><br><span class="line">        queue[s] = <span class="literal">null</span>;</span><br><span class="line">        siftDown(i, moved);</span><br><span class="line">        <span class="keyword">if</span>(queue[i] == moved) &#123;</span><br><span class="line">        	siftUp(i, moved);</span><br><span class="line">            <span class="keyword">if</span>(queue[i] != moved)</span><br><span class="line">            	<span class="keyword">return</span> moved;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>removeAt</code>方法有一个返回值，但是返回的不是删除掉的元素。我们知道删除掉元素<code>i</code>之后，会将最后一个元素放过来，然后执行向上或向下调整。如果成功向上调整了（元素被放到下标小于<code>i</code>的地方），那么返回原来的最后一个元素，否则返回<code>null</code>。这么设计的原因是保证遍历的时候不会漏掉元素。</p>
<h6 id="构造堆"><a href="#构造堆" class="headerlink" title="构造堆"></a>构造堆</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initFromCollection</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    initElementsFromCollection(c);</span><br><span class="line">    heapify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initElementsFromCollection</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">if</span>(a.getClass() != Object[].class)</span><br><span class="line">    	a = Arrays.copyOf(a, a.length, Object[].class);</span><br><span class="line">    <span class="built_in">this</span>.queue = a;</span><br><span class="line">    <span class="built_in">this</span>.size = a.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    	siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面有一句奇怪的话<code>a.getClass() != Object[].class</code>，为什么两者会不想等？<br><code>a.getClass()</code>的静态类型是<code>Object[]</code>，但动态类型可能是<code>Integer[]</code>或者其它。使用<code>a.getClass()</code>获取的是动态类型而不是静态类型。而使用<code>Object[].class</code>获取到的类型一定是<code>Object[]</code>，因此需要判定一下两者是否一样。</p>
<h4 id="PriorityQueue-的应用"><a href="#PriorityQueue-的应用" class="headerlink" title="PriorityQueue 的应用"></a>PriorityQueue 的应用</h4><h5 id="前-K-个最大元素"><a href="#前-K-个最大元素" class="headerlink" title="前 K 个最大元素"></a>前 K 个最大元素</h5><p>想要求一个数组里最大的 K 个元素，甚至数据可能会源源不断的到来，需要动态的维护这 K 个元素。</p>
<ul>
<li>对数组排序，排完序直接取前 K 个元素即可，时间复杂度是$O(N\times logN)$。</li>
<li>先找最大的，然后在剩下里面找最大的，重复 K 次即可，时间复杂度为$O(N\times K)$。</li>
<li>新开一个长度为 K 的数组用来保存最大的 K 个元素，每次添加元素的时候都将元素与这 K 个元素的最小值比较，若大于该最小值就替换掉这个最小值。</li>
</ul>
<p>前两种没什么好说的，第三种如果我们使用堆来存储最大的 K 个元素那么插入的时间复杂度可以降为$O(logK)$，整体的时间复杂度就变为$O(N\times logK)$。<br>因为我们每次比较的时候都是使用 K 个元素里面最小值进行比较的，所以我们应该维护一个最小堆，这样最小值就是堆的根元素。看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TopK</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;E&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;E&gt; p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TopK</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        <span class="built_in">this</span>.p = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.size() &lt; k) &#123;  <span class="comment">// 元素不满 k 个直接插入</span></span><br><span class="line">            p.add(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Comparable&lt;E&gt; min = p.peek();</span><br><span class="line">        <span class="keyword">if</span> (min.compareTo(e) &gt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        p.poll();</span><br><span class="line">        p.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;E&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">            add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E[] toArray(E[] a) &#123;</span><br><span class="line">        <span class="keyword">return</span> p.toArray(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TopK&lt;Integer&gt; top = <span class="keyword">new</span> <span class="title class_">TopK</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">top.addAll(Arrays.asList(<span class="number">20</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">22</span>, <span class="number">19</span>, <span class="number">49</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>));</span><br><span class="line">System.out.println(Arrays.toString(top.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">0</span>])));</span><br></pre></td></tr></table></figure>
<p>代码输出<code>[10, 19, 20, 22, 49]</code>，堆里保存了最大的 5 个元素。</p>
<h5 id="求中位数"><a href="#求中位数" class="headerlink" title="求中位数"></a>求中位数</h5><p>中位数就是数据排序之后位于中间位置的数，若数据总数是奇数那么中位数没有歧义，若数据总数是偶数，中间将会有两个数字，此时中位数可以是：较小的那个、较大的那个、随便一个、两者的平均值。<br>我们当然可以使用排序来寻找中位数，但没有必要，尤其是数据源源不断添加的情况下排序效率很低。我们可以维护两个堆，最大堆维护比中位数小的数，最小堆维护比中位数大的数，具体流程如下：</p>
<ul>
<li>假设中位数用<code>m</code>保存，最大堆里的元素都<code>≤m</code>，最小堆的元素都<code>≥m</code>。</li>
<li>当新元素<code>e</code>到达时，若<code>e ≤ m</code>将<code>e</code>插入到最大堆，否则插入到最小堆。</li>
<li>当两个堆的元素数目差<code>≥2</code>时做以下调整：<ul>
<li>设元素较少的堆为<code>A</code>，元素较多的堆为<code>B</code>；</li>
<li>将<code>m</code>插入到<code>A</code>中，同时将<code>B</code>的根拿出来作为新的中位数赋值给<code>m</code>。</li>
</ul>
</li>
</ul>
<p>所有元素插入完成之后，若两个堆元素数目一样，那么<code>m</code>就是唯一的中位数；若元素数目不一样，那么两个堆元素数目差必然为 1，取出元素较多的堆的根，这个根就是另一个中位数，拿到两个中位数之后取大的还是小的或者平均值都很简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Median</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;E&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> E m;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;E&gt; minP;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;E&gt; maxP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Median</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.minP = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.maxP = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="number">11</span>, Collections.reverseOrder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="literal">null</span>) &#123;</span><br><span class="line">            m = e;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e.compareTo(m) &lt;= <span class="number">0</span>) maxP.add(e);</span><br><span class="line">        <span class="keyword">else</span> minP.add(e);</span><br><span class="line">        <span class="keyword">if</span> (minP.size() - maxP.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            maxP.add(m);</span><br><span class="line">            m = minP.poll();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxP.size() - minP.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            minP.add(m);</span><br><span class="line">            m = maxP.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;E&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">            add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getM</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Median&lt;Integer&gt; median = <span class="keyword">new</span> <span class="title class_">Median</span>&lt;&gt;();</span><br><span class="line">median.addAll(Arrays.asList(<span class="number">20</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">22</span>, <span class="number">19</span>, <span class="number">49</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>));</span><br><span class="line">System.out.println(median.getM());</span><br></pre></td></tr></table></figure>
<p>我们代码认为的中位数没有明确要求总数为偶数时取较小还是较大，测试代码输出结果是<code>10</code>。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag"># 后端</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2023/04/14/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8804%EF%BC%89/" rel="next" title="Java 基础系列（04）">
                <i class="fa fa-chevron-left"></i> Java 基础系列（04）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2023/05/03/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8806%EF%BC%89/" rel="prev" title="Java 基础系列（06）">
                Java 基础系列（06） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/index.html">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Map-Set"><span class="nav-number">1.</span> <span class="nav-text">Map &amp; Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">总述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap"><span class="nav-number">1.2.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%B3%95"><span class="nav-number">1.2.1.</span> <span class="nav-text">用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">1.2.2.</span> <span class="nav-text">原理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%88%90%E5%91%98"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">成员</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E9%80%A0"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">构造</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">保存</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">删除</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.2.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet"><span class="nav-number">1.3.</span> <span class="nav-text">HashSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TreeMap"><span class="nav-number">1.4.</span> <span class="nav-text">TreeMap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">1.4.1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-1"><span class="nav-number">1.4.2.</span> <span class="nav-text">原理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%BB%84%E6%88%90"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">内部组成</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">保存键值对</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%A8%E9%94%AE%E8%8E%B7%E5%8F%96%E5%80%BC"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">用键获取值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%80%BC"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">查找值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">删除键值对</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">1.4.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TreeSet"><span class="nav-number">1.5.</span> <span class="nav-text">TreeSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedHashMap"><span class="nav-number">1.6.</span> <span class="nav-text">LinkedHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%B3%95-1"><span class="nav-number">1.6.1.</span> <span class="nav-text">用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-2"><span class="nav-number">1.6.2.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">1.6.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedHashSet"><span class="nav-number">1.7.</span> <span class="nav-text">LinkedHashSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EnumMap"><span class="nav-number">1.8.</span> <span class="nav-text">EnumMap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%B3%95-2"><span class="nav-number">1.8.1.</span> <span class="nav-text">用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-3"><span class="nav-number">1.8.2.</span> <span class="nav-text">原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EnumSet"><span class="nav-number">1.9.</span> <span class="nav-text">EnumSet</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%B3%95-3"><span class="nav-number">1.9.1.</span> <span class="nav-text">用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B"><span class="nav-number">1.9.2.</span> <span class="nav-text">案例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-4"><span class="nav-number">1.9.3.</span> <span class="nav-text">原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="nav-number">2.</span> <span class="nav-text">堆和优先级队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">2.1.</span> <span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">2.1.2.</span> <span class="nav-text">堆的算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">添加元素</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%B4%E9%83%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">头部删除元素</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">中间删除元素</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%88%9D%E5%A7%8B%E5%A0%86"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">构建初始堆</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%92%8C%E9%81%8D%E5%8E%86"><span class="nav-number">2.1.2.5.</span> <span class="nav-text">查找和遍历</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PriorityQueue"><span class="nav-number">2.2.</span> <span class="nav-text">PriorityQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%B3%95-4"><span class="nav-number">2.2.1.</span> <span class="nav-text">用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E7%90%86-5"><span class="nav-number">2.2.2.</span> <span class="nav-text">原理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%8A%E6%9E%84%E9%80%A0"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">成员及构造</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">添加</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%B4%E9%83%A8%E5%85%83%E7%B4%A0"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">头部元素</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%A4%B4%E9%83%A8%E5%85%83%E7%B4%A0"><span class="nav-number">2.2.2.4.</span> <span class="nav-text">删除头部元素</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E5%80%BC%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">2.2.2.5.</span> <span class="nav-text">根据值删除元素</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%A0%86"><span class="nav-number">2.2.2.6.</span> <span class="nav-text">构造堆</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PriorityQueue-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">2.3.</span> <span class="nav-text">PriorityQueue 的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%8D-K-%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="nav-number">2.3.1.</span> <span class="nav-text">前 K 个最大元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B1%82%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number">2.3.2.</span> <span class="nav-text">求中位数</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lu Yan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
