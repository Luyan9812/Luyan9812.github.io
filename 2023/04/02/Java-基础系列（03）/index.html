<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java,后端," />










<meta name="description" content="常用基础类包装类Java 有 8 中基本类型，每种类型都有一种对应的包装类。具体的对应关系如下：    基本类型 包装类 基本类型 包装类    boolean Boolean long Long   byte Byte float Float   short Short double Double   int Integer char Character   装箱与拆箱Java 里面基本数据类型">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 基础系列（03）">
<meta property="og:url" content="http://example.com/2023/04/02/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8803%EF%BC%89/index.html">
<meta property="og:site_name" content="Luyan&#39;s Bolg">
<meta property="og:description" content="常用基础类包装类Java 有 8 中基本类型，每种类型都有一种对应的包装类。具体的对应关系如下：    基本类型 包装类 基本类型 包装类    boolean Boolean long Long   byte Byte float Float   short Short double Double   int Integer char Character   装箱与拆箱Java 里面基本数据类型">
<meta property="og:locale">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1701769281175-4a9a9e0e-08a0-4491-a9af-4f6ac0554315.png#averageHue=%23e8e8e8&clientId=u0ba36842-4240-4&from=paste&height=406&id=ub843fc3d&originHeight=406&originWidth=953&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109456&status=done&style=none&taskId=u0c568dd7-a17c-48ff-93a9-31275a48d85&title=&width=953">
<meta property="article:published_time" content="2023-04-02T04:03:55.000Z">
<meta property="article:modified_time" content="2024-08-02T04:17:16.612Z">
<meta property="article:author" content="Lu Yan">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="后端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2023/png/1561375/1701769281175-4a9a9e0e-08a0-4491-a9af-4f6ac0554315.png#averageHue=%23e8e8e8&clientId=u0ba36842-4240-4&from=paste&height=406&id=ub843fc3d&originHeight=406&originWidth=953&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109456&status=done&style=none&taskId=u0c568dd7-a17c-48ff-93a9-31275a48d85&title=&width=953">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2023/04/02/Java-基础系列（03）/"/>





  <title>Java 基础系列（03） | Luyan's Bolg</title>
  








<meta name="generator" content="Hexo 7.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Luyan's Bolg</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不积跬步，无以至千里；不积小流，无以成江海。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/index.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/02/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8803%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Luyan's Bolg">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java 基础系列（03）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-02T12:03:55+08:00">
                2023-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="常用基础类"><a href="#常用基础类" class="headerlink" title="常用基础类"></a>常用基础类</h3><h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>Java 有 8 中基本类型，每种类型都有一种对应的包装类。具体的对应关系如下：</p>
<table>
<thead>
<tr>
<th><strong>基本类型</strong></th>
<th><strong>包装类</strong></th>
<th><strong>基本类型</strong></th>
<th><strong>包装类</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>Boolean</code></td>
<td><code>long</code></td>
<td><code>Long</code></td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>Byte</code></td>
<td><code>float</code></td>
<td><code>Float</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>Short</code></td>
<td><code>double</code></td>
<td><code>Double</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>Integer</code></td>
<td><code>char</code></td>
<td><code>Character</code></td>
</tr>
</tbody></table>
<h5 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h5><p>Java 里面基本数据类型与其对应的包装类型是可以互相转换的，这称为装箱与拆箱。将基本类型转换成包装类型叫做装箱，反之叫做拆箱。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">bObj</span> <span class="operator">=</span> Boolean.valueOf(b1);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> bObj.booleanValue();</span><br></pre></td></tr></table></figure>
<p>上面使用<code>boolean</code>类型举例子，实际上所有基本类型都是相似的。使用对应包装类型的静态方法<code>valueOf</code>进行装箱，拆箱只需要调用对象的<code>xxxValue</code>方法即可。<br>装箱与拆箱的操作比较繁琐，所以在 Java5 之后引入了自动装箱与拆箱技术。简单说就是可以直接相互赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">bObj</span> <span class="operator">=</span> b1;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> bObj;</span><br></pre></td></tr></table></figure>
<p>自动拆装箱是编译器提供的能力，实际上，背后还是做的上面那一套。<br>每种包装类都有对应的构造方法，例如<code>Boolean bObj = new Boolean(true);</code>。所以我们有两种方法从基本类型转到包装类型：一个是使用<code>valueOf</code>方法，一个是使用<code>new</code>。两者的区别主要是，<code>new</code>出来的对象每次都是新的，而<code>valueOf</code>方法则会维护一个缓存（Float 与 Double除外）提升效率。实际上，从 Java9 开始这些构造方法已经被标记过时了。</p>
<h5 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h5><p>所有包装类都实现了<code>Object</code>类的一些方法并实现了<code>Comparable</code>接口。</p>
<h6 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h6><p><code>equals</code>方法用来判断当前对象与传进来的对象是否相同。<code>Object</code>的默认实现是比较两个对象的引用是否相同（这和<code>==</code>运算符的含义是一样的），这在许多时候是不合适的。对于包装类型而言，我们的比较依据应该是它们值的大小关系，所以所有包装类型都有自己的实现。<br>对于<code>Long</code>类型，其<code>equals</code>实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">    	<span class="keyword">return</span> value == ((Long)obj).longValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>Float</code>类型，其实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (obj <span class="keyword">instanceof</span> Float)</span><br><span class="line">    	&amp;&amp; (floatToIntBits(((Float)obj).value) == floatToIntBits(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从实现可以看出浮点数比较看的是静态函数<code>floatToIntBits</code>的返回值，这个函数指的是将浮点数的二进制看做一个<code>int</code>。<br>对于<code>Double</code>类型会调用<code>doubleToLongBits</code>方法，将<code>Double</code>的二进制看做一个<code>long</code>，然后进行比较。</p>
<h6 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h6><p><code>hashCode</code>返回一个对象的哈希值。哈希值是一个<code>int</code>类型的数，对象的哈希值不能改变。同一个对象的哈希值必须一样，不同对象的哈希值一般应不同。<br><code>hashCode</code>与<code>equals</code>方法有密切联系。对两个对象来说，若<code>equals</code>返回<code>true</code>则<code>hashCode</code>必须一样，<code>equals</code>返回<code>false</code>不做要求。<code>hashCode</code>默认实现是将对象地址转成整数，子类若是重写<code>equals</code>方法必须也重写<code>hashCode</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">int</span>)value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Character</code>类直接使用其值作为哈希值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> value ? <span class="number">1231</span> : <span class="number">1237</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Boolean</code>类型根据真假返回两个质数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span>(<span class="type">int</span>)(value ^ (value &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Long</code>类型将高 32 位与低 32 位做异或作为返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> floatToIntBits(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">bits</span> <span class="operator">=</span> doubleToLongBits(value);</span><br><span class="line">    <span class="keyword">return</span>(<span class="type">int</span>)(bits ^ (bits &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于浮点数，将其二进制看做整数然后执行一样的操作。<code>Float</code>将看做<code>Integer</code>，<code>Double</code>将看做<code>Long</code>。</p>
<h6 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo"></a>compareTo</h6><p>每个包装类都实现了<code>Comparable</code>接口，接口里面只有<code>compareTo</code>一个方法。这个方法将当前对象与参数对象作比较，返回一个整数。整数符号为正表示大于，符号为负表示小于，整数为 0 表示相等。<br>各个包装类的实现都是使用基本类型值进行比较，对于<code>Boolean</code>类型来说，<code>false</code>小于<code>true</code>。</p>
<h5 id="包装类与字符串"><a href="#包装类与字符串" class="headerlink" title="包装类与字符串"></a>包装类与字符串</h5><h6 id="字符串转包装类"><a href="#字符串转包装类" class="headerlink" title="字符串转包装类"></a>字符串转包装类</h6><p>各包装类都有<code>valueOf</code>静态方法将字符串转成对应的包装类，这个方法上面还讲过另一种重载形式——将基本类型转成对应的包装类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.valueOf(<span class="string">&quot;false&quot;</span>);</span><br></pre></td></tr></table></figure>
<h6 id="字符串转基本类型"><a href="#字符串转基本类型" class="headerlink" title="字符串转基本类型"></a>字符串转基本类型</h6><p>各包装类还有<code>parseXXX</code>静态方法将字符串转成基本数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;false&quot;</span>);</span><br></pre></td></tr></table></figure>
<h6 id="基本类型转字符串"><a href="#基本类型转字符串" class="headerlink" title="基本类型转字符串"></a>基本类型转字符串</h6><p>各包装类还有静态的<code>toString</code>方法，接受基本数据数据，将之转成字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Boolean.toString(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h5 id="常用常量"><a href="#常用常量" class="headerlink" title="常用常量"></a>常用常量</h5><p>包装类中还定义了一些静态常量，对于<code>Boolean</code>类来说，定义了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">TRUE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">FALSE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>所有数值类型都定义了<code>MAX_VALUE</code>和<code>MIN_VALUE</code>表示该类型能表示的最大或最小范围，对于<code>Integer</code>来说：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_VALUE</span> <span class="operator">=</span> <span class="number">0x80000000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_VALUE</span> <span class="operator">=</span> <span class="number">0x7fffffff</span>;</span><br></pre></td></tr></table></figure>
<p><code>Float</code>和<code>Double</code>还定义了特殊数值，例如对<code>Double</code>而言：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">POSITIVE_INFINITY</span> <span class="operator">=</span> <span class="number">1.0</span> / <span class="number">0.0</span>;  <span class="comment">// 正无穷</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">NEGATIVE_INFINITY</span> <span class="operator">=</span> -<span class="number">1.0</span> / <span class="number">0.0</span>;  <span class="comment">// 负无穷</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">NaN</span> <span class="operator">=</span> <span class="number">0.0d</span> / <span class="number">0.0</span>;  <span class="comment">// 非数值</span></span><br></pre></td></tr></table></figure>
<h5 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h5><p>6 中数值类型的包装类都继承于<code>Number</code>类，这是一个抽象类。它定义了如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="title function_">byteValue</span><span class="params">()</span></span><br><span class="line"><span class="type">short</span> <span class="title function_">shortValue</span><span class="params">()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">intValue</span><span class="params">()</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">longValue</span><span class="params">()</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">floatValue</span><span class="params">()</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">doubleValue</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>通过这些方法，包装类能返回任意类型的基本类型。但如果类型不匹配怎么办？<br>例如对于<code>Integer i = 100</code>，<code>i.byteValue()</code>返回对<code>byte</code>强转后的结果。</p>
<h5 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h5><p>包装类都是不可变的，即对象一旦创建就无法修改。这主要通过下面的方式：</p>
<ul>
<li>所有包装类都声明为<code>final</code>，不可被继承。</li>
<li>内部基本类型值都是<code>final</code>的，且都是私有的。</li>
<li>不提供<code>setter</code>来修改基本类型值。</li>
</ul>
<h4 id="剖析-Integer"><a href="#剖析-Integer" class="headerlink" title="剖析 Integer"></a>剖析 Integer</h4><p><code>Long</code>和<code>Integer</code>相似，所以不多说。本节主要研究一些二进制操作。</p>
<h5 id="位翻转"><a href="#位翻转" class="headerlink" title="位翻转"></a>位翻转</h5><h6 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h6><p>位翻转指的是首尾互换，类似于求逆序。<code>Integer</code>有两个静态方法实现翻转：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">reverseBytes</span><span class="params">(<span class="type">int</span> i)</span></span><br></pre></td></tr></table></figure>
<p>其中<code>reverse</code>表示按位翻转，<code>reverseBytes</code>表示按字节翻转。看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0x12345678</span>;</span><br><span class="line">    System.out.println(Integer.toBinaryString(a));</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> Integer.reverse(a);</span><br><span class="line">    System.out.println(Integer.toBinaryString(r));</span><br><span class="line">    <span class="type">int</span> <span class="variable">rb</span> <span class="operator">=</span> Integer.reverseBytes(a);</span><br><span class="line">    System.out.println(Integer.toHexString(rb));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子会输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10010001101000101011001111000</span></span><br><span class="line"><span class="number">11110011010100010110001001000</span></span><br><span class="line"><span class="number">78563412</span></span><br></pre></td></tr></table></figure>
<p>对于按字节翻转，原来的数字是<code>0x12345678</code>，按字节翻转后是<code>0x78563412</code>。我们知道一个字节是 8 位，而十六进制数里面每个数字都是 4 位，所以一个字节表示十六进制里面的两位数。因此原来数字里面分为<code>12、34、56、78</code>这四个字节，那么翻转之后就是<code>78、56、34、12</code>。<br>对于按位翻转，看上面的结果似乎不对。但实际上，上面的输出结果并不是 32 位，它们前面还有前导 0 被省略掉了，补上之后的输出应该是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00010010001101000101011001111000</span></span><br><span class="line"><span class="number">00011110011010100010110001001000</span></span><br></pre></td></tr></table></figure>
<p>这样看来，按位翻转确实是首尾交换没错了。</p>
<h6 id="按字节翻转实现"><a href="#按字节翻转实现" class="headerlink" title="按字节翻转实现"></a>按字节翻转实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">reverseBytes</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((i &gt;&gt;&gt; <span class="number">24</span>) ) |</span><br><span class="line">        ((i &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF00</span>) |</span><br><span class="line">        ((i &lt;&lt; <span class="number">8</span>) &amp; <span class="number">0xFF0000</span>) |</span><br><span class="line">        ((i &lt;&lt; <span class="number">24</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>左边是按位翻转的源代码，这个代码其实还是比较好理解的，主体思想就是：将每个字节放到它该在的位置，其它位置置为 0，最后将这些数字或在一起即可。</p>
<h6 id="按位翻转实现"><a href="#按位翻转实现" class="headerlink" title="按位翻转实现"></a>按位翻转实现</h6><p>按照一样的思想，我们可以实现按位翻转。但问题是一个<code>Integer</code>有 32 位，按照上面的做法，我们需要将 32 个数字或在一起，很麻烦。下面看看源码的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">//HD, Figure 7-1</span></span><br><span class="line">    i = (i &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span> | (i &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>;</span><br><span class="line">    i = (i &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span> | (i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>;</span><br><span class="line">    i = (i &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span> | (i &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>;</span><br><span class="line">    i = (i &lt;&lt; <span class="number">24</span>) | ((i &amp; <span class="number">0xff00</span>) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">    ((i &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff00</span>) | (i &gt;&gt;&gt; <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码注释“HD”表示一本书《Hacker’s Delight》，中文翻译为《算法心得：高效算法的奥秘》。算法的主要思路就是交换，首先相邻位之间做交换；接着两位为一组，相邻组两两交换；4 位一组，组间两两交换；8 位一组，直接按字节交换结束。<br>十进制数也能使用这个算法：<code>12345678</code>→<code>21 43 65 87</code>→<code>4321 8765</code>→<code>87654321</code>。<br>对于十进制而言使用这样的方法效率不高，但二进制使用这样的方法效率很高。我们首先两两交换每一位，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (i &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span> | (i &amp; <span class="number">0xAAAAAAAA</span>) &gt;&gt;&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>5 的二进制是<code>0101</code>，A 的二进制是<code>1010</code>。因此<code>i &amp; 0x55555555</code>是取 i 的奇数位（从右开始数起），<code>i &amp; 0xAAAAAAAA</code>是取 i 的偶数位。然后奇数位左移 1 位，偶数位右移 1 位，最后两者或在一起就实现了两两交换的操作。<br>这个思路还可以有一点优化<code>i = (i &amp; 0x55555555) &lt;&lt; 1 | (i &gt;&gt;&gt; 1) &amp; 0x55555555</code>。这边只使用了一个常量<code>0x55555555</code>实现，先将 i 右移 1 位，那么偶数位自然变成奇数位。<br>同理，实现 2 位一组的交换的代码如下（3 的二进制是<code>0011</code>，C 的二进制是<code>1100</code>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = (i &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span> | (i &amp; <span class="number">0xCCCCCCCC</span>) &gt;&gt;&gt; <span class="number">2</span>  <span class="comment">// 优化前</span></span><br><span class="line">i = (i &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span> | (i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>  <span class="comment">// 优化后</span></span><br></pre></td></tr></table></figure>
<p>实现 4 位一组交换的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = (i &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span> | (i &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt;&gt; <span class="number">4</span>  <span class="comment">// 优化前</span></span><br><span class="line">i = (i &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span> | (i &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>  <span class="comment">// 优化后</span></span><br></pre></td></tr></table></figure>
<h5 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h5><p><code>Integer</code>类有两个静态方法实现循环移位，分别表示循环左移和循环右移。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rotateLeft</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> distance)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rotateRight</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> distance)</span></span><br></pre></td></tr></table></figure>
<p>循环移位与普通移位的差距在于位溢出的时候会放到另一端，而不是补 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.rotateLeft(a, <span class="number">8</span>);</span><br><span class="line">    println(Integer.toHexString(b));</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> Integer.rotateRight(a, <span class="number">8</span>);</span><br><span class="line">    println(Integer.toHexString(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>左边程序的运行结果是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">34567812</span></span><br><span class="line"><span class="number">78123456</span></span><br></pre></td></tr></table></figure>

<p>这两个函数的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rotateLeft</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (i &lt;&lt; distance) | (i &gt;&gt;&gt; -distance);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rotateRight</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (i &gt;&gt;&gt; distance) | (i &lt;&lt; -distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现里面令人费解的是移动负数。实际上在进行移位的时候，不是直接使用后面的数字作为移动的位数，而是使用后面数字的低 5 位作为移动的位数。因为我们知道<code>Integer</code>一共是 32 位，移位的时候最多移 31 位，再多就没有意义了，而 5 位能表示的最大范围正好是 31，所以会选取后面数字的低 5 位作为移动位数。例如<code>i &gt;&gt;&gt; -8</code>，-8 的二进制是<code>...11000</code>，所以实际上移位的时候会移动 <code>24</code> 位。<br>了解了这个，那么我们看看实现的逻辑。对于 5 位的整数<code>k</code>，<code>-k</code>是对<code>k</code>取反加 1，因此<code>-k + k</code>的二进制会是<code>100000</code>。最后我们发现，移动<code>-k</code>位实际上是移动<code>32 - k</code>位。基于此，源码的实现是很好理解的。</p>
<h5 id="valueOf-方法的实现"><a href="#valueOf-方法的实现" class="headerlink" title="valueOf 方法的实现"></a>valueOf 方法的实现</h5><p>之前我们就说过，创建包装类的时候推荐使用<code>valueOf</code>方法而不是直接<code>new</code>。现在我们看看<code>valueOf</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">    	<span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到使用<code>valueOf</code>里面有一个缓存，每次创建的时候优先拿缓存而不是创建。而包装类都是不可变的，缓存被拿去用不用担心被篡改，非常合理。我们再看看缓存内部是什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">            sun.misc.VM.getSavedProperty(</span><br><span class="line">            <span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">//Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        	cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码不难理解，默认情况下缓存的范围是<code>[-128, 127]</code>。这种共享常用对象的方式是一种设计模式，称为享元模式。</p>
<h4 id="剖析-String"><a href="#剖析-String" class="headerlink" title="剖析 String"></a>剖析 String</h4><p>字符串操作是计算机程序中最常用的操作之一，Java 操作字符串的类主要是<code>String</code>和<code>StringBuilder</code>类。</p>
<h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;卢研&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;真帅&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>创建字符串对象可以直接使用常量赋值或者使用<code>new</code>创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 += s2;</span><br><span class="line">System.out.println(s1 + <span class="string">&quot;!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>字符串对象之间可以使用<code>+</code>表示字符串的连接。还可以使用<code>+=</code>表示连接并赋值。<br><code>String</code>类里面有很多方法可以处理字符串，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字符串是否为空串，空串指的是 length 为 0 的串</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符串的长度即字符个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取范围 [beginIndex, length) 的子串，下标越界会报错</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取范围 [beginIndex, endIndex) 的子串，下标越界会报错</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符 ch 在串里的下标（从左到右第一个），找不到返回 -1</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(<span class="type">int</span> ch)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符串 str 在串里的下标（从左到右第一个），找不到返回 -1</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符 ch 在串里的下标（从右到左第一个），找不到返回 -1</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(<span class="type">int</span> ch)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符串 str 在串里的下标（从右到左第一个），找不到返回 -1</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符串是否包含序列 s</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(CharSequence s)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符串是否以 prefix 开头</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符串是否以 suffix 结尾</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">endsWith</span><span class="params">(String suffix)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回两个串内容是否一样</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回两个串内容是否一样（忽略大小写）</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">(String anotherString)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个串大小，返回一个整数，其符号表示大小关系</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String anotherString)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同上，但忽略大小写</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareToIgnoreCase</span><span class="params">(String str)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转大写，返回的是新串，原串不变</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toUpperCase</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转小写，返回的是新串，原串不变</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toLowerCase</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接两个字符串，返回连接后的结果。返回的是新串，原串不变</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String str)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符替换，将串里所有的 oldChar 替换成 newChar</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replace</span><span class="params">(<span class="type">char</span> oldChar, <span class="type">char</span> newChar)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列替换，将串里所有的 target 替换成 replacement</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除首尾的空白字符</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">trim</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 regex 分割字符串，返回分割后的字符串数组</span></span><br><span class="line"><span class="keyword">public</span> String[] split(String regex)</span><br></pre></td></tr></table></figure>
<h5 id="走进-String"><a href="#走进-String" class="headerlink" title="走进 String"></a>走进 String</h5><p>字符串内部使用<code>char</code>数组表示字符串，实例变量的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure>
<p><code>String</code>有两个和字符数组相关的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[])</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[], <span class="type">int</span> offset, <span class="type">int</span> count)</span></span><br></pre></td></tr></table></figure>
<p>需要说明的是，<code>String</code>会创建一个新数组并将参数的字符复制进去，而不会直接使用参数数组。<code>String</code>里面大部分方法都是操作<code>value</code>数组：</p>
<ul>
<li><code>length()</code>方法返回的就是<code>value</code>数组的长度。</li>
<li><code>substring()</code>方法是根据参数调用构造<code>String(char value[], int offset, int count)</code>创建新字符串并返回。</li>
</ul>
<p>还有很多方法就不一一列举。除此之外，还有很多方法和<code>value</code>数组相关：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 index 下标处的字符</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字符串的数组表示，返回的是 value 的副本不是本身</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">char</span>[] toCharArray()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 value 数组 [srcBegin, srcEnd) 的内容放到数组 dst 下标 dstBegin 开始处</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getChars</span><span class="params">(<span class="type">int</span> srcBegin, <span class="type">int</span> srcEnd, <span class="type">char</span> dst[], <span class="type">int</span> dstBegin)</span></span><br></pre></td></tr></table></figure>
<h5 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h5><p>Java 使用<code>Charset</code>类表示编码，它有两个常用的静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Charset <span class="title function_">defaultCharset</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Charset <span class="title function_">forName</span><span class="params">(String charsetName)</span></span><br></pre></td></tr></table></figure>
<p>第一个方法返回系统的默认编码，第二个方法返回给定名称的<code>Charset</code>对象。常见的名称有<code>UTF-8</code>、<code>GBK</code>、<code>windows-1252</code>等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Charset</span> <span class="variable">charset</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>String</code>提供了以下方法返回字符串按照指定编码的字节表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getBytes()</span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getBytes(String charsetName)</span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getBytes(Charset charset)</span><br></pre></td></tr></table></figure>
<p>第一个没有参数，表示按照默认编码返回字节。<br><code>String</code>类还提供对应的构造根据字节数组和编码来创建字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">byte</span> bytes[], <span class="type">int</span> offset, <span class="type">int</span> length, String charsetName)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">byte</span> bytes[], Charset charset)</span></span><br></pre></td></tr></table></figure>
<h5 id="不可变性-1"><a href="#不可变性-1" class="headerlink" title="不可变性"></a>不可变性</h5><p>与包装类类似，<code>String</code>类也是不可变类。字符串对象一旦创建就不能修改，<code>String</code>很多看似在修改的方法其实都是创建新字符串返回，我们以<code>concat</code>方法举例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">otherLen</span> <span class="operator">=</span> str.length();</span><br><span class="line">    <span class="keyword">if</span>(otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> value.length;</span><br><span class="line">    <span class="type">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到字符串的<code>value</code>数组没有发生变化，而是使用<code>Arrays.copyOf</code>方法复制了一份，最后返回的是<code>new</code>出来的新串。<br>正是因为不可变性，每次字符串操作都是返回新串，效率比较低下。因此如果需要频繁修改字符串可以使用<code>StringBuilder</code>类提高效率。</p>
<h5 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h5><p>Java 里的字符串常量其实是一种特殊的字符串对象，它可以调用所有字符串方法。例如可以使用<code>&quot;我是帅哥&quot;.length()</code>获取字符串常量的长度。这些常量对象会放在<strong>字符串常量池</strong>被所有人共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;帅哥&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;帅哥&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure>
<p>左边的案例会返回<code>true</code>，因为变量<code>s1</code>和<code>s2</code>指向同一个对象<code>&quot;帅哥&quot;</code>即变量里面存储的地址是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;帅哥&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;帅哥&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure>
<p>如果是这样就会返回<code>false</code>，因为变量<code>s1</code>和<code>s2</code>指向的对象是不一样的。<br>对于情形 2，有一个小细节。我们先看使用字符串作为参数的构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = original.value;</span><br><span class="line">    <span class="built_in">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从实现可以看出，两个串<code>value</code>数组的引用是一样的。<br>因此对于例子 2，<code>s1 == s2</code>是<code>false</code>，但<code>s1.value == s2.value</code>却是<code>true</code>。当然，<code>value</code>是私有的，不能直接访问。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/1561375/1701769281175-4a9a9e0e-08a0-4491-a9af-4f6ac0554315.png#averageHue=%23e8e8e8&clientId=u0ba36842-4240-4&from=paste&height=406&id=ub843fc3d&originHeight=406&originWidth=953&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109456&status=done&style=none&taskId=u0c568dd7-a17c-48ff-93a9-31275a48d85&title=&width=953" alt="image.png"></p>
<h5 id="hashCode-1"><a href="#hashCode-1" class="headerlink" title="hashCode"></a>hashCode</h5><p><code>String</code>类还有一个私有实例变量<code>hash</code>，这个变量用来缓存串的哈希码。这个变量定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> hash;  <span class="comment">//Default to 0</span></span><br></pre></td></tr></table></figure>
<p><code>hash</code>变量的默认值是 0，当我们第一次调用<code>hashCode</code>方法时会把计算出来的值缓存到这个变量里面。我们看下<code>hashCode</code>方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">    <span class="keyword">if</span>(h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> val[] = value;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据源码可以看出字符串哈希值的计算公式是：$s[0]\times31^{n-1}+s[1]\times31^{n-2}+…+s[n-1]$。<br>为什么这么实现呢？因为使用这样的公式能够让哈希值与字符串里每个字符有关，且与每个字符的位置也有关。<br>使用数字<code>31</code>的原因大致有两个：</p>
<ul>
<li>使用 31 能产生更分散的散列，尽量满足不同串的哈希值不一样。</li>
<li>计算效率比较高，因为<code>31*h = 32*h-h</code>而<code>32*h = h&lt;&lt;5</code>。这样可以使用效率更高的加减和位运算代替效率较低的乘法运算。</li>
</ul>
<h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h5><p>在<code>String</code>类中有些方法的参数不是普通的字符串，而是正则表达式。Java 里有专门的类用于正则表达式，如<code>Pattern</code>和<code>Matcher</code>。但对于简单的情况，<code>String</code>类提供了更为简洁的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex)  <span class="comment">// 字符串分割</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(String regex)</span>  <span class="comment">// 检查是否匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串替换，仅替换遇到的第一个</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceFirst</span><span class="params">(String regex, String replacement)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串替换，替换所有</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceAll</span><span class="params">(String regex, String replacement)</span></span><br></pre></td></tr></table></figure>
<p>至于正则表达式的教程看之前整理过的文档：<br><a target="_blank" rel="noopener" href="https://space-jiangsu.yuque.com/bcsfg9/qr2sxk/gaucwl?view=doc_embed">正则表达式学习</a><br><code>**String**</code><strong>类和下面将要介绍的</strong><code>**StringBuilder**</code><strong>类在 Java9 之后内部就优化了一下，使用 byte 数组而不是 char 数组。</strong></p>
<h4 id="剖析-StringBuilder"><a href="#剖析-StringBuilder" class="headerlink" title="剖析 StringBuilder"></a>剖析 StringBuilder</h4><p>之前说过，字符串需要频繁修改的时候，使用<code>String</code>很慢。建议使用<code>StringBuilder</code>或<code>StringBuffer</code>。这两者使用方法几乎是一样的，实现也几乎是一样的，<strong>只不过</strong><code>**StringBuffer**</code><strong>使用关键字</strong><code>**synchronized **</code><strong>实现了线程安全</strong>。</p>
<h5 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">sb.append(<span class="string">&quot;我是&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;帅哥&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure>
<p>我们创建<code>StringBuilder</code>对象之后，可以使用<code>append</code>方法往里面添加字符串。<br>最后再使用<code>toString</code>方法得到字符串。</p>
<h5 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h5><h6 id="append"><a href="#append" class="headerlink" title="append"></a>append</h6><p><code>StringBuilder append(?)</code>函数可以往<code>value</code>后面追加内容，几乎所有类型的数据都可以追加。因为<code>append</code>有一个重载的参数是<code>Object</code>类型，此时是追加该对象的<code>toString</code>。除了直接追加内容，<code>append</code>方法还有以下形式：</p>
<ul>
<li><code>StringBuilder append(char[] str, int offset, int len)</code>表示将<code>str[offset, offset+len)</code>追加到<code>value</code>后面。</li>
<li><code>StringBuilder append(CharSequence s, int start, int end)</code>表示将<code>s[start, end)</code>追加到<code>value</code>后面。</li>
</ul>
<h6 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h6><p><code>StringBuilder insert(int offset, ?)</code>函数可以往<code>value</code>指定下标出插入内容，原先的内容会后移。和<code>append</code>类似，几乎所有类型的数据都可以插入进去，因为有一个<code>Object</code>类型的重载，会将对象的<code>toString</code>插入到<code>value</code>里面。除了直接插入内容，还有一下形式：</p>
<ul>
<li><code>StringBuilder insert(int index, char[] str, int offset, int len)</code>表示将<code>str[offset, offset+len)</code>插入到<code>value</code>的指定位置。</li>
<li><code>StringBuilder insert(int dstOffset, CharSequence s, int start, int end)</code>表示将<code>s[start, end)</code>插入到<code>value</code>的指定位置。</li>
</ul>
<h6 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h6><p><code>StringBuilder delete(int start, int end)</code>删除<code>value[start, end)</code>子串。</p>
<h6 id="deleteCharAt"><a href="#deleteCharAt" class="headerlink" title="deleteCharAt"></a>deleteCharAt</h6><p><code>StringBuilder deleteCharAt(int index)</code>删除<code>value[index]</code>字符。</p>
<h6 id="charAt"><a href="#charAt" class="headerlink" title="charAt"></a>charAt</h6><p><code>char charAt(int index)</code>返回<code>value</code>中下标 index 处的字符。</p>
<h6 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h6><ol>
<li><code>int indexOf(String str)</code>返回子串<code>str</code>在<code>value</code>中的下标（从左到右第一个）。</li>
<li><code>int indexOf(String str, int fromIndex)</code>返回子串<code>str</code>在<code>value[fromIndex,length)</code>中的下标（从左到右第一个）。</li>
</ol>
<h6 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h6><ol>
<li><code>int lastIndexOf(String str)</code>返回子串<code>str</code>在<code>value</code>中的下标（从右到左第一个）。</li>
<li><code>int lastIndexOf(String str, int fromIndex)</code>返回子串<code>str</code>在<code>value[fromIndex,length)</code>中的下标（从右到左第一个）。</li>
</ol>
<h6 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h6><p><code>StringBuilder replace(int start, int end, String str)</code>将<code>value[start, end)</code>替换成<code>str</code>。</p>
<h6 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h6><p><code>StringBuilder reverse()</code>翻转整个<code>value</code>。</p>
<h6 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h6><ol>
<li><code>String substring(int start)</code>返回子串<code>value[start, length)</code>。</li>
<li><code>String substring(int start, int end)</code>返回子串<code>value[start, end)</code>。</li>
</ol>
<h6 id="getChars"><a href="#getChars" class="headerlink" title="getChars"></a>getChars</h6><p><code>void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</code>表示将<code>value[srcBegin, srcEnd)</code>复制到<code>dst[dstBegin,...]</code>处。</p>
<h6 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h6><p><code>String toString()</code>返回<code>value</code>的字符串形式。</p>
<h6 id="length"><a href="#length" class="headerlink" title="length"></a>length</h6><p><code>int length()</code>返回<code>value</code>中字符的个数。</p>
<h6 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h6><p><code>int capacity()</code>函数返回<code>value</code>的当前容量。</p>
<h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><p><code>StringBuilder</code>和<code>String</code>类似，内部维护一个字符数组。定义如<code>int count; char[] value;</code>，其中<code>count</code>表示数组中字符的个数。<code>StringBuilder</code>继承于<code>AbstractStringBuilder</code>，默认的构造是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AbstractStringBuilder(<span class="type">int</span> capacity) &#123;</span><br><span class="line">	value = <span class="keyword">new</span> <span class="title class_">char</span>[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码可以看出，默认创建的<code>StringBuilder</code>容量是 16。</p>
<h6 id="append-1"><a href="#append-1" class="headerlink" title="append"></a>append</h6><p>我们再看看<code>append</code>方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">null</span>) str = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>append</code>方法会将内容复制到自己的<code>value</code>数组中，不过在复制之前会先检查容量，如果容量不够会先扩容。下面看检查容量的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span>(minimumCapacity - value.length &gt; <span class="number">0</span>)</span><br><span class="line">    	expandCapacity(minimumCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码很简单，只是判断一下需要的容量和当前最大容量的关系，不够就扩容。扩容的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">expandCapacity</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> value.length * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(newCapacity - minimumCapacity &lt; <span class="number">0</span>)newCapacity = minimumCapacity;</span><br><span class="line">    <span class="keyword">if</span>(newCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minimumCapacity &lt; <span class="number">0</span>) <span class="comment">//overflow</span></span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        newCapacity = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    value = Arrays.copyOf(value, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边首先计算新容量的大小并分配一个新数组，然后将原来的内容复制到扩容后的数组中。最后将自己的<code>value</code>指向这个新数组。这边主要关注一下扩容的机制，每次在原有容量的基础上翻倍并<code>+2</code>，<code>+2</code>主要顾及到原始容量为 0 的场景。这是一种指数扩容机制，这在不知道要多长的情况下，是很常用的机制。<br>如果，我们在使用<code>StringBuilder</code>之前就能够粗略估算出最大容量，那我们就可以使用构造<code>public StringBuilder(int capacity)</code>来创建<code>StringBuilder</code>。</p>
<h6 id="toString"><a href="#toString" class="headerlink" title="toString"></a>toString</h6><p>字符串构建完毕之后，看看<code>toString</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//Create a copy, don&#x27;t share the array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，构建<code>String</code>时使用的是<code>value</code>的副本而不是本身，这可以保证<code>String</code>的不可变性。</p>
<h6 id="insert-1"><a href="#insert-1" class="headerlink" title="insert"></a>insert</h6><p><code>insert</code>方法能够在指定位置插入一个字符串，方法原型如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">insert</span><span class="params">(<span class="type">int</span> offset, String str)</span></span><br></pre></td></tr></table></figure>
<p>这个方法能在<code>value</code>数组下标<code>offset</code>处插入一个字符串，原先在这的内容会后移。下面看看这个方法内部的实现逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">insert</span><span class="params">(<span class="type">int</span> offset, String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>((offset &lt; <span class="number">0</span>) || (offset &gt; length()))</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(offset);</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">null</span>)</span><br><span class="line">    	str = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    System.arraycopy(value, offset, value, offset + len, count - offset);</span><br><span class="line">    str.getChars(value, offset);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的主体逻辑是：首先确保容量足够；其次将指定位置及其后面的所有字符后移 n 个位置，n 是待插入串的长度；最后把新串插入到指定位置。<br>这里面用到了一个很好用的函数<code>System.arraycopy</code>，其原型如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src, <span class="type">int</span> srcPos,</span></span><br><span class="line"><span class="params">	Object dest, <span class="type">int</span> destPos, <span class="type">int</span> length)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数的含义是：将数组 src 里面范围<code>[srcPos, srcPos+length)</code>的元素复制到数组 dest 起始下标 destPos 处。</p>
<h5 id="String-的-和"><a href="#String-的-和" class="headerlink" title="String 的 + 和 +&#x3D;"></a>String 的 + 和 +&#x3D;</h5><p>Java 中字符串可以使用<code>+</code>和<code>+=</code>做连接，这是 Java 编译器提供的支持。背后 Java 编译会自己生成一个<code>StringBuilder</code>，然后调用<code>append</code>操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">hello+=<span class="string">&quot;,world&quot;</span>;</span><br><span class="line">System.out.println(hello);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">hello.append(<span class="string">&quot;,world&quot;</span>);</span><br><span class="line">System.out.println(hello.toString());</span><br></pre></td></tr></table></figure>
<p>上面左侧的写法会被优化成右侧的写法，既然编译器会自己做这个事情，那我们使用的过程中为什么还要区分呢？对于简单的情况下，确实直接使用<code>String</code>更方便，但对于复杂情况，尤其是在循环里面使用，编译器就显得不够聪明了，看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">tring</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">	hello+=<span class="string">&quot;,world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(hello);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(hello);</span><br><span class="line">    sb.append(<span class="string">&quot;,world&quot;</span>);</span><br><span class="line">    hello = sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(hello);</span><br></pre></td></tr></table></figure>
<p>可以看到每一次循环都会生成<code>StringBuilder</code>对象，这就很低效了。所以，对于简单的情况，我们直接使用<code>String</code>；对于复杂的情况手动使用<code>StringBuilder</code>。</p>
<h4 id="剖析-Arrays"><a href="#剖析-Arrays" class="headerlink" title="剖析 Arrays"></a>剖析 Arrays</h4><p><code>Arrays</code>中有很多针对数组的方法，下面我们看一下。</p>
<h5 id="toString-1"><a href="#toString-1" class="headerlink" title="toString"></a>toString</h5><p>我们直接输出数组对象的时候，会输出其地址。此时我们可以调用<code>Arrays.toString()</code>方法来获取数组的字符串形式，即使是对象数组也会挨个调用对象的<code>toString</code>方法来生成数组的字符串形式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Point</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="type">Point</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">Point[] ps = &#123;p1, p2&#125;;</span><br><span class="line">System.out.println(ps);</span><br><span class="line">println(Arrays.toString(ps));</span><br></pre></td></tr></table></figure>
<p>这个案例输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Lcom.luyan.Point;@28a418fc</span><br><span class="line">[(<span class="number">1</span>,<span class="number">2</span>), (<span class="number">3</span>,<span class="number">4</span>)]</span><br></pre></td></tr></table></figure>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><h6 id="基本类型排序"><a href="#基本类型排序" class="headerlink" title="基本类型排序"></a>基本类型排序</h6><p>对数组而言，排序是非常重要且常用的操作。对于基本数据类型排序，可以使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span></span><br></pre></td></tr></table></figure>
<p>上面第一个函数是对数组<code>a</code>所有元素升序排序，第二个是对子数组<code>a[fromIndex, toIndex)</code>升序排序。这两种方法对除 boolean 外所有的基本数据类型都有对应的重载。</p>
<h6 id="对象数组排序"><a href="#对象数组排序" class="headerlink" title="对象数组排序"></a>对象数组排序</h6><p>除了基本数据类型，对象数组也可以排序，但前提是对象所属的类要实现<code>Comparable</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Object[] a)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Object[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span></span><br></pre></td></tr></table></figure>
<p>上面两个函数与基本数据类型的排序是一样的，只不过换成了对象数组。但对应的类一定要实现<code>Comparable</code>接口，不然会报错的，因为两个对象之间不知道如何比较。</p>
<h6 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h6><p><code>String</code>类实现了<code>Comparable</code>接口，所以可以排序。如果我想对字符串忽略大小写排序怎么办？那么我们可以使用下面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex,</span></span><br><span class="line"><span class="params">                            Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br></pre></td></tr></table></figure>
<p><code>Comparator</code>是比较器接口，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是<code>compare</code>方法，它会返回一个整数，根据整数的符号确定大小关系。<code>String</code>类中有一个公开的静态成员变量，表示忽略大小写的比较器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER</span><br><span class="line">	= <span class="keyword">new</span> <span class="title class_">CaseInsensitiveComparator</span>();</span><br></pre></td></tr></table></figure>
<p>想要忽略大小写对字符串数组排序就可以使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>, <span class="string">&quot;Break&quot;</span>,<span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(arr, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>
<h6 id="降序排序"><a href="#降序排序" class="headerlink" title="降序排序"></a>降序排序</h6><p>目前为止排序都是升序排序，如果想要逆序排序该如何操作？我们可以使用匿名内部类实现<code>Comparator</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>, <span class="string">&quot;Break&quot;</span>,<span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareToIgnoreCase(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>
<p>除了自己实现外，<code>Collections</code>类有两个静态方法能够返回逆序<code>Comparator</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Comparator&lt;T&gt; <span class="title function_">reverseOrder</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Comparator&lt;T&gt; <span class="title function_">reverseOrder</span><span class="params">(Comparator&lt;T&gt; cmp)</span></span><br></pre></td></tr></table></figure>
<p>这样忽略大小写降序排序就可以写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>, <span class="string">&quot;Break&quot;</span>,<span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(arr, Collections.reverseOrder(String.CASE_INSENSITIVE_ORDER));</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>
<h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>对于有序数组，二分查找是效率非常高的查找方式。所有基本数据类型（boolean除外）都支持二分查找：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> key)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex, <span class="type">int</span> key)</span></span><br></pre></td></tr></table></figure>
<p>函数里<code>key</code>指的是要查找的元素。<br>和排序类似，对象数组也可以进行查找，前提是对应的类需要实现<code>Comparable</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(Object[] a, <span class="type">int</span> key)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(Object[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex, <span class="type">int</span> key)</span></span><br></pre></td></tr></table></figure>
<p>对于复杂类型，也可以传递<code>Comparator</code>指定排序方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(T[] a, T key, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(T[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex,</span></span><br><span class="line"><span class="params">                                   T key, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>查找注意点</p>
<ol>
<li>使用二分查找的数组必须是升序数组，想要在降序数组里面查找，那么需要配合<code>Comparator</code>实现。</li>
<li>如果数组使用<code>Comparator</code>排序，那么查找时必须使用一样的比较器。因为只有这样，才能使两者认为的有序是一致的。</li>
<li>查找时若是没找到会返回一个负数，这个负数是<code>-(插入点+1)</code>。插入点指的是将要查找的元素插入在某个地方还能保证数组有序。</li>
<li>如果数组有多个匹配的元素，那么返回谁是不确定的。</li>
</ol>
<h5 id="更多方法"><a href="#更多方法" class="headerlink" title="更多方法"></a>更多方法</h5><h6 id="copyOf"><a href="#copyOf" class="headerlink" title="copyOf"></a>copyOf</h6><p><code>copyOf</code>是复制数组的方法，参数可以传递一个<code>newLength</code>表示新数组的长度。新长度比较短就复制前面一小部分，新长度比较长就在后面补<code>null</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="type">int</span> newLength)</span><br></pre></td></tr></table></figure>
<p>函数会返回复制后的新数组，但是注意对于引用类型，两个数组里面的元素其实是相同的元素。</p>
<h6 id="copyOfRange"><a href="#copyOfRange" class="headerlink" title="copyOfRange"></a>copyOfRange</h6><p><code>copyOfRange</code>方法能够复制<code>original[from, to)</code>到新数组中，返回复制后的数组。对于引用类型，两个数组里面的元素其实是相同的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOfRange(T[] original, <span class="type">int</span> from, <span class="type">int</span> to)</span><br></pre></td></tr></table></figure>
<h6 id="equals-1"><a href="#equals-1" class="headerlink" title="equals"></a>equals</h6><p><code>equals</code>方法能够返回两个数组是否相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object[] a, Object[] a2)</span></span><br></pre></td></tr></table></figure>
<p>数组相同指的是：</p>
<ol>
<li>两个数组长度一致。</li>
<li>数组内对应元素相同，元素相同是指调用<code>equals</code>方法返回<code>true</code>。</li>
</ol>
<h6 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h6><p><code>fill</code>方法用于使用一个元素填充数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(Object[] a, Object val)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(Object[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex, Object val)</span></span><br></pre></td></tr></table></figure>
<p>第一个方法是使用<code>val</code>填充整个数组<code>a</code>；第二个方法使用<code>val</code>填充<code>a[fromIndex, toIndex)</code>。<br>对于引用类型，填充过的元素都会指向同一个对象。</p>
<h6 id="hashCode-2"><a href="#hashCode-2" class="headerlink" title="hashCode"></a>hashCode</h6><p><code>hashCode</code>方法用于返回一个数组的哈希值。我们直接看它的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Object element : a)</span><br><span class="line">        result = <span class="number">31</span> * result + (element == <span class="literal">null</span> ? <span class="number">0</span> : element.hashCode());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现和字符串的很像，这个实现能够照顾到数组里面每个元素以及元素的位置。</p>
<h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5><p>之前介绍的数组都是一维的，其实数组还可以有多维。下面使用二维数组举例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">        arr[i][j] = i + j;</span><br><span class="line">        System.out.print(arr[i][j] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中我们首先定义了一个 2 行 3 列的二维数组，然后给每个元素赋值并输出。<br>我们还能发现，<code>a</code>和<code>a[i]</code>都有<code>length</code>属性。这就很有意思，实际上多维数组只是假象，这些多维数组本质上还是一维数组，只不过一维数组里面每个元素仍然是一维数组（每个元素都指向另一个一维数组）。既然如此，就会出现下面这些写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>][];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">        arr[i][j] = i + j;</span><br><span class="line">        System.out.print(arr[i][j] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>左边案例输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>	</span><br><span class="line"><span class="number">1</span>	<span class="number">2</span>	</span><br><span class="line"><span class="number">2</span>	<span class="number">3</span>	<span class="number">4</span>	</span><br><span class="line"><span class="number">3</span>	<span class="number">4</span>	<span class="number">5</span>	<span class="number">6</span>	</span><br><span class="line"><span class="number">4</span>	<span class="number">5</span>	<span class="number">6</span>	<span class="number">7</span>	<span class="number">8</span>	</span><br></pre></td></tr></table></figure>
<p>可以发现我们创建的二维数组并不是正方形，而是三角形。也就是说，二维数组里面每一行的列数可以自定义。<br><code>Arrays</code>里面的<code>toString</code>、<code>equals</code>、<code>hashCode</code>方法都有对应的<code>deepXXX</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">deepToString</span><span class="params">(Object[] a)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">deepEquals</span><span class="params">(Object[] a1, Object[] a2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">deepHashCode</span><span class="params">(Object a[])</span></span><br></pre></td></tr></table></figure>
<p>这些方法在实现的时候会判断元素是不是也是一个数组，如果是就会递归进行操作。看例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> [][]arr = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">println(Arrays.toString(arr));</span><br><span class="line">println(Arrays.deepToString(arr));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[I@2f92e0f4, [I@28a418fc]</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br></pre></td></tr></table></figure>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><h6 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">binarySearch0</span><span class="params">(T[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex,</span></span><br><span class="line"><span class="params">                                     T key, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> fromIndex;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> toIndex - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">T</span> <span class="variable">midVal</span> <span class="operator">=</span> a[mid];</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> c.compare(midVal, key);</span><br><span class="line">        <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>) low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>) high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid; <span class="comment">//key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>); <span class="comment">//key not found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主体框架还是很简单的，活学活用，以后也用右移表示除以 2。</p>
<h6 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h6><p>对于基本类型的数组使用<strong>双枢轴快速排序</strong>（普通快排的优化版本），对象数组使用<strong>TimSort</strong>（对归并排序的优化）。当数组元素比较少的时候会采用效率更高的插入排序。<br>为什么要区分基本类型数组和对象数组？因为这涉及到稳定性的问题，即排序前后数组中值相同的元素先后顺序是否改变的问题。快排不稳定，而归并排序是稳定的。<br>对于基本数据类型，值相同就是完全相同，稳定性没有意义；但两个对象之间，相同指的是比较结果一样，两者仍然是不同的对象，它们的其它成员变量也可能不同等，所以稳定性很重要。</p>
<h4 id="剖析日期和时间"><a href="#剖析日期和时间" class="headerlink" title="剖析日期和时间"></a>剖析日期和时间</h4><h5 id="Date-类"><a href="#Date-类" class="headerlink" title="Date 类"></a>Date 类</h5><p><code>Date</code>是 Java 最早引入关于日期的类，但由于不能支持国际化，很多方法已经过时。<code>Date</code>内部主要维护一个<code>long</code>类型的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">long</span> fastTime;</span><br></pre></td></tr></table></figure>
<p><code>fastTime</code>表示距离纪元时（1970年1月1日0时0分0秒）的毫秒数，<code>Date</code>主要有两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Date</span><span class="params">(<span class="type">long</span> date)</span> &#123;</span><br><span class="line">	fastTime = date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Date</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无参构造使用<code>System.currentTimeMillis()</code>进行初始化，这个函数会返回当前时刻距离纪元时的毫秒数，使用的还是比较多的。下面是一些<code>Date</code>里面没有过时的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTime</span><span class="params">()</span>  <span class="comment">// 返回毫秒数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>  <span class="comment">// 返回两个 Date 对象是否相同，比较的是毫秒数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Date anotherDate)</span>  <span class="comment">// 与另一个日期对象作比较，返回整数表示大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">before</span><span class="params">(Date when)</span>  <span class="comment">// 判定是否在给定日期之前</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">after</span><span class="params">(Date when)</span>  <span class="comment">// 判定是否在给定日期之后</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>  <span class="comment">// 哈希值算法与 Long 类似</span></span><br></pre></td></tr></table></figure>
<h5 id="Calendar-类"><a href="#Calendar-类" class="headerlink" title="Calendar 类"></a>Calendar 类</h5><p><code>Calendar</code>是日历类，也是 Java 中操作日期和时间的主要类。<code>Calendar</code>内部维护以下成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">long</span> time;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> fields[];</span><br></pre></td></tr></table></figure>
<p><code>time</code>仍然是表示时刻的毫秒数，<code>fields</code>是一个存储日历中各字段值的数组。数组的长度是 17，主要存储的字段有：</p>
<table>
<thead>
<tr>
<th><strong>字段名</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>Calendar.YEAR</code></td>
<td>表示年份。</td>
</tr>
<tr>
<td><code>Calendar.MONTH</code></td>
<td>表示月份，用 0 表示 1 月，1 表示 2 月，…</td>
</tr>
<tr>
<td><code>Calendar.DAY_OF_MONTH</code></td>
<td>表示日，每月第一天是 1。</td>
</tr>
<tr>
<td><code>Calendar.HOUR_OF_DAY</code></td>
<td>表示小时，范围是 0-23。</td>
</tr>
<tr>
<td><code>Calendar.MINUTE</code></td>
<td>表示分钟，范围是 0-59。</td>
</tr>
<tr>
<td><code>Calendar.SECOND</code></td>
<td>表示秒，范围是 0-59。</td>
</tr>
<tr>
<td><code>Calendar.MILLISECOND</code></td>
<td>表示毫秒，范围是 0-999。</td>
</tr>
<tr>
<td><code>Calendar.DAY_OF_WEEK</code></td>
<td>表示周几，周日是 1，周一是 2，…</td>
</tr>
</tbody></table>
<p><code>Calendar</code>类中定义了表示月份和周几的静态变量，例如<code>Calendar.JULY</code>表示 7 月、<code>Calendar.SUNDAY</code>表示周日。<br><code>Calendar</code>是抽象类，不能直接创建对象，它提供了几个静态方法用来获取实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title function_">getInstance</span><span class="params">(TimeZone zone, Locale aLocale)</span></span><br></pre></td></tr></table></figure>
<p><code>TimeZone</code>表示时区，<code>Locale</code>表示国家（或地区）和语言。所有的<code>getInstance</code>方法都需要这两个参数，如果没有就使用默认值（默认当前的时区与国家、语言）。方法中会根据时区与国家选择合适的子类创建对象，中文系统中一般会创建<code>GregorianCalendar</code>类对象。<br>之前就说过，<code>Calendar</code>会将各字段的值存到<code>fields</code>数组里面。当我们想访问某个字段的时候，可以通过<code>get</code>方法获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">println(<span class="string">&quot;年：&quot;</span> + calendar.get(Calendar.YEAR));</span><br><span class="line">println(<span class="string">&quot;月：&quot;</span> + calendar.get(Calendar.MONTH));</span><br><span class="line">println(<span class="string">&quot;日：&quot;</span> + calendar.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">println(<span class="string">&quot;时：&quot;</span> + calendar.get(Calendar.HOUR));</span><br><span class="line">println(<span class="string">&quot;分：&quot;</span> + calendar.get(Calendar.MINUTE));</span><br><span class="line">println(<span class="string">&quot;秒：&quot;</span> + calendar.get(Calendar.SECOND));</span><br><span class="line">println(<span class="string">&quot;毫秒：&quot;</span> + calendar.get(Calendar.MILLISECOND));</span><br><span class="line">println(<span class="string">&quot;周：&quot;</span> + calendar.get(Calendar.DAY_OF_WEEK));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">年：<span class="number">2023</span></span><br><span class="line">月：<span class="number">11</span></span><br><span class="line">日：<span class="number">13</span></span><br><span class="line">时：<span class="number">11</span></span><br><span class="line">分：<span class="number">17</span></span><br><span class="line">秒：<span class="number">59</span></span><br><span class="line">毫秒：<span class="number">534</span></span><br><span class="line">周：<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>因为月是从 0 开始排的，所以拿到字段后需要<code>+1</code>。周日表示 1，所以周三这边显示 4，也需要根据具体情况做变换。<br><code>Calendar</code>类还支持修改各字段的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setTime</span><span class="params">(Date date)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTimeInMillis</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> date)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> date,</span></span><br><span class="line"><span class="params">                      <span class="type">int</span> hourOfDay, <span class="type">int</span> minute, <span class="type">int</span> second)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> field, <span class="type">int</span> value)</span>  <span class="comment">// 用的较多</span></span><br></pre></td></tr></table></figure>
<p>除此之外，还可以使用<code>add</code>方法根据字段增加或减少时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> field, <span class="type">int</span> amount)</span></span><br></pre></td></tr></table></figure>
<p>举个例，我想时间变成第二天下午 2:15 就可以这样设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">calendar.set(Calendar.HOUR_OF_DAY, <span class="number">14</span>);</span><br><span class="line">calendar.set(Calendar.MINUTE, <span class="number">15</span>);</span><br><span class="line">calendar.set(Calendar.SECOND, <span class="number">0</span>);</span><br><span class="line">calendar.set(Calendar.MILLISECOND, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><code>add</code>方法强在不是无脑加法，而是会联动更新其它字段，比如加一天跨年了，那么年份也会联动加一。<br>还有一个方法使用和<code>add</code>一样叫做<code>roll</code>，这个方法也会让一个字段加一，但是不会影响到其它字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">roll</span><span class="params">(<span class="type">int</span> field, <span class="type">int</span> amount)</span></span><br></pre></td></tr></table></figure>
<p>假设现在是<code>2023.12.31</code>，如果使用<code>calendar.add(Calendar.DAY_OF_MONTH, 1) </code>日期会变成<code>2024.1.1</code>；而使用<code>calendar.roll(Calendar.DAY_OF_MONTH, 1) </code>之后日期会变成<code>2023.12.1</code>。<br><code>Calendar</code>可以很方便的转换成<code>Date</code>或毫秒数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Date <span class="title function_">getTime</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTimeInMillis</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>与<code>Date</code>类似，<code>Calendar</code>对象之间也可以进行比较：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Calendar anotherCalendar)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">after</span><span class="params">(Object when)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">before</span><span class="params">(Object when)</span></span><br></pre></td></tr></table></figure>
<h5 id="DateFormat"><a href="#DateFormat" class="headerlink" title="DateFormat"></a>DateFormat</h5><p><code>DateFormat</code>类主要用于将<code>Date</code>与字符串互相转化，主要有下面方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">format</span><span class="params">(Date date)</span></span><br><span class="line"><span class="keyword">public</span> Date <span class="title function_">parse</span><span class="params">(String source)</span></span><br></pre></td></tr></table></figure>
<p>字符串有四种风格，使用静态变量<code>SHORT、MEDIUM、LONG、FULL</code>表示，四种风格描述的详细程度不一样。除了四种风格，还有<code>DEFAULT</code>表示默认风格，默认是<code>MEDIUM</code>。<code>DateFormat</code>也是抽象类，使用的时候需要根据方法获取实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title function_">getDateTimeInstance</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title function_">getDateInstance</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title function_">getTimeInstance</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>这三种方法分别表示：处理日期和时间、只处理日期、只处理时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">calendar.set(<span class="number">2023</span>, Calendar.DECEMBER, <span class="number">31</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">println(DateFormat.getDateInstance().format(date));</span><br><span class="line">println(DateFormat.getTimeInstance().format(date));</span><br><span class="line">println(DateFormat.getDateTimeInstance().format(date));</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023</span>年<span class="number">12</span>月<span class="number">31</span>日</span><br><span class="line"><span class="number">15</span>:<span class="number">40</span>:<span class="number">07</span></span><br><span class="line"><span class="number">2023</span>年<span class="number">12</span>月<span class="number">31</span>日 <span class="number">15</span>:<span class="number">40</span>:<span class="number">07</span></span><br></pre></td></tr></table></figure>

<p>获取实例的方法都有两种重载：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DateFormat <span class="title function_">getDateTimeInstance</span><span class="params">(<span class="type">int</span> dateStyle, <span class="type">int</span> timeStyle)</span></span><br><span class="line">DateFormat <span class="title function_">getDateTimeInstance</span><span class="params">(<span class="type">int</span> dateStyle, <span class="type">int</span> timeStyle, Locale aLocale)</span></span><br></pre></td></tr></table></figure>
<p>简单例子<code>println(DateFormat.getDateInstance(DateFormat.SHORT).format(date))</code>输出简短的日期<code>2023/12/31</code>。</p>
<h5 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h5><p><code>SimpleDateFormat</code>是<code>DateFormat</code>的子类，它的优点是能够接受一个<code>pattern</code>表示日期的自定义格式。<code>pattern</code>里面所有英语字母都有特殊含义，其它字符原样输出，下面是一些常见字母：</p>
<ul>
<li><code>yyyy</code>表示四位数的年</li>
<li><code>MM</code>表示两位数的月</li>
<li><code>dd</code>表示两位数的日</li>
<li><code>HH</code>表示两位数的小时（24小时制）</li>
<li><code>hh</code>表示两位数的小时（12小时制）</li>
<li><code>mm</code>表示两位数的分钟</li>
<li><code>ss</code>表示两位数的秒</li>
<li><code>SSS</code>表示三位数的毫秒</li>
<li><code>E</code>表示周几</li>
<li><code>a</code>表示上午还是下午</li>
</ul>
<p>我们仍然使用<code>format</code>方法将<code>Date</code>对象转换成字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> <span class="string">&quot;yyyy年MM月dd日\nE hh:mm.ss a&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(pattern);</span><br><span class="line">System.out.println(sdf.format(calendar.getTime()));</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2023</span>年<span class="number">12</span>月<span class="number">14</span>日</span><br><span class="line">周四 <span class="number">04</span>:<span class="number">01.36</span> 下午</span><br></pre></td></tr></table></figure>
<p>我们除了可以将日期转换成字符串，还可以将指定格式的字符串转换成<code>Date</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> <span class="string">&quot;yyyy年MM月dd日\nE hh:mm.ss a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">timeStr</span> <span class="operator">=</span> <span class="string">&quot;2023年12月14日\n周四 04:02.19 下午&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(pattern);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(timeStr);</span><br><span class="line">    <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">    calendar.setTime(date);</span><br><span class="line">    System.out.println(calendar.get(Calendar.YEAR));</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子会输出<code>2023</code>，我们主要使用<code>parse</code>方法将指定格式的字符串转换成<code>Date</code>对象。这个方法会抛出一个受检异常<code>ParseException</code>，调用者必须处理。<br><code>**DateFormat**</code><strong>和</strong><code>**SimpleDateFormat**</code><strong>都是线程不安全的。</strong></p>
<h4 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h4><p>随机是计算机程序中非常常见的需求，例如：红包金额、随机密码、摇车牌等。</p>
<h5 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random"></a>Math.random</h5><p>Java 对随机的基本支持是<code>Math</code>类的静态方法<code>random</code>，这个方法会返回范围在<code>[0, 1)</code>的随机数。它的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Random randomNumberGenerator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Random <span class="title function_">initRNG</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> randomNumberGenerator;</span><br><span class="line">    <span class="keyword">return</span> (rnd == <span class="literal">null</span>) ? (randomNumberGenerator = <span class="keyword">new</span> <span class="title class_">Random</span>()) : rnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">random</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> randomNumberGenerator;</span><br><span class="line">    <span class="keyword">if</span> (rnd == <span class="literal">null</span>) rnd = initRNG();</span><br><span class="line">    <span class="keyword">return</span> rnd.nextDouble();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>Math</code>类维护了一个<code>Random</code>对象，然后每次调用它的<code>nextDouble</code>方法。这个<code>Random</code>对象是单例的，只有第一次访问的时候会创建这个对象。</p>
<h5 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h5><h6 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h6><p><code>Random</code>提供了更丰富的随机数方法，这些方法不是静态的。下面是一个简单的案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">println(rnd.nextInt());</span><br><span class="line">println(rnd.nextInt(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">1944456130</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><code>nextInt</code>方法会产生一个随机的<code>int</code>（可正可负）；<code>nextInt(100)</code>方法会产生一个随机的范围在<code>[0, 100)</code>的<code>int</code>。除了<code>nextInt</code>方法，还有以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextLong</span><span class="params">()</span>  <span class="comment">// 产生一个随机的 long</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">nextBoolean</span><span class="params">()</span>  <span class="comment">// 产生一个随机的 boolean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextBytes</span><span class="params">(<span class="type">byte</span>[] bytes)</span>  <span class="comment">// 产生一堆随机字节填满数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">float</span> <span class="title function_">nextFloat</span><span class="params">()</span>  <span class="comment">// 产生一个随机的范围在 [0， 1) 的 float</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">nextDouble</span><span class="params">()</span>  <span class="comment">// 产生一个随机的范围在 [0， 1) 的 double</span></span><br></pre></td></tr></table></figure>
<p><code>Random</code>除了默认构造之外，还有一个构造可以接受一个<code>long</code>类型的种子参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Random</span><span class="params">(<span class="type">long</span> seed)</span></span><br></pre></td></tr></table></figure>
<p>种子决定了随机产生的序列，种子相同，那么产生的序列就是相同的，看例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">20231214</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    print(rnd.nextInt(<span class="number">100</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">39</span> <span class="number">27</span> <span class="number">24</span> <span class="number">14</span> <span class="number">90</span> </span><br></pre></td></tr></table></figure>
<p>上面的程序不管执行多少次，结果都是<code>39 27 24 14 90</code>不会变，因为每次运行种子是一样的。我们除了在构造里面传递种子，还可以使用对应的<code>setter</code>设置种子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSeed</span><span class="params">(<span class="type">long</span> seed)</span></span><br></pre></td></tr></table></figure>
<p>使用种子的主要目的是为了实现可重复的随机，测试的时候可以复现场景。</p>
<h6 id="随机的基本原理"><a href="#随机的基本原理" class="headerlink" title="随机的基本原理"></a>随机的基本原理</h6><p><code>Random</code>产生的不是真随机数，而是基于种子的伪随机数。每次生成随机数的时候，先根据当前种子经过某种运算得出新种子，再使用新种子生成随机数。这也就是为什么，在运行环境一样的情况下，若初始种子是一样的，那么每次生成的随机数序列也是一样的。如果构造<code>Random</code>的时候没有传递种子，那么内部会生成一个种子，这个种子是真随机的。下面看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">seedUniquifier</span> <span class="operator">=</span> </span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">8682522807148012L</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Random</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(seedUniquifier() ^ System.nanoTime());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">seedUniquifier</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> seedUniquifier.get();</span><br><span class="line">        <span class="type">long</span> <span class="variable">next</span> <span class="operator">=</span> current * <span class="number">181783497276652981L</span>;</span><br><span class="line">        <span class="keyword">if</span>(seedUniquifier.compareAndSet(current, next))</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>种子是由<code>seedUniquifier()</code>与<code>System.nanoTime()</code>异或生成的。<code>System.nanoTime()</code>返回纳秒级的当前时间。<code>seedUniquifier()</code>相对复杂，它会先获取<code>seedUniquifier</code>的值存到<code>current</code>中，然后将其与一个常数相乘存到<code>next</code>中，若<code>next</code>与<code>current</code>的值不一样就更新<code>seedUniquifier</code>并将<code>next</code>作为返回值。程序里面使用死循环以及<code>compareAndSet</code>方法主要为了确保在多线程情况不会出现两次一样的随机数。<br>当我们有了种子之后，随机数是怎么生成的？我们看一些代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> next(<span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextLong</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ((<span class="type">long</span>)(next(<span class="number">32</span>)) &lt;&lt; <span class="number">32</span>) + next(<span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">float</span> <span class="title function_">nextFloat</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> next(<span class="number">24</span>) / ((<span class="type">float</span>)(<span class="number">1</span> &lt;&lt; <span class="number">24</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">nextBoolean</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> next(<span class="number">1</span>) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他们都是在<code>next(int bits)</code>的基础上做些变换，这个方法是用来生成指定位数的随机数的，下面我们看看源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">multiplier</span> <span class="operator">=</span> <span class="number">0x5DEECE66DL</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">addend</span> <span class="operator">=</span> <span class="number">0xBL</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">mask</span> <span class="operator">=</span> (<span class="number">1L</span> &lt;&lt; <span class="number">48</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">(<span class="type">int</span> bits)</span> &#123;</span><br><span class="line">    <span class="type">long</span> oldseed, nextseed;</span><br><span class="line">    <span class="type">AtomicLong</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="built_in">this</span>.seed;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        oldseed = seed.get();</span><br><span class="line">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码主要使用公式<code>(oldseed * multiplier + addend) &amp; mask</code>生成新种子，这个公式表示对旧种子乘以某个数（multiplier）再加上某个数（addend），最后取低 48 位。最后的随机数就是新种子的高<code>bits</code>位。这种方法有一个名字叫做线性同余随机数生成器（linear congruential pseudorandom number generator）。</p>
<h6 id="随机验证码-密码"><a href="#随机验证码-密码" class="headerlink" title="随机验证码&#x2F;密码"></a>随机验证码&#x2F;密码</h6><p>随机验证码一般由 6 位数字组成，以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成 n 位验证码，每一位都是数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateVRCode</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        chars[i] = (<span class="type">char</span>) (<span class="string">&#x27;0&#x27;</span> + rnd.nextInt(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">vrcode</span> <span class="operator">=</span> generateVRCode(<span class="number">6</span>);</span><br><span class="line">    System.out.println(vrcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>密码由数字、字母、特殊符号组成，以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPECIAL_CHARS</span> <span class="operator">=</span> <span class="string">&quot;!@#$%^&amp;*_=+-/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">nextChar</span><span class="params">(Random rnd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> rnd.nextInt(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">char</span>) (<span class="string">&#x27;0&#x27;</span> + rnd.nextInt(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + rnd.nextInt(<span class="number">26</span>));</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">char</span>) (<span class="string">&#x27;A&#x27;</span> + rnd.nextInt(<span class="number">26</span>));</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> SPECIAL_CHARS.charAt(rnd.nextInt(SPECIAL_CHARS.length()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generatePwd</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        chars[i] = nextChar(rnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> generatePwd(<span class="number">8</span>);</span><br><span class="line">    System.out.println(pwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于一些复杂的密码要求至少一位大写字母、小写字母、特殊符号、数字，其它的随机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPECIAL_CHARS</span> <span class="operator">=</span> <span class="string">&quot;!@#$%^&amp;*_=+-/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机返回一个没有内容的下标</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">char</span>[] chars, Random rnd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] idxes = <span class="keyword">new</span> <span class="title class_">int</span>[chars.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chars[i] &gt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        idxes[n++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idxes[rnd.nextInt(n)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">nextNumber</span><span class="params">(Random rnd)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>) (<span class="string">&#x27;0&#x27;</span> + rnd.nextInt(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">nextLowerLetter</span><span class="params">(Random rnd)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + rnd.nextInt(<span class="number">26</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">nextUpperLetter</span><span class="params">(Random rnd)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>) (<span class="string">&#x27;A&#x27;</span> + rnd.nextInt(<span class="number">26</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">nextSpecialChar</span><span class="params">(Random rnd)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SPECIAL_CHARS.charAt(rnd.nextInt(SPECIAL_CHARS.length()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">nextChar</span><span class="params">(Random rnd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> rnd.nextInt(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span> -&gt; nextNumber(rnd);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> -&gt; nextLowerLetter(rnd);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span> -&gt; nextUpperLetter(rnd);</span><br><span class="line">        <span class="keyword">default</span> -&gt; nextSpecialChar(rnd);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generatePwd</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    chars[nextIndex(chars, rnd)] = nextNumber(rnd);</span><br><span class="line">    chars[nextIndex(chars, rnd)] = nextLowerLetter(rnd);</span><br><span class="line">    chars[nextIndex(chars, rnd)] = nextUpperLetter(rnd);</span><br><span class="line">    chars[nextIndex(chars, rnd)] = nextSpecialChar(rnd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chars[i] &gt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        chars[i] = nextChar(rnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> generatePwd(<span class="number">8</span>);</span><br><span class="line">    System.out.println(pwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="洗牌"><a href="#洗牌" class="headerlink" title="洗牌"></a>洗牌</h6><p>洗牌就是将数组里面的元素打乱顺序，看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">int</span>[] nums, Random rnd)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> rnd.nextInt(i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[idx];</span><br><span class="line">        nums[idx] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    shuffle(nums, rnd);</span><br><span class="line">    System.out.println(Arrays.toString(nums));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>洗牌的基本思路就是从后往前每个元素与它前面的随机一个元素交换。</p>
<h6 id="带权重的随机"><a href="#带权重的随机" class="headerlink" title="带权重的随机"></a>带权重的随机</h6><p>实际场景中，带权重随机还是比较常见的。比如抽奖有一、二、三等奖这三种奖项，它们抽中的概率分别是 10%、20%、70%。我们实现的基本思路是使用累积分布概率，这个例子里面我们随机一个<code>[0,1)</code>的小数<code>n</code>，看它的范围：</p>
<ul>
<li><code>n∈[0, 10%)</code>就是一等奖；</li>
<li><code>n∈[10%, 30%)</code>就是二等奖；</li>
<li><code>n∈[30%, 1)</code>就是三等奖；</li>
</ul>
<p>我们首先定义一个类<code>Pair</code>表示奖品和奖品对应的权重：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object item;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(Object item, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = item;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getItem</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们定义一个带权随机类<code>WeightRandom</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WeightRandom</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Pair[] options;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span>[] cmPro;  <span class="comment">//cumulativeProbabilities;</span></span><br><span class="line">    <span class="keyword">private</span> Random rnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeightRandom</span><span class="params">(Pair[] options)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rnd = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="built_in">this</span>.options = options;</span><br><span class="line">        initCumulativeProbabilities();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initCumulativeProbabilities</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">weights</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Pair option : options) &#123;</span><br><span class="line">            weights += option.getWeight();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.cmPro = <span class="keyword">new</span> <span class="title class_">double</span>[options.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; options.length; ++i) &#123;</span><br><span class="line">            sum += options[i].getWeight();</span><br><span class="line">            cmPro[i] = sum / weights;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">nextItem</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">n</span> <span class="operator">=</span> rnd.nextDouble();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> Arrays.binarySearch(cmPro, n);</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            idx = -idx - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> options[idx].getItem();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>nextItem</code>方法里面可以使用循环从前到后寻找，我们给定的寻找方案是使用二分查找。因为概率累积数组本就是递增的，而且就算找不到函数的返回值表示应该插入在哪个位置。</p>
<h6 id="抢红包算法"><a href="#抢红包算法" class="headerlink" title="抢红包算法"></a>抢红包算法</h6><p>给定一个钱数和人数，设计一个抢红包算法，每个人最少 0.01 元。我们有如下思路：<br>每次分配金额的时候，根据人数和钱数计算出平均金额<code>avg</code>。然后每个人的红包金额在范围<code>[0.01, 2 * avg)</code>，除此之外还有一些特殊情况需要考虑：</p>
<ol>
<li>只剩最后一个人时，这个人获得所有金钱。</li>
<li>每次金额随机出来时，我们至少要确保剩下的人每人都还能分得 0.01。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomPacket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;</span><br><span class="line">    <span class="keyword">private</span> Random rnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RandomPacket</span><span class="params">(<span class="type">int</span> num, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (money &lt; num * <span class="number">0.01</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;money &lt; num * 0.01&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">        <span class="built_in">this</span>.rnd = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">double</span> m;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            m = money;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> money / num * <span class="number">2</span>;</span><br><span class="line">            m = rnd.nextDouble() * max;</span><br><span class="line">            m = Math.round(m * <span class="number">100</span>) / <span class="number">100.0</span>;</span><br><span class="line">            System.err.println(m);</span><br><span class="line">            m = Math.max(m, <span class="number">0.01</span>);</span><br><span class="line">            m = Math.min(m, money - (num - <span class="number">1</span>) * <span class="number">0.01</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.num--;</span><br><span class="line">        <span class="built_in">this</span>.money -= m;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p><code>**Random**</code><strong>类是线程安全的</strong>，但在并发很高的情况下会产生竞争，此时建议考虑<code>ThreadLocalRandom</code>类。除此之外，<code>SecureRandom</code>类可以产生安全性更高、随机性更强的随机数，用于安全加密等领域。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag"># 后端</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2023/03/18/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8802%EF%BC%89/" rel="next" title="Java 基础系列（02）">
                <i class="fa fa-chevron-left"></i> Java 基础系列（02）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2023/04/14/Java-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%8804%EF%BC%89/" rel="prev" title="Java 基础系列（04）">
                Java 基础系列（04） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/index.html">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E7%B1%BB"><span class="nav-number">1.</span> <span class="nav-text">常用基础类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">1.1.</span> <span class="nav-text">包装类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="nav-number">1.1.1.</span> <span class="nav-text">装箱与拆箱</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-number">1.1.2.</span> <span class="nav-text">共同点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#equals"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">equals</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#hashCode"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">hashCode</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#compareTo"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">compareTo</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.1.3.</span> <span class="nav-text">包装类与字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">字符串转包装类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">字符串转基本类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">基本类型转字符串</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%B8%B8%E9%87%8F"><span class="nav-number">1.1.4.</span> <span class="nav-text">常用常量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Number"><span class="nav-number">1.1.5.</span> <span class="nav-text">Number</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="nav-number">1.1.6.</span> <span class="nav-text">不可变性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%96%E6%9E%90-Integer"><span class="nav-number">1.2.</span> <span class="nav-text">剖析 Integer</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%8D%E7%BF%BB%E8%BD%AC"><span class="nav-number">1.2.1.</span> <span class="nav-text">位翻转</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%94%A8%E6%B3%95"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">用法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8C%89%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">按字节翻转实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8C%89%E4%BD%8D%E7%BF%BB%E8%BD%AC%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">按位翻转实现</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D"><span class="nav-number">1.2.2.</span> <span class="nav-text">循环移位</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#valueOf-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.3.</span> <span class="nav-text">valueOf 方法的实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%96%E6%9E%90-String"><span class="nav-number">1.3.</span> <span class="nav-text">剖析 String</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">1.3.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B5%B0%E8%BF%9B-String"><span class="nav-number">1.3.2.</span> <span class="nav-text">走进 String</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.3.3.</span> <span class="nav-text">编码转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7-1"><span class="nav-number">1.3.4.</span> <span class="nav-text">不可变性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F"><span class="nav-number">1.3.5.</span> <span class="nav-text">字符串常量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hashCode-1"><span class="nav-number">1.3.6.</span> <span class="nav-text">hashCode</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.3.7.</span> <span class="nav-text">正则表达式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%96%E6%9E%90-StringBuilder"><span class="nav-number">1.4.</span> <span class="nav-text">剖析 StringBuilder</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-1"><span class="nav-number">1.4.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8-API"><span class="nav-number">1.4.2.</span> <span class="nav-text">常用 API</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#append"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">append</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#insert"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">insert</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#delete"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">delete</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#deleteCharAt"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">deleteCharAt</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#charAt"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">charAt</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#indexOf"><span class="nav-number">1.4.2.6.</span> <span class="nav-text">indexOf</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#lastIndexOf"><span class="nav-number">1.4.2.7.</span> <span class="nav-text">lastIndexOf</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#replace"><span class="nav-number">1.4.2.8.</span> <span class="nav-text">replace</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#reverse"><span class="nav-number">1.4.2.9.</span> <span class="nav-text">reverse</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#substring"><span class="nav-number">1.4.2.10.</span> <span class="nav-text">substring</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#getChars"><span class="nav-number">1.4.2.11.</span> <span class="nav-text">getChars</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#toString-NaN"><span class="nav-number">1.4.2.12.</span> <span class="nav-text">toString</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#length"><span class="nav-number">1.4.2.13.</span> <span class="nav-text">length</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#capacity"><span class="nav-number">1.4.2.14.</span> <span class="nav-text">capacity</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.3.</span> <span class="nav-text">基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#append-1"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">append</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#toString"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">toString</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#insert-1"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">insert</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#String-%E7%9A%84-%E5%92%8C"><span class="nav-number">1.4.4.</span> <span class="nav-text">String 的 + 和 +&#x3D;</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%96%E6%9E%90-Arrays"><span class="nav-number">1.5.</span> <span class="nav-text">剖析 Arrays</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#toString-1"><span class="nav-number">1.5.1.</span> <span class="nav-text">toString</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">1.5.2.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">基本类型排序</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">对象数组排序</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E5%99%A8"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">比较器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%99%8D%E5%BA%8F%E6%8E%92%E5%BA%8F"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">降序排序</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">1.5.3.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.4.</span> <span class="nav-text">更多方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#copyOf"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">copyOf</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#copyOfRange"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">copyOfRange</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#equals-1"><span class="nav-number">1.5.4.3.</span> <span class="nav-text">equals</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#fill"><span class="nav-number">1.5.4.4.</span> <span class="nav-text">fill</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#hashCode-2"><span class="nav-number">1.5.4.5.</span> <span class="nav-text">hashCode</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">1.5.5.</span> <span class="nav-text">多维数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.5.6.</span> <span class="nav-text">实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-1"><span class="nav-number">1.5.6.1.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F-1"><span class="nav-number">1.5.6.2.</span> <span class="nav-text">排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%96%E6%9E%90%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4"><span class="nav-number">1.6.</span> <span class="nav-text">剖析日期和时间</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Date-%E7%B1%BB"><span class="nav-number">1.6.1.</span> <span class="nav-text">Date 类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Calendar-%E7%B1%BB"><span class="nav-number">1.6.2.</span> <span class="nav-text">Calendar 类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DateFormat"><span class="nav-number">1.6.3.</span> <span class="nav-text">DateFormat</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SimpleDateFormat"><span class="nav-number">1.6.4.</span> <span class="nav-text">SimpleDateFormat</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA"><span class="nav-number">1.7.</span> <span class="nav-text">随机</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Math-random"><span class="nav-number">1.7.1.</span> <span class="nav-text">Math.random</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Random"><span class="nav-number">1.7.2.</span> <span class="nav-text">Random</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">简单使用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">随机的基本原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81-%E5%AF%86%E7%A0%81"><span class="nav-number">1.7.2.3.</span> <span class="nav-text">随机验证码&#x2F;密码</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B4%97%E7%89%8C"><span class="nav-number">1.7.2.4.</span> <span class="nav-text">洗牌</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B8%A6%E6%9D%83%E9%87%8D%E7%9A%84%E9%9A%8F%E6%9C%BA"><span class="nav-number">1.7.2.5.</span> <span class="nav-text">带权重的随机</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8A%A2%E7%BA%A2%E5%8C%85%E7%AE%97%E6%B3%95"><span class="nav-number">1.7.2.6.</span> <span class="nav-text">抢红包算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.7.2.7.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lu Yan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
